{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-42e5c31243840a7d.js","node_modules/@parcel/runtime-js/lib/runtime-e2e4d22a19ef524c.js","node_modules/@parcel/runtime-js/lib/runtime-31eb60235fcb3727.js","node_modules/@parcel/runtime-js/lib/runtime-a73fb4ae4e881727.js","node_modules/@parcel/runtime-js/lib/runtime-92308e5f868488a5.js","node_modules/@parcel/runtime-js/lib/runtime-c04e17c3f9a9ee78.js","node_modules/@parcel/runtime-js/lib/runtime-9146bbc1357f8406.js","node_modules/excalibur/build/node_modules/core-js/es/array/sort.js","node_modules/excalibur/build/node_modules/core-js/es/object/keys.js","node_modules/excalibur/build/node_modules/core-js/internals/a-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/an-object.js","node_modules/excalibur/build/node_modules/core-js/internals/array-includes.js","node_modules/excalibur/build/node_modules/core-js/internals/array-method-is-strict.js","node_modules/excalibur/build/node_modules/core-js/internals/array-slice-simple.js","node_modules/excalibur/build/node_modules/core-js/internals/array-sort.js","node_modules/excalibur/build/node_modules/core-js/internals/classof-raw.js","node_modules/excalibur/build/node_modules/core-js/internals/classof.js","node_modules/excalibur/build/node_modules/core-js/internals/copy-constructor-properties.js","node_modules/excalibur/build/node_modules/core-js/internals/create-non-enumerable-property.js","node_modules/excalibur/build/node_modules/core-js/internals/create-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/create-property.js","node_modules/excalibur/build/node_modules/core-js/internals/define-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/define-global-property.js","node_modules/excalibur/build/node_modules/core-js/internals/delete-property-or-throw.js","node_modules/excalibur/build/node_modules/core-js/internals/descriptors.js","node_modules/excalibur/build/node_modules/core-js/internals/document-create-element.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-ff-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-is-ie-or-edge.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-user-agent.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-v8-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-webkit-version.js","node_modules/excalibur/build/node_modules/core-js/internals/entry-unbind.js","node_modules/excalibur/build/node_modules/core-js/internals/enum-bug-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/export.js","node_modules/excalibur/build/node_modules/core-js/internals/fails.js","node_modules/excalibur/build/node_modules/core-js/internals/function-bind-native.js","node_modules/excalibur/build/node_modules/core-js/internals/function-call.js","node_modules/excalibur/build/node_modules/core-js/internals/function-name.js","node_modules/excalibur/build/node_modules/core-js/internals/function-uncurry-this.js","node_modules/excalibur/build/node_modules/core-js/internals/get-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/get-method.js","node_modules/excalibur/build/node_modules/core-js/internals/global.js","node_modules/excalibur/build/node_modules/core-js/internals/has-own-property.js","node_modules/excalibur/build/node_modules/core-js/internals/hidden-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/ie8-dom-define.js","node_modules/excalibur/build/node_modules/core-js/internals/indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/inspect-source.js","node_modules/excalibur/build/node_modules/core-js/internals/internal-state.js","node_modules/excalibur/build/node_modules/core-js/internals/is-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/is-forced.js","node_modules/excalibur/build/node_modules/core-js/internals/is-object.js","node_modules/excalibur/build/node_modules/core-js/internals/is-pure.js","node_modules/excalibur/build/node_modules/core-js/internals/is-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/length-of-array-like.js","node_modules/excalibur/build/node_modules/core-js/internals/make-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/math-trunc.js","node_modules/excalibur/build/node_modules/core-js/internals/native-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/native-weak-map.js","node_modules/excalibur/build/node_modules/core-js/internals/object-define-property.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-names.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-symbols.js","node_modules/excalibur/build/node_modules/core-js/internals/object-is-prototype-of.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys-internal.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/object-property-is-enumerable.js","node_modules/excalibur/build/node_modules/core-js/internals/ordinary-to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/own-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/path.js","node_modules/excalibur/build/node_modules/core-js/internals/require-object-coercible.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-key.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-store.js","node_modules/excalibur/build/node_modules/core-js/internals/shared.js","node_modules/excalibur/build/node_modules/core-js/internals/to-absolute-index.js","node_modules/excalibur/build/node_modules/core-js/internals/to-indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-integer-or-infinity.js","node_modules/excalibur/build/node_modules/core-js/internals/to-length.js","node_modules/excalibur/build/node_modules/core-js/internals/to-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/to-property-key.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string-tag-support.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/try-to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/uid.js","node_modules/excalibur/build/node_modules/core-js/internals/use-symbol-as-uid.js","node_modules/excalibur/build/node_modules/core-js/internals/v8-prototype-define-bug.js","node_modules/excalibur/build/node_modules/core-js/internals/well-known-symbol.js","node_modules/excalibur/build/node_modules/core-js/modules/es.array.sort.js","node_modules/excalibur/build/node_modules/core-js/modules/es.object.keys.js","node_modules/excalibur/build/esm/webpack:/Loader.css","node_modules/excalibur/build/esm/webpack:/Util/Toaster.css","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/api.js","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/sourceMaps.js","node_modules/excalibur/build/esm/webpack:/webpack/bootstrap","node_modules/excalibur/build/esm/webpack:/webpack/runtime/compat get default export","node_modules/excalibur/build/esm/webpack:/webpack/runtime/define property getters","node_modules/excalibur/build/esm/webpack:/webpack/runtime/global","node_modules/excalibur/build/esm/webpack:/webpack/runtime/hasOwnProperty shorthand","node_modules/excalibur/build/esm/webpack:/webpack/runtime/make namespace object","node_modules/excalibur/build/esm/webpack:/Polyfill.ts","node_modules/excalibur/build/esm/webpack:/Flags.ts","node_modules/excalibur/build/esm/webpack:/Id.ts","node_modules/excalibur/build/esm/webpack:/Math/Random.ts","node_modules/excalibur/build/esm/webpack:/Math/util.ts","node_modules/excalibur/build/esm/webpack:/Math/vector.ts","node_modules/excalibur/build/esm/webpack:/Util/Log.ts","node_modules/excalibur/build/esm/webpack:/Color.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Graphic.ts","node_modules/excalibur/build/esm/webpack:/Collision/Side.ts","node_modules/excalibur/build/esm/webpack:/Collision/BoundingBox.ts","node_modules/excalibur/build/esm/webpack:/Util/Future.ts","node_modules/excalibur/build/esm/webpack:/Util/Util.ts","node_modules/excalibur/build/esm/webpack:/Math/matrix.ts","node_modules/excalibur/build/esm/webpack:/Math/affine-matrix.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/transform-stack.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/state-stack.ts","node_modules/excalibur/build/esm/webpack:/Events.ts","node_modules/excalibur/build/esm/webpack:/EventDispatcher.ts","node_modules/excalibur/build/esm/webpack:/Resources/Resource.ts","node_modules/excalibur/build/esm/webpack:/Util/Watch.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Sprite.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Filtering.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/texture-loader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/ImageSource.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteSheet.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteFont.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/debug-font.png","node_modules/excalibur/build/esm/webpack:/Graphics/Context/debug-text.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/render-source.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/render-target.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/webgl-adapter.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/line-renderer/line-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/webgl-util.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/vertex-buffer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/vertex-layout.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsDiagnostics.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/line-renderer/line-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-pass-painter.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/quad-index-buffer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/image-renderer/image-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/rectangle-renderer/rectangle-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/circle-renderer/circle-renderer.vert.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/circle-renderer/circle-renderer.ts","node_modules/excalibur/build/esm/webpack:/Util/Pool.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/draw-call.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContextWebGL.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts","node_modules/excalibur/build/esm/webpack:/Screen.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/AudioContext.ts","node_modules/excalibur/build/esm/webpack:/Util/WebAudio.ts","node_modules/excalibur/build/esm/webpack:/Class.ts","node_modules/excalibur/build/esm/webpack:/Util/DrawUtil.ts","node_modules/excalibur/build/esm/webpack:/Loader.logo.png","node_modules/excalibur/build/esm/webpack:/Graphics/Raster.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Canvas.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/AudioImplementation.ts","node_modules/excalibur/build/esm/webpack:/Util/StateMachine.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/WebAudioInstance.ts","node_modules/excalibur/build/esm/webpack:/Events/MediaEvents.ts","node_modules/excalibur/build/esm/webpack:/Util/Sound.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/Sound.ts","node_modules/excalibur/build/esm/webpack:/Loader.ts","node_modules/excalibur/build/esm/webpack:/Util/Detector.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionType.ts","node_modules/excalibur/build/esm/webpack:/Util/Decorators.ts","node_modules/excalibur/build/esm/webpack:/Collision/Physics.ts","node_modules/excalibur/build/esm/webpack:/Math/coord-plane.ts","node_modules/excalibur/build/esm/webpack:/Math/vector-view.ts","node_modules/excalibur/build/esm/webpack:/Math/watch-vector.ts","node_modules/excalibur/build/esm/webpack:/Math/transform.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Component.ts","node_modules/excalibur/build/esm/webpack:/Util/Observable.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/TransformComponent.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/MotionComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroup.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/Pair.ts","node_modules/excalibur/build/esm/webpack:/Math/projection.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTree.ts","node_modules/excalibur/build/esm/webpack:/Math/ray.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTreeCollisionProcessor.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CompositeCollider.ts","node_modules/excalibur/build/esm/webpack:/Math/line-segment.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/ClosestLineJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CircleCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/CollisionContact.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/SeparatingAxis.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CollisionJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/EdgeCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/PolygonCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/Shape.ts","node_modules/excalibur/build/esm/webpack:/Collision/ColliderComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/BodyComponent.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Entity.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Rectangle.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Circle.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerComponent.ts","node_modules/excalibur/build/esm/webpack:/Util/EasingFunctions.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionQueue.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Repeat.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RepeatForever.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/RotationType.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/CallMethod.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/EaseTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/EaseBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Blink.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Fade.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Delay.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Die.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Follow.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Meet.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionContext.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/FontCommon.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Font.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Text.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsGroup.ts","node_modules/excalibur/build/esm/webpack:/Input/Keyboard.ts","node_modules/excalibur/build/esm/webpack:/Actor.ts","node_modules/excalibur/build/esm/webpack:/ScreenElement.ts","node_modules/excalibur/build/esm/webpack:/Timer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/ParallaxComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/DebugGraphicsComponent.ts","node_modules/excalibur/build/esm/webpack:/TileMap/TileMap.ts","node_modules/excalibur/build/esm/webpack:/Camera.ts","node_modules/excalibur/build/esm/webpack:/Trigger.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/System.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/EntityManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Util.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Query.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/QueryManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/SystemManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/World.ts","node_modules/excalibur/build/esm/webpack:/Collision/Integrator.ts","node_modules/excalibur/build/esm/webpack:/Collision/MotionSystem.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ArcadeSolver.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ContactConstraintPoint.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/RealisticSolver.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionSystem.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Animation.ts","node_modules/excalibur/build/esm/webpack:/Configurable.ts","node_modules/excalibur/build/esm/webpack:/Particles.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsSystem.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugSystem.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerSystem.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsSystem.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricEntityComponent.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricEntitySystem.ts","node_modules/excalibur/build/esm/webpack:/Graphics/OffscreenSystem.ts","node_modules/excalibur/build/esm/webpack:/Scene.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ColorBlindnessMode.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/color-blind-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ScreenShader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ColorBlindnessPostProcessor.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugFlags.ts","node_modules/excalibur/build/esm/webpack:/Debug/Debug.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerScope.ts","node_modules/excalibur/build/esm/webpack:/Input/Gamepad.ts","node_modules/excalibur/build/esm/webpack:/Util/Browser.ts","node_modules/excalibur/build/esm/webpack:/Math/global-coordinates.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerEvent.ts","node_modules/excalibur/build/esm/webpack:/Input/WheelEvent.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerAbstraction.ts","node_modules/excalibur/build/esm/webpack:/Input/WheelDeltaMode.ts","node_modules/excalibur/build/esm/webpack:/Input/NativePointerButton.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerButton.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerType.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerEventReceiver.ts","node_modules/excalibur/build/esm/webpack:/Util/Fps.ts","node_modules/excalibur/build/esm/webpack:/Util/Clock.ts","node_modules/excalibur/build/esm/webpack:/Util/Toaster.ts","node_modules/excalibur/build/esm/webpack:/Engine.ts","node_modules/excalibur/build/esm/webpack:/Label.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricMap.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ActionSequence.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ParallelActions.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroupManager.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/LifecycleEvents.ts","node_modules/excalibur/build/esm/webpack:/Resources/Gif.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Line.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Polygon.ts","node_modules/excalibur/build/esm/webpack:/Util/Semaphore.ts","node_modules/excalibur/build/esm/webpack:/index.ts","src/loader.ts","src/main.ts"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"lrDsD\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"awSlu\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"2yrlS\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"fJaaQ\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"h8I7f\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"lwCtC\")).toString();","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"aT88m\\\":\\\"index.8e1b6af1.js\\\",\\\"lrDsD\\\":\\\"zombie1.098150cd.png\\\",\\\"awSlu\\\":\\\"zombie2.fff3b053.png\\\",\\\"2yrlS\\\":\\\"zombie3.5a754787.png\\\",\\\"fJaaQ\\\":\\\"zombie4.9a7067bb.png\\\",\\\"h8I7f\\\":\\\"zombie5.7f726c39.png\\\",\\\"lwCtC\\\":\\\"zombie6.46fdc101.png\\\"}\"));","require('../../modules/es.array.sort');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('Array', 'sort');\n","require('../../modules/es.object.keys');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.keys;\n","var isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw $TypeError(tryToString(argument) + ' is not a function');\n};\n","var isObject = require('../internals/is-object');\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw $TypeError($String(argument) + ' is not an object');\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n","var toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar createProperty = require('../internals/create-property');\n\nvar $Array = Array;\nvar max = Math.max;\n\nmodule.exports = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n","var arraySlice = require('../internals/array-slice-simple');\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice(array, 0, middle), comparefn),\n    mergeSort(arraySlice(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nmodule.exports = mergeSort;\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n","var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\nvar isCallable = require('../internals/is-callable');\nvar classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n","var hasOwn = require('../internals/has-own-property');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","'use strict';\nvar toPropertyKey = require('../internals/to-property-key');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n","var isCallable = require('../internals/is-callable');\nvar definePropertyModule = require('../internals/object-define-property');\nvar makeBuiltIn = require('../internals/make-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n","var global = require('../internals/global');\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","'use strict';\nvar tryToString = require('../internals/try-to-string');\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (O, P) {\n  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));\n};\n","var fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var userAgent = require('../internals/engine-user-agent');\n\nvar firefox = userAgent.match(/firefox\\/(\\d+)/i);\n\nmodule.exports = !!firefox && +firefox[1];\n","var UA = require('../internals/engine-user-agent');\n\nmodule.exports = /MSIE|Trident/.test(UA);\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","var global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n","var userAgent = require('../internals/engine-user-agent');\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nmodule.exports = !!webkit && +webkit[1];\n","var global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = function (CONSTRUCTOR, METHOD) {\n  return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);\n};\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar defineBuiltIn = require('../internals/define-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","var fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n","var NATIVE_BIND = require('../internals/function-bind-native');\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar hasOwn = require('../internals/has-own-property');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n","var NATIVE_BIND = require('../internals/function-bind-native');\n\nvar FunctionPrototype = Function.prototype;\nvar bind = FunctionPrototype.bind;\nvar call = FunctionPrototype.call;\nvar uncurryThis = NATIVE_BIND && bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? function (fn) {\n  return fn && uncurryThis(fn);\n} : function (fn) {\n  return fn && function () {\n    return call.apply(fn, arguments);\n  };\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n","var aCallable = require('../internals/a-callable');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n","var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar toObject = require('../internals/to-object');\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n","module.exports = {};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : $Object(it);\n} : $Object;\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis(store.get);\n  var wmhas = uncurryThis(store.has);\n  var wmset = uncurryThis(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument == 'function';\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n","module.exports = false;\n","var getBuiltIn = require('../internals/get-built-in');\nvar isCallable = require('../internals/is-callable');\nvar isPrototypeOf = require('../internals/object-is-prototype-of');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n","var toLength = require('../internals/to-length');\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\nvar hasOwn = require('../internals/has-own-property');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n","/* eslint-disable es-x/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar inspectSource = require('../internals/inspect-source');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar call = require('../internals/function-call');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar hasOwn = require('../internals/has-own-property');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar hasOwn = require('../internals/has-own-property');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","var call = require('../internals/function-call');\nvar isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw $TypeError(\"Can't convert object to primitive value\");\n};\n","var getBuiltIn = require('../internals/get-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n","var global = require('../internals/global');\n\nmodule.exports = global;\n","var $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw $TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","var global = require('../internals/global');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","var trunc = require('../internals/math-trunc');\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n","var call = require('../internals/function-call');\nvar isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw $TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n","var toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n","var classof = require('../internals/classof');\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n","var $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n","/* eslint-disable es-x/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar hasOwn = require('../internals/has-own-property');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar aCallable = require('../internals/a-callable');\nvar toObject = require('../internals/to-object');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar deletePropertyOrThrow = require('../internals/delete-property-or-throw');\nvar toString = require('../internals/to-string');\nvar fails = require('../internals/fails');\nvar internalSort = require('../internals/array-sort');\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar FF = require('../internals/engine-ff-version');\nvar IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');\nvar V8 = require('../internals/engine-v8-version');\nvar WEBKIT = require('../internals/engine-webkit-version');\n\nvar test = [];\nvar un$Sort = uncurryThis(test.sort);\nvar push = uncurryThis(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD = arrayMethodIsStrict('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString(x) > toString(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable(comparefn);\n\n    var array = toObject(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) deletePropertyOrThrow(array, index++);\n\n    return array;\n  }\n});\n","var $ = require('../internals/export');\nvar toObject = require('../internals/to-object');\nvar nativeKeys = require('../internals/object-keys');\nvar fails = require('../internals/fails');\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject(it));\n  }\n});\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./Loader.css\"],\"names\":[],\"mappings\":\"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF\",\"sourcesContent\":[\"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./Util/Toaster.css\"],\"names\":[],\"mappings\":\";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB\",\"sourcesContent\":[\"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import 'core-js/es/array/sort';\r\nimport 'core-js/es/object/keys';\r\n\r\n/**\r\n * Polyfill adding function\r\n */\r\nexport function polyfill() {\r\n  /* istanbul ignore next */\r\n  if (typeof window === 'undefined') {\r\n    window = <any>{\r\n      audioContext: function () {\r\n        return;\r\n      }\r\n    };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.requestAnimationFrame) {\r\n    (<any>window).requestAnimationFrame =\r\n      (<any>window).webkitRequestAnimationFrame ||\r\n      (<any>window).mozRequestAnimationFrame ||\r\n      function (callback: Function) {\r\n        window.setInterval(callback, 1000 / 60);\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {\r\n    (<any>window).cancelAnimationFrame =\r\n      (<any>window).webkitCancelAnimationFrame ||\r\n      (<any>window).mozCancelAnimationFrame ||\r\n      function () {\r\n        return;\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).AudioContext) {\r\n    if ((<any>window).webkitAudioContext) {\r\n      const ctx = (<any>window).webkitAudioContext;\r\n      const replaceMe = ctx.prototype.decodeAudioData;\r\n      (<any>window).webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer: ArrayBuffer) {\r\n        return new Promise((resolve, reject) => {\r\n          replaceMe.call(this, arrayBuffer, resolve, reject);\r\n        });\r\n      };\r\n    }\r\n\r\n    (<any>window).AudioContext =\r\n      (<any>window).AudioContext ||\r\n      (<any>window).webkitAudioContext ||\r\n      (<any>window).mozAudioContext ||\r\n      (<any>window).msAudioContext ||\r\n      (<any>window).oAudioContext;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).devicePixelRatio) {\r\n    (<any>window).devicePixelRatio = window.devicePixelRatio || 1;\r\n  }\r\n}\r\n","\r\n/**\r\n * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**\r\n * after which they are frozen and are read-only.\r\n *\r\n * Flags are used to enable experimental or preview features in Excalibur.\r\n */\r\nexport class Flags {\r\n  private static _FROZEN = false;\r\n  private static _FLAGS: Record<string, boolean> = {};\r\n\r\n\r\n  /**\r\n   * Force excalibur to load the Canvas 2D graphics context fallback\r\n   *\r\n   * @warning not all features of excalibur are supported in the Canvas 2D fallback\r\n   */\r\n  public static useCanvasGraphicsContext() {\r\n    Flags.enable('use-canvas-context');\r\n  }\r\n\r\n  /**\r\n   * Freeze all flag modifications making them readonly\r\n   */\r\n  public static freeze() {\r\n    Flags._FROZEN = true;\r\n  }\r\n\r\n  /**\r\n   * Resets internal flag state, not meant to be called by users. Only used for testing.\r\n   *\r\n   * Calling this in your game is UNSUPPORTED\r\n   * @internal\r\n   */\r\n  public static _reset() {\r\n    Flags._FROZEN = false;\r\n    Flags._FLAGS = {};\r\n  }\r\n  /**\r\n   * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static enable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be enabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = true;\r\n  }\r\n\r\n  /**\r\n   * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static disable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be disabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = false;\r\n  }\r\n\r\n  /**\r\n   * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned\r\n   * @param flagName\r\n   */\r\n  public static isEnabled(flagName: string): boolean {\r\n    return !!Flags._FLAGS[flagName];\r\n  }\r\n\r\n  /**\r\n   * Show a list of currently known flags\r\n   */\r\n  public static show(): string[] {\r\n    return Object.keys(Flags._FLAGS);\r\n  }\r\n}\r\n","export type Id<T extends string> = {\r\n  type: T,\r\n  value: number\r\n};\r\n\r\n/**\r\n * Create a branded ID type from a number\r\n */\r\nexport function createId<T extends string>(type: T, value: number): Id<T> {\r\n  return { type, value };\r\n};\r\n","/**\r\n * @module\r\n * Pseudo-Random Utility\r\n *\r\n * A pseudo-random utility to add seeded random support for help in\r\n * generating things like terrain or reproducible randomness. Uses the\r\n * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.\r\n */\r\n\r\n/**\r\n * 32-bit mask\r\n */\r\nconst BITMASK32: number = 0xffffffff;\r\n\r\n/**\r\n * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence\r\n * of numbers each time it is called.\r\n * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.\r\n * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\r\n *\r\n * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs\r\n */\r\nexport class Random {\r\n  // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1\r\n  private _lowerMask: number = 0x7fffffff; // 31 bits same as _r\r\n  private _upperMask: number = 0x80000000; // 34 high bits\r\n\r\n  // Word size, 64 bits\r\n  private _w: number = 32;\r\n\r\n  // Degree of recurrence\r\n  private _n: number = 624;\r\n\r\n  // Middle word, an offset used in the recurrence defining the series x, 1<=m<n\r\n  private _m: number = 397;\r\n  // coefficients of teh rational normal form twist matrix\r\n  private _a: number = 0x9908b0df;\r\n\r\n  // tempering bit shifts and masks\r\n  private _u: number = 11;\r\n  private _s: number = 7;\r\n  private _b: number = 0x9d2c5680;\r\n  private _t: number = 15;\r\n  private _c: number = 0xefc60000;\r\n  private _l: number = 18;\r\n  private _f: number = 1812433253;\r\n\r\n  private _mt: number[];\r\n\r\n  private _index: number;\r\n\r\n  /**\r\n   * If no seed is specified, the Date.now() is used\r\n   */\r\n  constructor(public seed?: number) {\r\n    this._mt = new Array<number>(this._n);\r\n    // need to mask to support higher bit machines\r\n    this._mt[0] = (seed || Date.now()) >>> 0;\r\n\r\n    for (let i = 1; i < this._n; i++) {\r\n      const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));\r\n      // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits\r\n      this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;\r\n    }\r\n    this._index = this._n;\r\n  }\r\n\r\n  /**\r\n   * Apply the twist\r\n   */\r\n  private _twist(): void {\r\n    const mag01 = [0x0, this._a];\r\n    let y = 0,\r\n      i = 0;\r\n    for (; i < this._n - this._m; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    for (; i < this._n - 1; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);\r\n    this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n\r\n    this._index = 0;\r\n  }\r\n\r\n  /**\r\n   * Return next 32 bit integer number in sequence\r\n   */\r\n  public nextInt(): number {\r\n    if (this._index >= this._n) {\r\n      this._twist();\r\n    }\r\n\r\n    let y = this._mt[this._index++];\r\n\r\n    y ^= y >>> this._u;\r\n    y ^= (y << this._s) & this._b;\r\n    y ^= (y << this._t) & this._c;\r\n    y ^= y >>> this._l;\r\n\r\n    return y >>> 0;\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point number between [0, 1)\r\n   */\r\n  public next(): number {\r\n    return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point in range [min, max) min is included, max is not included\r\n   */\r\n  public floating(min: number, max: number): number {\r\n    return (max - min) * this.next() + min;\r\n  }\r\n\r\n  /**\r\n   * Return a random integer in range [min, max] min is included, max is included.\r\n   * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a\r\n   */\r\n  public integer(min: number, max: number): number {\r\n    return Math.floor((max - min + 1) * this.next() + min);\r\n  }\r\n\r\n  /**\r\n   * Returns true or false randomly with 50/50 odds by default.\r\n   * By default the likelihood of returning a true is .5 (50%).\r\n   * @param likelihood takes values between [0, 1]\r\n   */\r\n  public bool(likelihood: number = 0.5): boolean {\r\n    return this.next() <= likelihood;\r\n  }\r\n\r\n  /**\r\n   * Returns one element from an array at random\r\n   */\r\n  public pickOne<T>(array: Array<T>): T {\r\n    return array[this.integer(0, array.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original\r\n   * @param array Original array to pick from\r\n   * @param numPicks can be any positive number\r\n   * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates\r\n   * just that it is possible)\r\n   */\r\n  public pickSet<T>(array: Array<T>, numPicks: number, allowDuplicates: boolean = false): Array<T> {\r\n    if (allowDuplicates) {\r\n      return this._pickSetWithDuplicates(array, numPicks);\r\n    } else {\r\n      return this._pickSetWithoutDuplicates(array, numPicks);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new array randomly picking elements in the original (not reused)\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks must be less than or equal to the number of elements in the array.\r\n   */\r\n  private _pickSetWithoutDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    if (numPicks > array.length || numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');\r\n    }\r\n    if (numPicks === array.length) {\r\n      return array;\r\n    }\r\n\r\n    const result: Array<T> = new Array<T>(numPicks);\r\n    let currentPick = 0;\r\n    const tempArray = array.slice(0);\r\n    while (currentPick < numPicks) {\r\n      const index = this.integer(0, tempArray.length - 1);\r\n      result[currentPick++] = tempArray[index];\r\n      tempArray.splice(index, 1);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original allowing duplicates\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks can be any positive number\r\n   */\r\n  private _pickSetWithDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)\r\n    if (numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');\r\n    }\r\n    const result = new Array<T>(numPicks);\r\n    for (let i = 0; i < numPicks; i++) {\r\n      result[i] = this.pickOne(array);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array that has its elements shuffled. Using the Fisher/Yates method\r\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n   */\r\n  public shuffle<T>(array: Array<T>): Array<T> {\r\n    const tempArray = array.slice(0);\r\n    let swap: T = null;\r\n    for (let i = 0; i < tempArray.length - 2; i++) {\r\n      const randomIndex = this.integer(i, tempArray.length - 1);\r\n      swap = tempArray[i];\r\n      tempArray[i] = tempArray[randomIndex];\r\n      tempArray[randomIndex] = swap;\r\n    }\r\n\r\n    return tempArray;\r\n  }\r\n\r\n  /**\r\n   * Generate a list of random integer numbers\r\n   * @param length the length of the final array\r\n   * @param min the minimum integer number to generate inclusive\r\n   * @param max the maximum integer number to generate inclusive\r\n   */\r\n  public range(length: number, min: number, max: number): Array<number> {\r\n    const result: Array<number> = new Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n      result[i] = this.integer(min, max);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d4 dice roll\r\n   */\r\n  public d4() {\r\n    return this.integer(1, 4);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d6 dice roll\r\n   */\r\n  public d6() {\r\n    return this.integer(1, 6);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d8 dice roll\r\n   */\r\n  public d8() {\r\n    return this.integer(1, 8);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d10 dice roll\r\n   */\r\n  public d10() {\r\n    return this.integer(1, 10);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d12 dice roll\r\n   */\r\n  public d12() {\r\n    return this.integer(1, 12);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d20 dice roll\r\n   */\r\n  public d20() {\r\n    return this.integer(1, 20);\r\n  }\r\n}\r\n","import { Random } from './Random';\r\n\r\n/**\r\n * Two PI constant\r\n */\r\nexport const TwoPI: number = Math.PI * 2;\r\n\r\n/**\r\n * Returns the fractional part of a number\r\n * @param x\r\n */\r\nexport function frac(x: number): number {\r\n  if (x >= 0) {\r\n    return x - Math.floor(x);\r\n  } else {\r\n    return x - Math.ceil(x);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the sign of a number, if 0 returns 0\r\n */\r\nexport function sign(val: number): number {\r\n  if (val === 0) {\r\n    return 0;\r\n  }\r\n  return val < 0 ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Clamps a value between a min and max inclusive\r\n */\r\nexport function clamp(val: number, min: number, max: number) {\r\n  return Math.min(Math.max(min, val), max);\r\n}\r\n\r\n\r\n/**\r\n * Convert an angle to be the equivalent in the range [0, 2PI]\r\n */\r\nexport function canonicalizeAngle(angle: number): number {\r\n  let tmpAngle = angle;\r\n  if (angle > TwoPI) {\r\n    while (tmpAngle > TwoPI) {\r\n      tmpAngle -= TwoPI;\r\n    }\r\n  }\r\n\r\n  if (angle < 0) {\r\n    while (tmpAngle < 0) {\r\n      tmpAngle += TwoPI;\r\n    }\r\n  }\r\n  return tmpAngle;\r\n}\r\n\r\n/**\r\n * Convert radians to degrees\r\n */\r\nexport function toDegrees(radians: number): number {\r\n  return (180 / Math.PI) * radians;\r\n}\r\n\r\n/**\r\n * Convert degrees to radians\r\n */\r\nexport function toRadians(degrees: number): number {\r\n  return (degrees / 180) * Math.PI;\r\n}\r\n\r\n/**\r\n * Generate a range of numbers\r\n * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]\r\n * @param from inclusive\r\n * @param to inclusive\r\n */\r\nexport const range = (from: number, to: number) => Array.from(new Array(to - from + 1), (_x, i) => i + from);\r\n\r\n/**\r\n * Find a random floating point number in range\r\n */\r\nexport function randomInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.floating(min, max) : min + Math.random() * (max - min);\r\n}\r\n\r\n/**\r\n * Find a random integer in a range\r\n */\r\nexport function randomIntInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.integer(min, max) : Math.round(randomInRange(min, max));\r\n}","import { Clonable } from '../Interfaces/Clonable';\r\nimport { clamp } from './util';\r\n\r\n/**\r\n * A 2D vector on a plane.\r\n */\r\n\r\nexport class Vector implements Clonable<Vector> {\r\n  /**\r\n   * A (0, 0) vector\r\n   */\r\n  public static get Zero() {\r\n    return new Vector(0, 0);\r\n  }\r\n\r\n  /**\r\n   * A (1, 1) vector\r\n   */\r\n  public static get One() {\r\n    return new Vector(1, 1);\r\n  }\r\n\r\n  /**\r\n   * A (0.5, 0.5) vector\r\n   */\r\n  public static get Half() {\r\n    return new Vector(0.5, 0.5);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing up (0, -1)\r\n   */\r\n  public static get Up() {\r\n    return new Vector(0, -1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing down (0, 1)\r\n   */\r\n  public static get Down() {\r\n    return new Vector(0, 1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing left (-1, 0)\r\n   */\r\n  public static get Left() {\r\n    return new Vector(-1, 0);\r\n  }\r\n  /**\r\n   * A unit vector pointing right (1, 0)\r\n   */\r\n  public static get Right() {\r\n    return new Vector(1, 0);\r\n  }\r\n\r\n  /**\r\n   * Returns a vector of unit length in the direction of the specified angle in Radians.\r\n   * @param angle The angle to generate the vector\r\n   */\r\n  public static fromAngle(angle: number) {\r\n    return new Vector(Math.cos(angle), Math.sin(angle));\r\n  }\r\n\r\n  /**\r\n   * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.\r\n   */\r\n  public static isValid(vec: Vector) {\r\n    if (vec === null || vec === undefined) {\r\n      return false;\r\n    }\r\n    if (isNaN(vec.x) || isNaN(vec.y)) {\r\n      return false;\r\n    }\r\n\r\n    if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calculates distance between two Vectors\r\n   * @param vec1\r\n   * @param vec2\r\n   */\r\n  public static distance(vec1: Vector, vec2: Vector) {\r\n    return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));\r\n  }\r\n\r\n  public static min(vec1: Vector, vec2: Vector) {\r\n    return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));\r\n  }\r\n\r\n  public static max(vec1: Vector, vec2: Vector) {\r\n    return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));\r\n  }\r\n\r\n  /**\r\n   * @param x  X component of the Vector\r\n   * @param y  Y component of the Vector\r\n   */\r\n  constructor(x: number, y: number) {\r\n    this._x = x;\r\n    this._y = y;\r\n  }\r\n\r\n  protected _x = 0;\r\n  /**\r\n   * Get the x component of the vector\r\n   */\r\n  public get x(): number {\r\n    return this._x;\r\n  }\r\n\r\n  /**\r\n   * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set x(val: number) {\r\n    this._x = val;\r\n  }\r\n\r\n  protected _y = 0;\r\n  /**\r\n   * Get the y component of the vector\r\n   */\r\n  public get y(): number {\r\n    return this._y;\r\n  }\r\n\r\n  /**\r\n   * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set y(val: number) {\r\n    this._y = val;\r\n  }\r\n\r\n  /**\r\n   * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   *\r\n   * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  setTo(x: number, y: number) {\r\n    (this.x as number) = x;\r\n    (this.y as number) = y;\r\n  }\r\n\r\n  /**\r\n   * Compares this point against another and tests for equality\r\n   * @param vector The other point to compare to\r\n   * @param tolerance Amount of euclidean distance off we are willing to tolerate\r\n   */\r\n  public equals(vector: Vector, tolerance: number = 0.001): boolean {\r\n    return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;\r\n  }\r\n\r\n  /**\r\n   * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].\r\n   * @param v  The other vector. Leave blank to use origin vector.\r\n   */\r\n  public distance(v?: Vector): number {\r\n    if (!v) {\r\n      return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n    const deltaX = this.x - v.x;\r\n    const deltaY = this.y - v.y;\r\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n  }\r\n\r\n  public squareDistance(v?: Vector): number {\r\n    if (!v) {\r\n      v = Vector.Zero;\r\n    }\r\n    const deltaX = this.x - v.x;\r\n    const deltaY = this.y - v.y;\r\n    return deltaX * deltaX + deltaY * deltaY;\r\n  }\r\n\r\n  /**\r\n   * Clamps the current vector's magnitude mutating it\r\n   * @param magnitude\r\n   */\r\n  public clampMagnitude(magnitude: number): Vector {\r\n    const size = this.size;\r\n    const newSize = clamp(size, 0, magnitude);\r\n    this.size = newSize;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * The size (magnitude) of the Vector\r\n   */\r\n  public get size(): number {\r\n    return this.distance();\r\n  }\r\n\r\n  /**\r\n   * Setting the size mutates the current vector\r\n   *\r\n   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  public set size(newLength: number) {\r\n    const v = this.normalize().scale(newLength);\r\n    this.setTo(v.x, v.y);\r\n  }\r\n\r\n  /**\r\n   * Normalizes a vector to have a magnitude of 1.\r\n   */\r\n  public normalize(): Vector {\r\n    const d = this.distance();\r\n    if (d > 0) {\r\n      return new Vector(this.x / d, this.y / d);\r\n    } else {\r\n      return new Vector(0, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the average (midpoint) between the current point and the specified\r\n   */\r\n  public average(vec: Vector): Vector {\r\n    return this.add(vec).scale(0.5);\r\n  }\r\n\r\n  /**\r\n   * Scales a vector's by a factor of size\r\n   * @param size  The factor to scale the magnitude by\r\n   * @param dest  Optionally provide a destination vector for the result\r\n   */\r\n  public scale(scale: Vector, dest?: Vector): Vector;\r\n  public scale(size: number, dest?: Vector): Vector;\r\n  public scale(sizeOrScale: number | Vector, dest?: Vector): Vector {\r\n    const result = dest || new Vector(0, 0);\r\n    if (sizeOrScale instanceof Vector) {\r\n      result.x = this.x * sizeOrScale.x;\r\n      result.y = this.y * sizeOrScale.y;\r\n    } else {\r\n      result.x = this.x * sizeOrScale;\r\n      result.y = this.y * sizeOrScale;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to another\r\n   * @param v The vector to add\r\n   * @param dest Optionally copy the result into a provided vector\r\n   */\r\n  public add(v: Vector, dest?: Vector): Vector {\r\n    if (dest) {\r\n      dest.x = this.x + v.x;\r\n      dest.y = this.y + v.y;\r\n      return dest;\r\n    }\r\n    return new Vector(this.x + v.x, this.y + v.y);\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B\r\n   * @param v The vector to subtract\r\n   */\r\n  public sub(v: Vector): Vector {\r\n    return new Vector(this.x - v.x, this.y - v.y);\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to this one modifying the original\r\n   * @param v The vector to add\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public addEqual(v: Vector): Vector {\r\n    this.setTo(this.x + v.x, this.y + v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from this one modifying the original\r\n   * @param v The vector to subtract\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public subEqual(v: Vector): Vector {\r\n    this.setTo(this.x - v.x, this.y - v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales this vector by a factor of size and modifies the original\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public scaleEqual(size: number): Vector {\r\n    this.setTo(this.x * size, this.y * size);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Performs a dot product with another vector\r\n   * @param v  The vector to dot\r\n   */\r\n  public dot(v: Vector): number {\r\n    return this.x * v.x + this.y * v.y;\r\n  }\r\n\r\n  /**\r\n   * Performs a 2D cross product with scalar. 2D cross products with a scalar return a vector.\r\n   * @param v  The scalar to cross\r\n   */\r\n  public cross(v: number): Vector;\r\n  /**\r\n   * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.\r\n   * @param v  The vector to cross\r\n   */\r\n  public cross(v: Vector): number;\r\n  public cross(v: any): any {\r\n    if (v instanceof Vector) {\r\n      return this.x * v.y - this.y * v.x;\r\n    } else if (typeof v === 'number') {\r\n      return new Vector(v * this.y, -v * this.x);\r\n    }\r\n  }\r\n\r\n  static cross(num: number, vec: Vector): Vector {\r\n    return new Vector(-num * vec.y, num * vec.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the perpendicular vector to this one\r\n   */\r\n  public perpendicular(): Vector {\r\n    return new Vector(this.y, -this.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the normal vector to this one, same as the perpendicular of length 1\r\n   */\r\n  public normal(): Vector {\r\n    return this.perpendicular().normalize();\r\n  }\r\n\r\n  /**\r\n   * Negate the current vector\r\n   */\r\n  public negate(): Vector {\r\n    return this.scale(-1);\r\n  }\r\n\r\n  /**\r\n   * Returns the angle of this vector.\r\n   */\r\n  public toAngle(): number {\r\n    return Math.atan2(this.y, this.x);\r\n  }\r\n\r\n  /**\r\n   * Rotates the current vector around a point by a certain number of\r\n   * degrees in radians\r\n   */\r\n  public rotate(angle: number, anchor?: Vector): Vector {\r\n    if (!anchor) {\r\n      anchor = new Vector(0, 0);\r\n    }\r\n    const sinAngle = Math.sin(angle);\r\n    const cosAngle = Math.cos(angle);\r\n    const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\r\n    const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\r\n    return new Vector(x, y);\r\n  }\r\n\r\n  /**\r\n   * Creates new vector that has the same values as the previous.\r\n   */\r\n  public clone(dest?: Vector): Vector {\r\n    const v = dest ?? new Vector(0, 0);\r\n    v.x = this.x;\r\n    v.y = this.y;\r\n    return v;\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of the vector.\r\n   */\r\n  public toString(fixed?: number): string {\r\n    if (fixed) {\r\n      return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;\r\n    }\r\n    return `(${this.x}, ${this.y})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Shorthand for creating new Vectors - returns a new Vector instance with the\r\n * provided X and Y components.\r\n *\r\n * @param x  X component of the Vector\r\n * @param y  Y component of the Vector\r\n */\r\nexport function vec(x: number, y: number): Vector {\r\n  return new Vector(x, y);\r\n}\r\n","/* eslint-disable no-console */\r\n/**\r\n * Logging level that Excalibur will tag\r\n */\r\nexport enum LogLevel {\r\n  Debug,\r\n  Info,\r\n  Warn,\r\n  Error,\r\n  Fatal\r\n}\r\n\r\n/**\r\n * Static singleton that represents the logging facility for Excalibur.\r\n * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].\r\n * Derive from [[Appender]] to create your own logging appenders.\r\n */\r\nexport class Logger {\r\n  private static _INSTANCE: Logger = null;\r\n  private _appenders: Appender[] = [];\r\n\r\n  constructor() {\r\n    if (Logger._INSTANCE) {\r\n      throw new Error('Logger is a singleton');\r\n    }\r\n    Logger._INSTANCE = this;\r\n    // Default console appender\r\n    Logger._INSTANCE.addAppender(new ConsoleAppender());\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the default logging level. Excalibur will only log\r\n   * messages if equal to or above this level. Default: [[LogLevel.Info]]\r\n   */\r\n  public defaultLevel: LogLevel = LogLevel.Info;\r\n\r\n  /**\r\n   * Gets the current static instance of Logger\r\n   */\r\n  public static getInstance(): Logger {\r\n    if (Logger._INSTANCE == null) {\r\n      Logger._INSTANCE = new Logger();\r\n    }\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Adds a new [[Appender]] to the list of appenders to write to\r\n   */\r\n  public addAppender(appender: Appender): void {\r\n    this._appenders.push(appender);\r\n  }\r\n\r\n  /**\r\n   * Clears all appenders from the logger\r\n   */\r\n  public clearAppenders(): void {\r\n    this._appenders.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Logs a message at a given LogLevel\r\n   * @param level  The LogLevel`to log the message at\r\n   * @param args   An array of arguments to write to an appender\r\n   */\r\n  private _log(level: LogLevel, args: any[]): void {\r\n    if (level == null) {\r\n      level = this.defaultLevel;\r\n    }\r\n\r\n    const len = this._appenders.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (level >= this.defaultLevel) {\r\n        this._appenders[i].log(level, args);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Debug]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public debug(...args: any[]): void {\r\n    this._log(LogLevel.Debug, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Info]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public info(...args: any[]): void {\r\n    this._log(LogLevel.Info, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Warn]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public warn(...args: any[]): void {\r\n    this._log(LogLevel.Warn, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Error]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public error(...args: any[]): void {\r\n    this._log(LogLevel.Error, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Fatal]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public fatal(...args: any[]): void {\r\n    this._log(LogLevel.Fatal, args);\r\n  }\r\n}\r\n\r\n/**\r\n * Contract for any log appender (such as console/screen)\r\n */\r\nexport interface Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  log(level: LogLevel, args: any[]): void;\r\n}\r\n\r\n/**\r\n * Console appender for browsers (i.e. `console.log`)\r\n */\r\nexport class ConsoleAppender implements Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    // Check for console support\r\n    if (!console && !console.log && console.warn && console.error) {\r\n      // todo maybe do something better than nothing\r\n      return;\r\n    }\r\n\r\n    // Create a new console args array\r\n    const consoleArgs: any[] = [];\r\n    consoleArgs.unshift.apply(consoleArgs, args);\r\n    consoleArgs.unshift('[' + LogLevel[level] + '] : ');\r\n\r\n    if (level < LogLevel.Warn) {\r\n      // Call .log for Debug/Info\r\n      if (console.log.apply) {\r\n        // this is required on some older browsers that don't support apply on console.log :(\r\n        console.log.apply(console, consoleArgs);\r\n      } else {\r\n        console.log(consoleArgs.join(' '));\r\n      }\r\n    } else if (level < LogLevel.Error) {\r\n      // Call .warn for Warn\r\n      if (console.warn.apply) {\r\n        console.warn.apply(console, consoleArgs);\r\n      } else {\r\n        console.warn(consoleArgs.join(' '));\r\n      }\r\n    } else {\r\n      // Call .error for Error/Fatal\r\n      if (console.error.apply) {\r\n        console.error.apply(console, consoleArgs);\r\n      } else {\r\n        console.error(consoleArgs.join(' '));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * On-screen (canvas) appender\r\n */\r\nexport class ScreenAppender implements Appender {\r\n  // @todo Clean this up\r\n\r\n  private _messages: string[] = [];\r\n  private _canvas: HTMLCanvasElement;\r\n  private _ctx: CanvasRenderingContext2D;\r\n\r\n  /**\r\n   * @param width   Width of the screen appender in pixels\r\n   * @param height  Height of the screen appender in pixels\r\n   */\r\n  constructor(width?: number, height?: number) {\r\n    this._canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    this._canvas.width = width || window.innerWidth;\r\n    this._canvas.height = height || window.innerHeight;\r\n    this._canvas.style.position = 'absolute';\r\n    // eslint-disable-next-line\r\n    this._ctx = <CanvasRenderingContext2D>this._canvas.getContext('2d'); // eslint-disable-line\r\n    document.body.appendChild(this._canvas);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    const message = args.join(',');\r\n\r\n    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n\r\n    this._messages.unshift('[' + LogLevel[level] + '] : ' + message);\r\n\r\n    let pos = 10;\r\n    let opacity = 1.0;\r\n    for (let i = 0; i < this._messages.length; i++) {\r\n      this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';\r\n      this._ctx.fillText(this._messages[i], 200, pos);\r\n      pos += 10;\r\n      opacity = opacity > 0 ? opacity - 0.05 : 0;\r\n    }\r\n  }\r\n}\r\n","\r\n/**\r\n * Provides standard colors (e.g. [[Color.Black]])\r\n * but you can also create custom colors using RGB, HSL, or Hex. Also provides\r\n * useful color operations like [[Color.lighten]], [[Color.darken]], and more.\r\n */\r\nexport class Color {\r\n  /**\r\n   * Red channel\r\n   */\r\n  public r: number;\r\n  /**\r\n   * Green channel\r\n   */\r\n  public g: number;\r\n  /**\r\n   * Blue channel\r\n   */\r\n  public b: number;\r\n  /**\r\n   * Alpha channel (between 0 and 1)\r\n   */\r\n  public a: number;\r\n\r\n  /**\r\n   * Hue\r\n   */\r\n  public h: number;\r\n  /**\r\n   * Saturation\r\n   */\r\n  public s: number;\r\n  /**\r\n   * Lightness\r\n   */\r\n  public l: number;\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  constructor(r: number, g: number, b: number, a?: number) {\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a != null ? a : 1;\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  public static fromRGB(r: number, g: number, b: number, a?: number): Color {\r\n    return new Color(r, g, b, a);\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a rgb string\r\n   *\r\n   * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)\r\n   */\r\n  public static fromRGBString(string: string): Color {\r\n    const rgbaRegEx: RegExp = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/i;\r\n    let match = null;\r\n    if ((match = string.match(rgbaRegEx))) {\r\n      const r = parseInt(match[1], 10);\r\n      const g = parseInt(match[2], 10);\r\n      const b = parseInt(match[3], 10);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseFloat(match[4]);\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid rgb/a string: ' + string);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a hex string\r\n   *\r\n   * @param hex  CSS color string of the form #ffffff, the alpha component is optional\r\n   */\r\n  public static fromHex(hex: string): Color {\r\n    const hexRegEx: RegExp = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\r\n    let match = null;\r\n    if ((match = hex.match(hexRegEx))) {\r\n      const r = parseInt(match[1], 16);\r\n      const g = parseInt(match[2], 16);\r\n      const b = parseInt(match[3], 16);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseInt(match[4], 16) / 255;\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid hex string: ' + hex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from hsla values\r\n   *\r\n   * @param h  Hue is represented [0-1]\r\n   * @param s  Saturation is represented [0-1]\r\n   * @param l  Luminance is represented [0-1]\r\n   * @param a  Alpha is represented [0-1]\r\n   */\r\n  public static fromHSL(h: number, s: number, l: number, a: number = 1.0): Color {\r\n    const temp = new HSLColor(h, s, l, a);\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Lightens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to lighten by [0-1]\r\n   */\r\n  public lighten(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l += (1 - temp.l) * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Darkens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to darken by [0-1]\r\n   */\r\n  public darken(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l -= temp.l * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Saturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to saturate by [0-1]\r\n   */\r\n  public saturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s += temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Desaturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to desaturate by [0-1]\r\n   */\r\n  public desaturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s -= temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Multiplies a color by another, results in a darker color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public multiply(color: Color): Color {\r\n    const newR = (((color.r / 255) * this.r) / 255) * 255;\r\n    const newG = (((color.g / 255) * this.g) / 255) * 255;\r\n    const newB = (((color.b / 255) * this.b) / 255) * 255;\r\n    const newA = color.a * this.a;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  /**\r\n   * Screens a color by another, results in a lighter color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public screen(color: Color): Color {\r\n    const color1 = color.invert();\r\n    const color2 = color.invert();\r\n    return color1.multiply(color2).invert();\r\n  }\r\n\r\n  /**\r\n   * Inverts the current color\r\n   */\r\n  public invert(): Color {\r\n    return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);\r\n  }\r\n\r\n  /**\r\n   * Averages the current color with another\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public average(color: Color): Color {\r\n    const newR = (color.r + this.r) / 2;\r\n    const newG = (color.g + this.g) / 2;\r\n    const newB = (color.b + this.b) / 2;\r\n    const newA = (color.a + this.a) / 2;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  public equal(color: Color): boolean {\r\n    return this.toString() === color.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   *\r\n   * @param format Color representation, accepts: rgb, hsl, or hex\r\n   */\r\n  public toString(format: 'rgb' | 'hsl' | 'hex' = 'rgb') {\r\n    switch (format) {\r\n      case 'rgb':\r\n        return this.toRGBA();\r\n      case 'hsl':\r\n        return this.toHSLA();\r\n      case 'hex':\r\n        return this.toHex();\r\n      default:\r\n        throw new Error('Invalid Color format');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns Hex Value of a color component\r\n   * @param c color component\r\n   * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n   */\r\n  private _componentToHex(c: number) {\r\n    const hex = c.toString(16);\r\n    return hex.length === 1 ? '0' + hex : hex;\r\n  }\r\n\r\n  /**\r\n   * Return Hex representation of a color.\r\n   */\r\n  public toHex() {\r\n    return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);\r\n  }\r\n\r\n  /**\r\n   * Return RGBA representation of a color.\r\n   */\r\n  public toRGBA() {\r\n    const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));\r\n    if (this.a !== undefined || this.a !== null) {\r\n      return 'rgba(' + result + ', ' + String(this.a) + ')';\r\n    }\r\n    return 'rgb(' + result + ')';\r\n  }\r\n\r\n  /**\r\n   * Return HSLA representation of a color.\r\n   */\r\n  public toHSLA() {\r\n    return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   */\r\n  public fillStyle() {\r\n    return this.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of the current color.\r\n   */\r\n  public clone(): Color {\r\n    return new Color(this.r, this.g, this.b, this.a);\r\n  }\r\n\r\n  /**\r\n   * Black (#000000)\r\n   */\r\n  public static get Black(): Color {\r\n    return Color.fromHex('#000000');\r\n  }\r\n\r\n  /**\r\n   * White (#FFFFFF)\r\n   */\r\n  public static get White(): Color {\r\n    return Color.fromHex('#FFFFFF');\r\n  }\r\n\r\n  /**\r\n   * Gray (#808080)\r\n   */\r\n  public static get Gray(): Color {\r\n    return Color.fromHex('#808080');\r\n  }\r\n\r\n  /**\r\n   * Light gray (#D3D3D3)\r\n   */\r\n  public static get LightGray(): Color {\r\n    return Color.fromHex('#D3D3D3');\r\n  }\r\n\r\n  /**\r\n   * Dark gray (#A9A9A9)\r\n   */\r\n  public static get DarkGray(): Color {\r\n    return Color.fromHex('#A9A9A9');\r\n  }\r\n\r\n  /**\r\n   * Yellow (#FFFF00)\r\n   */\r\n  public static get Yellow(): Color {\r\n    return Color.fromHex('#FFFF00');\r\n  }\r\n\r\n  /**\r\n   * Orange (#FFA500)\r\n   */\r\n  public static get Orange(): Color {\r\n    return Color.fromHex('#FFA500');\r\n  }\r\n\r\n  /**\r\n   * Red (#FF0000)\r\n   */\r\n  public static get Red(): Color {\r\n    return Color.fromHex('#FF0000');\r\n  }\r\n\r\n  /**\r\n   * Vermilion (#FF5B31)\r\n   */\r\n  public static get Vermilion(): Color {\r\n    return Color.fromHex('#FF5B31');\r\n  }\r\n\r\n  /**\r\n   * Rose (#FF007F)\r\n   */\r\n  public static get Rose(): Color {\r\n    return Color.fromHex('#FF007F');\r\n  }\r\n\r\n  /**\r\n   * Magenta (#FF00FF)\r\n   */\r\n  public static get Magenta(): Color {\r\n    return Color.fromHex('#FF00FF');\r\n  }\r\n\r\n  /**\r\n   * Violet (#7F00FF)\r\n   */\r\n  public static get Violet(): Color {\r\n    return Color.fromHex('#7F00FF');\r\n  }\r\n\r\n  /**\r\n   * Blue (#0000FF)\r\n   */\r\n  public static get Blue(): Color {\r\n    return Color.fromHex('#0000FF');\r\n  }\r\n\r\n  /**\r\n   * Azure (#007FFF)\r\n   */\r\n  public static get Azure(): Color {\r\n    return Color.fromHex('#007FFF');\r\n  }\r\n\r\n  /**\r\n   * Cyan (#00FFFF)\r\n   */\r\n  public static get Cyan(): Color {\r\n    return Color.fromHex('#00FFFF');\r\n  }\r\n\r\n  /**\r\n   * Viridian (#59978F)\r\n   */\r\n  public static get Viridian(): Color {\r\n    return Color.fromHex('#59978F');\r\n  }\r\n\r\n  /**\r\n   * Green (#00FF00)\r\n   */\r\n  public static get Green(): Color {\r\n    return Color.fromHex('#00FF00');\r\n  }\r\n\r\n  /**\r\n   * Chartreuse (#7FFF00)\r\n   */\r\n  public static get Chartreuse(): Color {\r\n    return Color.fromHex('#7FFF00');\r\n  }\r\n\r\n  /**\r\n   * Transparent (#FFFFFF00)\r\n   */\r\n  public static get Transparent(): Color {\r\n    return Color.fromHex('#FFFFFF00');\r\n  }\r\n\r\n  /**\r\n   * ExcaliburBlue (#176BAA)\r\n   */\r\n  public static get ExcaliburBlue(): Color {\r\n    return Color.fromHex('#176BAA');\r\n  }\r\n}\r\n\r\n/**\r\n * Internal HSL Color representation\r\n *\r\n * http://en.wikipedia.org/wiki/HSL_and_HSV\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n */\r\nclass HSLColor {\r\n  constructor(public h: number, public s: number, public l: number, public a: number) {}\r\n\r\n  public static hue2rgb(p: number, q: number, t: number): number {\r\n    if (t < 0) {\r\n      t += 1;\r\n    }\r\n    if (t > 1) {\r\n      t -= 1;\r\n    }\r\n    if (t < 1 / 6) {\r\n      return p + (q - p) * 6 * t;\r\n    }\r\n    if (t < 1 / 2) {\r\n      return q;\r\n    }\r\n    if (t < 2 / 3) {\r\n      return p + (q - p) * (2 / 3 - t) * 6;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public static fromRGBA(r: number, g: number, b: number, a: number): HSLColor {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n    const max = Math.max(r, g, b),\r\n      min = Math.min(r, g, b);\r\n    let h, s;\r\n    const l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0; // achromatic\r\n    } else {\r\n      const d = max - min;\r\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      switch (max) {\r\n        case r:\r\n          h = (g - b) / d + (g < b ? 6 : 0);\r\n          break;\r\n        case g:\r\n          h = (b - r) / d + 2;\r\n          break;\r\n        case b:\r\n          h = (r - g) / d + 4;\r\n          break;\r\n      }\r\n      h /= 6;\r\n    }\r\n\r\n    return new HSLColor(h, s, l, a);\r\n  }\r\n\r\n  public toRGBA(): Color {\r\n    let r: number, g: number, b: number;\r\n\r\n    if (this.s === 0) {\r\n      r = g = b = this.l; // achromatic\r\n    } else {\r\n      const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;\r\n      const p = 2 * this.l - q;\r\n      r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);\r\n      g = HSLColor.hue2rgb(p, q, this.h);\r\n      b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);\r\n    }\r\n\r\n    return new Color(r * 255, g * 255, b * 255, this.a);\r\n  }\r\n\r\n  public toString(): string {\r\n    const h = this.h.toFixed(0),\r\n      s = this.s.toFixed(0),\r\n      l = this.l.toFixed(0),\r\n      a = this.a.toFixed(0);\r\n    return `hsla(${h}, ${s}, ${l}, ${a})`;\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { watch } from '../Util/Watch';\r\nimport { AffineMatrix } from '../Math/affine-matrix';\r\n\r\nexport interface GraphicOptions {\r\n  /**\r\n   * The width of the graphic\r\n   */\r\n  width?: number;\r\n  /**\r\n   * The height of the graphic\r\n   */\r\n  height?: number;\r\n  /**\r\n   * Should the graphic be flipped horizontally\r\n   */\r\n  flipHorizontal?: boolean;\r\n  /**\r\n   * Should the graphic be flipped vertically\r\n   */\r\n  flipVertical?: boolean;\r\n  /**\r\n   * The rotation of the graphic\r\n   */\r\n  rotation?: number;\r\n  /**\r\n   * The scale of the graphic\r\n   */\r\n  scale?: Vector;\r\n  /**\r\n   * The opacity of the graphic\r\n   */\r\n  opacity?: number;\r\n  /**\r\n   * The tint of the graphic, this color will be multiplied by the original pixel colors\r\n   */\r\n  tint?: Color;\r\n  /**\r\n   * The origin of the drawing in pixels to use when applying transforms, by default it will be the center of the image\r\n   */\r\n  origin?: Vector;\r\n}\r\n\r\n/**\r\n * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].\r\n * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the\r\n * [[Graphic]] abstract class.\r\n *\r\n * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic\r\n * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]\r\n */\r\nexport abstract class Graphic {\r\n  private static _ID: number = 0;\r\n  readonly id = Graphic._ID++;\r\n\r\n  public transform: AffineMatrix = AffineMatrix.identity();\r\n  public tint: Color = null;\r\n\r\n  private _transformStale = true;\r\n  public isStale() {\r\n    return this._transformStale;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets wether to show debug information about the graphic\r\n   */\r\n  public showDebug: boolean = false;\r\n\r\n\r\n  private _flipHorizontal = false;\r\n  /**\r\n   * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)\r\n   */\r\n  public get flipHorizontal(): boolean {\r\n    return this._flipHorizontal;\r\n  }\r\n\r\n  public set flipHorizontal(value: boolean) {\r\n    this._flipHorizontal = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _flipVertical = false;\r\n  /**\r\n   * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)\r\n   */\r\n  public get flipVertical(): boolean {\r\n    return this._flipVertical;\r\n  }\r\n\r\n  public set flipVertical(value: boolean) {\r\n    this._flipVertical = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _rotation = 0;\r\n  /**\r\n   * Gets or sets the rotation of the graphic\r\n   */\r\n  public get rotation(): number {\r\n    return this._rotation;\r\n  }\r\n\r\n  public set rotation(value: number) {\r\n    this._rotation = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).\r\n   */\r\n  public opacity: number = 1;\r\n\r\n  private _scale = Vector.One;\r\n  /**\r\n   * Gets or sets the scale of the graphic, this affects the width and\r\n   */\r\n  public get scale() {\r\n    return this._scale;\r\n  }\r\n\r\n  public set scale(value: Vector) {\r\n    this._scale = watch(value, () => {\r\n      this._transformStale = true;\r\n    });\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _origin: Vector | null = null;\r\n  /**\r\n   * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin\r\n   */\r\n  public get origin(): Vector | null {\r\n    return this._origin;\r\n  }\r\n\r\n  public set origin(value: Vector | null) {\r\n    this._origin = watch(value, () => {\r\n      this._transformStale = true;\r\n    });\r\n    this._transformStale = true;\r\n  }\r\n\r\n  constructor(options?: GraphicOptions) {\r\n    if (options) {\r\n      this.origin = options.origin ?? this.origin;\r\n      this.flipHorizontal = options.flipHorizontal ?? this.flipHorizontal;\r\n      this.flipVertical = options.flipVertical ?? this.flipVertical;\r\n      this.rotation = options.rotation ?? this.rotation;\r\n      this.opacity = options.opacity ?? this.opacity;\r\n      this.scale = options.scale ?? this.scale;\r\n    }\r\n  }\r\n\r\n  public cloneGraphicOptions(): GraphicOptions {\r\n    return {\r\n      origin: this.origin ? this.origin.clone() : null,\r\n      flipHorizontal: this.flipHorizontal,\r\n      flipVertical: this.flipVertical,\r\n      rotation: this.rotation,\r\n      opacity: this.opacity,\r\n      scale: this.scale ? this.scale.clone() : null\r\n    };\r\n  }\r\n\r\n  private _width: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the width of the graphic (always positive)\r\n   */\r\n  public get width() {\r\n    return Math.abs(this._width * this.scale.x);\r\n  }\r\n\r\n  private _height: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the height of the graphic (always positive)\r\n   */\r\n  public get height() {\r\n    return Math.abs(this._height * this.scale.y);\r\n  }\r\n\r\n  public set width(value: number) {\r\n    this._width = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  public set height(value: number) {\r\n    this._height = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  /**\r\n   * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);\r\n  }\r\n\r\n  /**\r\n   * Draw the whole graphic to the context including transform\r\n   * @param ex The excalibur graphics context\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public draw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    this._preDraw(ex, x, y);\r\n    this._drawImage(ex, 0, 0);\r\n    this._postDraw(ex);\r\n  }\r\n\r\n  /**\r\n   * Meant to be overridden by the graphic implementation to draw the underlying image (HTMLCanvasElement or HTMLImageElement)\r\n   * to the graphics context without transform. Transformations like position, rotation, and scale are handled by [[Graphic._preDraw]]\r\n   * and [[Graphic._postDraw]]\r\n   * @param ex The excalibur graphics context\r\n   * @param x\r\n   * @param y\r\n   */\r\n  protected abstract _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void;\r\n\r\n  /**\r\n   * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]\r\n   * @param ex\r\n   * @param x\r\n   * @param y\r\n   */\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    ex.save();\r\n    ex.translate(x, y);\r\n    if (this._transformStale) {\r\n      this.transform.reset();\r\n      this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));\r\n      this._rotate(this.transform);\r\n      this._flip(this.transform);\r\n      this._transformStale = false;\r\n    }\r\n    ex.multiply(this.transform);\r\n    // it is important to multiply alphas so graphics respect the current context\r\n    ex.opacity = ex.opacity * this.opacity;\r\n    if (this.tint) {\r\n      ex.tint = this.tint;\r\n    }\r\n  }\r\n\r\n  protected _rotate(ex: ExcaliburGraphicsContext | AffineMatrix) {\r\n    const scaleDirX = this.scale.x > 0 ? 1 : -1;\r\n    const scaleDirY = this.scale.y > 0 ? 1 : -1;\r\n    const origin = this.origin ?? vec(this.width / 2, this.height / 2);\r\n    ex.translate(origin.x, origin.y);\r\n    ex.rotate(this.rotation);\r\n    // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()\r\n    ex.scale(scaleDirX, scaleDirY);\r\n    ex.translate(-origin.x, -origin.y);\r\n  }\r\n\r\n  protected _flip(ex: ExcaliburGraphicsContext | AffineMatrix) {\r\n    if (this.flipHorizontal) {\r\n      ex.translate(this.width / this.scale.x, 0);\r\n      ex.scale(-1, 1);\r\n    }\r\n\r\n    if (this.flipVertical) {\r\n      ex.translate(0, this.height / this.scale.y);\r\n      ex.scale(1, -1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply any additional work after [[Graphic._drawImage]] and restore the context state.\r\n   * @param ex\r\n   */\r\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\r\n    if (this.showDebug) {\r\n      ex.debug.drawRect(0, 0, this.width, this.height);\r\n    }\r\n    ex.restore();\r\n  }\r\n\r\n  /**\r\n   * Returns a new instance of the graphic that has the same properties\r\n   */\r\n  abstract clone(): Graphic;\r\n}\r\n","import { Vector } from '../Math/vector';\r\n\r\n/**\r\n * An enum that describes the sides of an axis aligned box for collision\r\n */\r\nexport enum Side {\r\n  None = 'None',\r\n  Top = 'Top',\r\n  Bottom = 'Bottom',\r\n  Left = 'Left',\r\n  Right = 'Right'\r\n}\r\n\r\nexport module Side {\r\n  /**\r\n   * Returns the opposite side from the current\r\n   */\r\n  export function getOpposite(side: Side): Side {\r\n    if (side === Side.Top) {\r\n      return Side.Bottom;\r\n    }\r\n    if (side === Side.Bottom) {\r\n      return Side.Top;\r\n    }\r\n    if (side === Side.Left) {\r\n      return Side.Right;\r\n    }\r\n    if (side === Side.Right) {\r\n      return Side.Left;\r\n    }\r\n\r\n    return Side.None;\r\n  }\r\n\r\n  /**\r\n   * Given a vector, return the Side most in that direction (via dot product)\r\n   */\r\n  export function fromDirection(direction: Vector): Side {\r\n    const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];\r\n    const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];\r\n\r\n    let max = -Number.MAX_VALUE;\r\n    let maxIndex = -1;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      if (directions[i].dot(direction) > max) {\r\n        max = directions[i].dot(direction);\r\n        maxIndex = i;\r\n      }\r\n    }\r\n    return directionEnum[maxIndex];\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Ray } from '../Math/ray';\r\nimport { Color } from '../Color';\r\nimport { Side } from './Side';\r\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { AffineMatrix } from '../Math/affine-matrix';\r\n\r\nexport interface BoundingBoxOptions {\r\n  left: number;\r\n  right: number;\r\n  top: number;\r\n  bottom: number;\r\n}\r\n\r\n/**\r\n * Axis Aligned collision primitive for Excalibur.\r\n */\r\nexport class BoundingBox {\r\n  public top: number;\r\n  public right: number;\r\n  public bottom: number;\r\n  public left: number;\r\n\r\n  /**\r\n   * Constructor allows passing of either an object with all coordinate components,\r\n   * or the coordinate components passed separately.\r\n   * @param leftOrOptions    Either x coordinate of the left edge or an options object\r\n   * containing the four coordinate components.\r\n   * @param top     y coordinate of the top edge\r\n   * @param right   x coordinate of the right edge\r\n   * @param bottom  y coordinate of the bottom edge\r\n   */\r\n  constructor(leftOrOptions: number | BoundingBoxOptions = 0, top: number = 0, right: number = 0, bottom: number = 0) {\r\n    if (typeof leftOrOptions === 'object') {\r\n      this.left = leftOrOptions.left;\r\n      this.top = leftOrOptions.top;\r\n      this.right = leftOrOptions.right;\r\n      this.bottom = leftOrOptions.bottom;\r\n    } else if (typeof leftOrOptions === 'number') {\r\n      this.left = leftOrOptions;\r\n      this.top = top;\r\n      this.right = right;\r\n      this.bottom = bottom;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new instance of [[BoundingBox]] that is a copy of the current instance\r\n   */\r\n  public clone(): BoundingBox {\r\n    return new BoundingBox(this.left, this.top, this.right, this.bottom);\r\n  }\r\n\r\n  /**\r\n   * Given bounding box A & B, returns the side relative to A when intersection is performed.\r\n   * @param intersection Intersection vector between 2 bounding boxes\r\n   */\r\n  public static getSideFromIntersection(intersection: Vector): Side {\r\n    if (!intersection) {\r\n      return Side.None;\r\n    }\r\n    if (intersection) {\r\n      if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\r\n        if (intersection.x < 0) {\r\n          return Side.Right;\r\n        }\r\n        return Side.Left;\r\n      } else {\r\n        if (intersection.y < 0) {\r\n          return Side.Bottom;\r\n        }\r\n        return Side.Top;\r\n      }\r\n    }\r\n    return Side.None;\r\n  }\r\n\r\n  public static fromPoints(points: Vector[]): BoundingBox {\r\n    let minX = Infinity;\r\n    let minY = Infinity;\r\n    let maxX = -Infinity;\r\n    let maxY = -Infinity;\r\n    for (let i = 0; i < points.length; i++) {\r\n      if (points[i].x < minX) {\r\n        minX = points[i].x;\r\n      }\r\n      if (points[i].x > maxX) {\r\n        maxX = points[i].x;\r\n      }\r\n      if (points[i].y < minY) {\r\n        minY = points[i].y;\r\n      }\r\n      if (points[i].y > maxY) {\r\n        maxY = points[i].y;\r\n      }\r\n    }\r\n    return new BoundingBox(minX, minY, maxX, maxY);\r\n  }\r\n\r\n  public static fromDimension(width: number, height: number, anchor: Vector = Vector.Half, pos: Vector = Vector.Zero) {\r\n    return new BoundingBox(\r\n      -width * anchor.x + pos.x,\r\n      -height * anchor.y + pos.y,\r\n      width - width * anchor.x + pos.x,\r\n      height - height * anchor.y + pos.y\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the calculated width of the bounding box\r\n   */\r\n  public get width() {\r\n    return this.right - this.left;\r\n  }\r\n\r\n  /**\r\n   * Returns the calculated height of the bounding box\r\n   */\r\n  public get height() {\r\n    return this.bottom - this.top;\r\n  }\r\n\r\n  /**\r\n   * Return whether the bounding box has zero dimensions in height,width or both\r\n   */\r\n  public hasZeroDimensions() {\r\n    return this.width === 0 || this.height === 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the center of the bounding box\r\n   */\r\n  public get center(): Vector {\r\n    return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);\r\n  }\r\n\r\n  public translate(pos: Vector): BoundingBox {\r\n    return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);\r\n  }\r\n\r\n  /**\r\n   * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding\r\n   * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.\r\n   */\r\n  public rotate(angle: number, point: Vector = Vector.Zero): BoundingBox {\r\n    const points = this.getPoints().map((p) => p.rotate(angle, point));\r\n    return BoundingBox.fromPoints(points);\r\n  }\r\n\r\n  /**\r\n   * Scale a bounding box by a scale factor, optionally provide a point\r\n   * @param scale\r\n   * @param point\r\n   */\r\n  public scale(scale: Vector, point: Vector = Vector.Zero): BoundingBox {\r\n    const shifted = this.translate(point);\r\n    return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);\r\n  }\r\n\r\n  /**\r\n   * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box\r\n   * @param matrix\r\n   */\r\n  public transform(matrix: AffineMatrix) {\r\n    // inlined these calculations to not use vectors would speed it up slightly\r\n    // const matFirstColumn = vec(matrix.data[0], matrix.data[1]);\r\n    // const xa = matFirstColumn.scale(this.left);\r\n    const xa1 = matrix.data[0] * this.left;\r\n    const xa2 = matrix.data[1] * this.left;\r\n\r\n    // const xb = matFirstColumn.scale(this.right);\r\n    const xb1 = matrix.data[0] * this.right;\r\n    const xb2 = matrix.data[1] * this.right;\r\n\r\n    // const matSecondColumn = vec(matrix.data[2], matrix.data[3]);\r\n    // const ya = matSecondColumn.scale(this.top);\r\n    const ya1 = matrix.data[2] * this.top;\r\n    const ya2 = matrix.data[3] * this.top;\r\n\r\n    // const yb = matSecondColumn.scale(this.bottom);\r\n    const yb1 = matrix.data[2] * this.bottom;\r\n    const yb2 = matrix.data[3] * this.bottom;\r\n\r\n    const matrixPos = matrix.getPosition();\r\n    // const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);\r\n    // const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);\r\n    const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;\r\n    const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;\r\n    const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;\r\n    const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;\r\n\r\n    return new BoundingBox({\r\n      left,//: topLeft.x,\r\n      top,//: topLeft.y,\r\n      right,//: bottomRight.x,\r\n      bottom//: bottomRight.y\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the perimeter of the bounding box\r\n   */\r\n  public getPerimeter(): number {\r\n    const wx = this.width;\r\n    const wy = this.height;\r\n    return 2 * (wx + wy);\r\n  }\r\n\r\n  public getPoints(): Vector[] {\r\n    const results = [];\r\n    results.push(new Vector(this.left, this.top));\r\n    results.push(new Vector(this.right, this.top));\r\n    results.push(new Vector(this.right, this.bottom));\r\n    results.push(new Vector(this.left, this.bottom));\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Determines whether a ray intersects with a bounding box\r\n   */\r\n  public rayCast(ray: Ray, farClipDistance = Infinity): boolean {\r\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n    let tmin = -Infinity;\r\n    let tmax = +Infinity;\r\n\r\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n\r\n    const tx1 = (this.left - ray.pos.x) * xinv;\r\n    const tx2 = (this.right - ray.pos.x) * xinv;\r\n    tmin = Math.min(tx1, tx2);\r\n    tmax = Math.max(tx1, tx2);\r\n\r\n    const ty1 = (this.top - ray.pos.y) * yinv;\r\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n\r\n    return tmax >= Math.max(0, tmin) && tmin < farClipDistance;\r\n  }\r\n\r\n  public rayCastTime(ray: Ray, farClipDistance = Infinity): number {\r\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n    let tmin = -Infinity;\r\n    let tmax = +Infinity;\r\n\r\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n\r\n    const tx1 = (this.left - ray.pos.x) * xinv;\r\n    const tx2 = (this.right - ray.pos.x) * xinv;\r\n    tmin = Math.min(tx1, tx2);\r\n    tmax = Math.max(tx1, tx2);\r\n\r\n    const ty1 = (this.top - ray.pos.y) * yinv;\r\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n\r\n    if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {\r\n      return tmin;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Tests whether a point is contained within the bounding box\r\n   * @param p  The point to test\r\n   */\r\n  public contains(p: Vector): boolean;\r\n\r\n  /**\r\n   * Tests whether another bounding box is totally contained in this one\r\n   * @param bb  The bounding box to test\r\n   */\r\n  public contains(bb: BoundingBox): boolean;\r\n  public contains(val: any): boolean {\r\n    if (val instanceof Vector) {\r\n      return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;\r\n    } else if (val instanceof BoundingBox) {\r\n      if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Combines this bounding box and another together returning a new bounding box\r\n   * @param other  The bounding box to combine\r\n   */\r\n  public combine(other: BoundingBox): BoundingBox {\r\n    const compositeBB = new BoundingBox(\r\n      Math.min(this.left, other.left),\r\n      Math.min(this.top, other.top),\r\n      Math.max(this.right, other.right),\r\n      Math.max(this.bottom, other.bottom)\r\n    );\r\n    return compositeBB;\r\n  }\r\n\r\n  public get dimensions(): Vector {\r\n    return new Vector(this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * Returns true if the bounding boxes overlap.\r\n   * @param other\r\n   * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.\r\n   * This epsilon is useful in stable collision simulations.\r\n   */\r\n  public overlaps(other: BoundingBox, epsilon?: number): boolean {\r\n    const e = epsilon || 0;\r\n    if (other.hasZeroDimensions()){\r\n      return this.contains(other);\r\n    }\r\n    if (this.hasZeroDimensions()) {\r\n      return other.contains(this);\r\n    }\r\n    const totalBoundingBox = this.combine(other);\r\n    return totalBoundingBox.width + e < other.width + this.width &&\r\n           totalBoundingBox.height + e < other.height + this.height;\r\n  }\r\n\r\n  /**\r\n   * Test wether this bounding box intersects with another returning\r\n   * the intersection vector that can be used to resolve the collision. If there\r\n   * is no intersection null is returned.\r\n   *\r\n   * @param other  Other [[BoundingBox]] to test intersection with\r\n   * @returns A Vector in the direction of the current BoundingBox, this <- other\r\n   */\r\n  public intersect(other: BoundingBox): Vector {\r\n    const totalBoundingBox = this.combine(other);\r\n\r\n    // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision\r\n    if (\r\n      totalBoundingBox.width < other.width + this.width &&\r\n      totalBoundingBox.height < other.height + this.height &&\r\n      !totalBoundingBox.dimensions.equals(other.dimensions) &&\r\n      !totalBoundingBox.dimensions.equals(this.dimensions)\r\n    ) {\r\n      // collision\r\n      let overlapX = 0;\r\n      // right edge is between the other's left and right edge\r\n      /**\r\n       *     +-this-+\r\n       *     |      |\r\n       *     |    +-other-+\r\n       *     +----|-+     |\r\n       *          |       |\r\n       *          +-------+\r\n       *         <---\r\n       *          ^ overlap\r\n       */\r\n      if (this.right >= other.left && this.right <= other.right) {\r\n        overlapX = other.left - this.right;\r\n        // right edge is past the other's right edge\r\n        /**\r\n         *     +-other-+\r\n         *     |       |\r\n         *     |    +-this-+\r\n         *     +----|--+   |\r\n         *          |      |\r\n         *          +------+\r\n         *          --->\r\n         *          ^ overlap\r\n         */\r\n      } else {\r\n        overlapX = other.right - this.left;\r\n      }\r\n\r\n      let overlapY = 0;\r\n      // top edge is between the other's top and bottom edge\r\n      /**\r\n       *     +-other-+\r\n       *     |       |\r\n       *     |    +-this-+   | <- overlap\r\n       *     +----|--+   |   |\r\n       *          |      |  \\ /\r\n       *          +------+   '\r\n       */\r\n      if (this.top <= other.bottom && this.top >= other.top) {\r\n        overlapY = other.bottom - this.top;\r\n        // top edge is above the other top edge\r\n        /**\r\n         *     +-this-+         .\r\n         *     |      |        / \\\r\n         *     |    +-other-+   | <- overlap\r\n         *     +----|-+     |   |\r\n         *          |       |\r\n         *          +-------+\r\n         */\r\n      } else {\r\n        overlapY = other.top - this.bottom;\r\n      }\r\n\r\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n        return new Vector(overlapX, 0);\r\n      } else {\r\n        return new Vector(0, overlapY);\r\n      }\r\n      // Case of total containment of one bounding box by another\r\n    } else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {\r\n      let overlapX = 0;\r\n      // this is wider than the other\r\n      if (this.width - other.width >= 0) {\r\n        // This right edge is closest to the others right edge\r\n        if (this.right - other.right <= other.left - this.left) {\r\n          overlapX = other.left - this.right;\r\n          // This left edge is closest to the others left edge\r\n        } else {\r\n          overlapX = other.right - this.left;\r\n        }\r\n        // other is wider than this\r\n      } else {\r\n        // This right edge is closest to the others right edge\r\n        if (other.right - this.right <= this.left - other.left) {\r\n          overlapX = this.left - other.right;\r\n          // This left edge is closest to the others left edge\r\n        } else {\r\n          overlapX = this.right - other.left;\r\n        }\r\n      }\r\n\r\n      let overlapY = 0;\r\n      // this is taller than other\r\n      if (this.height - other.height >= 0) {\r\n        // The bottom edge is closest to the others bottom edge\r\n        if (this.bottom - other.bottom <= other.top - this.top) {\r\n          overlapY = other.top - this.bottom;\r\n        } else {\r\n          overlapY = other.bottom - this.top;\r\n        }\r\n        // other is taller than this\r\n      } else {\r\n        // The bottom edge is closest to the others bottom edge\r\n        if (other.bottom - this.bottom <= this.top - other.top) {\r\n          overlapY = this.top - other.bottom;\r\n        } else {\r\n          overlapY = this.bottom - other.top;\r\n        }\r\n      }\r\n\r\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n        return new Vector(overlapX, 0);\r\n      } else {\r\n        return new Vector(0, overlapY);\r\n      }\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.\r\n   * @param bb The other actor to test\r\n   */\r\n  public intersectWithSide(bb: BoundingBox): Side {\r\n    const intersect = this.intersect(bb);\r\n    return BoundingBox.getSideFromIntersection(intersect);\r\n  }\r\n\r\n  /**\r\n   * Draw a debug bounding box\r\n   * @param ex\r\n   * @param color\r\n   */\r\n  public draw(ex: ExcaliburGraphicsContext, color: Color = Color.Yellow) {\r\n    ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });\r\n  }\r\n}\r\n","\r\n/**\r\n * Future is a wrapper around a native browser Promise to allow resolving/rejecting at any time\r\n */\r\nexport class Future<T> {\r\n  // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e\r\n  private _resolver: (value: T) => void;\r\n  private _rejecter: (error: Error) => void;\r\n  private _isCompleted: boolean = false;\r\n\r\n  constructor() {\r\n    this.promise = new Promise((resolve, reject) => {\r\n      this._resolver = resolve;\r\n      this._rejecter = reject;\r\n    });\r\n  }\r\n\r\n  public readonly promise: Promise<T>;\r\n\r\n  public get isCompleted(): boolean {\r\n    return this._isCompleted;\r\n  }\r\n\r\n  public resolve(value: T): void {\r\n    if (this._isCompleted) {\r\n      return;\r\n    }\r\n    this._isCompleted = true;\r\n    this._resolver(value);\r\n  }\r\n\r\n  public reject(error: Error): void {\r\n    if (this._isCompleted) {\r\n      return;\r\n    }\r\n    this._isCompleted = true;\r\n    this._rejecter(error);\r\n  }\r\n}","import { Vector } from '../Math/vector';\r\nimport { Clock } from './Clock';\r\nimport { Future } from './Future';\r\n\r\n/**\r\n * Find the screen position of an HTML element\r\n */\r\nexport function getPosition(el: HTMLElement): Vector {\r\n  let oLeft: number = 0,\r\n    oTop: number = 0;\r\n\r\n  const calcOffsetLeft = (parent: HTMLElement) => {\r\n    oLeft += parent.offsetLeft;\r\n\r\n    if (parent.offsetParent) {\r\n      calcOffsetLeft(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n  const calcOffsetTop = (parent: HTMLElement) => {\r\n    oTop += parent.offsetTop;\r\n    if (parent.offsetParent) {\r\n      calcOffsetTop(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n\r\n  calcOffsetLeft(el);\r\n  calcOffsetTop(el);\r\n\r\n  return new Vector(oLeft, oTop);\r\n}\r\n\r\n/**\r\n * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function addItemToArray<T>(item: T, array: T[]): boolean {\r\n  if (array.indexOf(item) === -1) {\r\n    array.push(item);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Remove an item from an list\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function removeItemFromArray<T>(item: T, array: T[]): boolean {\r\n  let index = -1;\r\n  if ((index = array.indexOf(item)) > -1) {\r\n    array.splice(index, 1);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * See if an array contains something\r\n */\r\nexport function contains(array: Array<any>, obj: any): boolean {\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (array[i] === obj) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Used for exhaustive checks at compile time\r\n */\r\nexport function fail(message: never): never {\r\n  throw new Error(message);\r\n}\r\n\r\n/**\r\n * Create a promise that resolves after a certain number of milliseconds\r\n *\r\n * It is strongly recommended you pass the excalibur clock so delays are bound to the\r\n * excalibur clock which would be unaffected by stop/pause.\r\n * @param milliseconds\r\n * @param clock\r\n */\r\nexport function delay(milliseconds: number, clock?: Clock): Promise<void> {\r\n  const future = new Future<void>();\r\n  const schedule = clock?.schedule.bind(clock) ?? setTimeout;\r\n  schedule(() => {\r\n    future.resolve();\r\n  }, milliseconds);\r\n  return future.promise;\r\n}\r\n","import { sign } from './util';\r\nimport { Vector, vec } from './vector';\r\nimport { canonicalizeAngle } from './util';\r\n\r\nexport enum MatrixLocations {\r\n  X = 12,\r\n  Y = 13\r\n}\r\n\r\n/**\r\n * Excalibur Matrix helper for 4x4 matrices\r\n *\r\n * Useful for webgl 4x4 matrices\r\n */\r\nexport class Matrix {\r\n  /**\r\n   *  4x4 matrix in column major order\r\n   *\r\n   * |         |         |          |          |\r\n   * | ------- | ------- | -------- | -------- |\r\n   * | data[0] | data[4] | data[8]  | data[12] |\r\n   * | data[1] | data[5] | data[9]  | data[13] |\r\n   * | data[2] | data[6] | data[10] | data[14] |\r\n   * | data[3] | data[7] | data[11] | data[15] |\r\n   *\r\n   */\r\n  public data: Float32Array = new Float32Array(16);\r\n\r\n  /**\r\n   * Creates an orthographic (flat non-perspective) projection\r\n   * https://en.wikipedia.org/wiki/Orthographic_projection\r\n   * @param left\r\n   * @param right\r\n   * @param bottom\r\n   * @param top\r\n   * @param near\r\n   * @param far\r\n   */\r\n  public static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix {\r\n    const mat = new Matrix();\r\n    mat.data[0] = 2 / (right - left);\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 2 / (top - bottom);\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = -2 / (far - near);\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = -(right + left) / (right - left);\r\n    mat.data[13] = -(top + bottom) / (top - bottom);\r\n    mat.data[14] = -(far + near) / (far - near);\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a new Matrix with the same data as the current 4x4\r\n   */\r\n  public clone(dest?: Matrix): Matrix {\r\n    const mat = dest || new Matrix();\r\n    mat.data[0] = this.data[0];\r\n    mat.data[1] = this.data[1];\r\n    mat.data[2] = this.data[2];\r\n    mat.data[3] = this.data[3];\r\n\r\n    mat.data[4] = this.data[4];\r\n    mat.data[5] = this.data[5];\r\n    mat.data[6] = this.data[6];\r\n    mat.data[7] = this.data[7];\r\n\r\n    mat.data[8] = this.data[8];\r\n    mat.data[9] = this.data[9];\r\n    mat.data[10] = this.data[10];\r\n    mat.data[11] = this.data[11];\r\n\r\n    mat.data[12] = this.data[12];\r\n    mat.data[13] = this.data[13];\r\n    mat.data[14] = this.data[14];\r\n    mat.data[15] = this.data[15];\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Converts the current matrix into a DOMMatrix\r\n   *\r\n   * This is useful when working with the browser Canvas context\r\n   * @returns {DOMMatrix} DOMMatrix\r\n   */\r\n  public toDOMMatrix(): DOMMatrix {\r\n    return new DOMMatrix([...this.data]);\r\n  }\r\n\r\n  public static fromFloat32Array(data: Float32Array) {\r\n    const matrix =  new Matrix();\r\n    matrix.data = data;\r\n    return matrix;\r\n  }\r\n\r\n  /**\r\n   * Creates a new identity matrix (a matrix that when applied does nothing)\r\n   */\r\n  public static identity(): Matrix {\r\n    const mat = new Matrix();\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 1;\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = 0;\r\n    mat.data[13] = 0;\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Resets the current matrix to the identity matrix, mutating it\r\n   * @returns {Matrix} Current matrix as identity\r\n   */\r\n  public reset(): Matrix {\r\n    const mat = this;\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 1;\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = 0;\r\n    mat.data[13] = 0;\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new translation matrix at the specified 3d point\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public static translation(x: number, y: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[12] = x;\r\n    mat.data[13] = y;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new scaling matrix with the specified scaling factor\r\n   * @param sx\r\n   * @param sy\r\n   */\r\n  public static scale(sx: number, sy: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[0] = sx;\r\n    mat.data[5] = sy;\r\n    mat.data[10] = 1;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new rotation matrix with the specified angle\r\n   * @param angleRadians\r\n   */\r\n  public static rotation(angleRadians: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[0] = Math.cos(angleRadians);\r\n    mat.data[4] = -Math.sin(angleRadians);\r\n    mat.data[1] = Math.sin(angleRadians);\r\n    mat.data[5] = Math.cos(angleRadians);\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Multiply the current matrix by a vector producing a new vector\r\n   * @param vector\r\n   * @param dest\r\n   */\r\n  multiply(vector: Vector, dest?: Vector): Vector;\r\n  /**\r\n   * Multiply the current matrix by another matrix producing a new matrix\r\n   * @param matrix\r\n   * @param dest\r\n   */\r\n  multiply(matrix: Matrix, dest?: Matrix): Matrix;\r\n  multiply(vectorOrMatrix: Vector | Matrix, dest?: Vector | Matrix): Vector | Matrix {\r\n    if (vectorOrMatrix instanceof Vector) {\r\n      const result = (dest as Vector) || new Vector(0, 0);\r\n      const vector = vectorOrMatrix;\r\n      // these shenanigans are to allow dest and vector to be the same instance\r\n      const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];\r\n      const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];\r\n\r\n      result.x = resultX;\r\n      result.y = resultY;\r\n      return result;\r\n    } else {\r\n      const result = (dest as Matrix) || new Matrix();\r\n      const other = vectorOrMatrix;\r\n      const a11 = this.data[0];\r\n      const a21 = this.data[1];\r\n      const a31 = this.data[2];\r\n      const a41 = this.data[3];\r\n\r\n      const a12 = this.data[4];\r\n      const a22 = this.data[5];\r\n      const a32 = this.data[6];\r\n      const a42 = this.data[7];\r\n\r\n      const a13 = this.data[8];\r\n      const a23 = this.data[9];\r\n      const a33 = this.data[10];\r\n      const a43 = this.data[11];\r\n\r\n      const a14 = this.data[12];\r\n      const a24 = this.data[13];\r\n      const a34 = this.data[14];\r\n      const a44 = this.data[15];\r\n\r\n      const b11 = other.data[0];\r\n      const b21 = other.data[1];\r\n      const b31 = other.data[2];\r\n      const b41 = other.data[3];\r\n\r\n      const b12 = other.data[4];\r\n      const b22 = other.data[5];\r\n      const b32 = other.data[6];\r\n      const b42 = other.data[7];\r\n\r\n      const b13 = other.data[8];\r\n      const b23 = other.data[9];\r\n      const b33 = other.data[10];\r\n      const b43 = other.data[11];\r\n\r\n      const b14 = other.data[12];\r\n      const b24 = other.data[13];\r\n      const b34 = other.data[14];\r\n      const b44 = other.data[15];\r\n\r\n      result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n      result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n      result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n      result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\r\n      result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n      result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n      result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n      result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\r\n      result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n      result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n      result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n      result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\r\n      result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n      result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n      result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n      result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n      const s = this.getScale();\r\n      result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\r\n      result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Applies translation to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    const a13 = this.data[8];\r\n    const a23 = this.data[9];\r\n    const a33 = this.data[10];\r\n    const a43 = this.data[11];\r\n\r\n    const a14 = this.data[12];\r\n    const a24 = this.data[13];\r\n    const a34 = this.data[14];\r\n    const a44 = this.data[15];\r\n\r\n    // Doesn't change z\r\n    const z = 0;\r\n    const w = 1;\r\n    this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;\r\n    this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;\r\n    this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;\r\n    this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;\r\n\r\n    return this;\r\n  }\r\n\r\n  public setPosition(x: number, y: number) {\r\n    this.data[12] = x;\r\n    this.data[13] = y;\r\n  }\r\n\r\n  public getPosition(): Vector {\r\n    return vec(this.data[12], this.data[13]);\r\n  }\r\n\r\n  /**\r\n   * Applies rotation to the current matrix mutating it\r\n   * @param angle in Radians\r\n   */\r\n  rotate(angle: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * a11 + sine * a12;\r\n    this.data[1] = cosine * a21 + sine * a22;\r\n    this.data[2] = cosine * a31 + sine * a32;\r\n    this.data[3] = cosine * a41 + sine * a42;\r\n\r\n    this.data[4] = cosine * a12 - sine * a11;\r\n    this.data[5] = cosine * a22 - sine * a21;\r\n    this.data[6] = cosine * a32 - sine * a31;\r\n    this.data[7] = cosine * a42 - sine * a41;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies scaling to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    this.data[0] = a11 * x;\r\n    this.data[1] = a21 * x;\r\n    this.data[2] = a31 * x;\r\n    this.data[3] = a41 * x;\r\n\r\n    this.data[4] = a12 * y;\r\n    this.data[5] = a22 * y;\r\n    this.data[6] = a32 * y;\r\n    this.data[7] = a42 * y;\r\n\r\n    return this;\r\n  }\r\n\r\n  public setRotation(angle: number) {\r\n    const currentScale = this.getScale();\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * currentScale.x;\r\n    this.data[1] = sine * currentScale.y;\r\n    this.data[4] = -sine * currentScale.x;\r\n    this.data[5] = cosine * currentScale.y;\r\n  }\r\n\r\n  public getRotation(): number {\r\n    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\r\n    return canonicalizeAngle(angle);\r\n  }\r\n\r\n  public getScaleX(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const xscale = vec(this.data[0], this.data[4]).size;\r\n    return this._scaleSignX * xscale;\r\n  }\r\n\r\n  public getScaleY(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const yscale = vec(this.data[1], this.data[5]).size;\r\n    return this._scaleSignY * yscale;\r\n  }\r\n\r\n  /**\r\n   * Get the scale of the matrix\r\n   */\r\n  public getScale(): Vector {\r\n    return vec(this.getScaleX(), this.getScaleY());\r\n  }\r\n\r\n  private _scaleX = 1;\r\n  private _scaleSignX = 1;\r\n  public setScaleX(val: number) {\r\n    if (this._scaleX === val) {\r\n      return;\r\n    }\r\n\r\n    this._scaleSignX = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();\r\n    this.data[0] = xscale.x * val;\r\n    this.data[4] = xscale.y * val;\r\n    this._scaleX = val;\r\n  }\r\n\r\n  private _scaleY = 1;\r\n  private _scaleSignY = 1;\r\n  public setScaleY(val: number) {\r\n    if (this._scaleY === val) {\r\n      return;\r\n    }\r\n    this._scaleSignY = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();\r\n    this.data[1] = yscale.x * val;\r\n    this.data[5] = yscale.y * val;\r\n    this._scaleY = val;\r\n  }\r\n\r\n  public setScale(scale: Vector) {\r\n    this.setScaleX(scale.x);\r\n    this.setScaleY(scale.y);\r\n  }\r\n\r\n  /**\r\n   * Determinant of the upper left 2x2 matrix\r\n   */\r\n  public getBasisDeterminant() {\r\n    return this.data[0] * this.data[5] - this.data[1] * this.data[4];\r\n  }\r\n\r\n  /**\r\n   * Return the affine inverse, optionally store it in a target matrix.\r\n   *\r\n   * It's recommended you call .reset() the target unless you know what you're doing\r\n   * @param target\r\n   */\r\n  public getAffineInverse(target?: Matrix): Matrix {\r\n    // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\r\n    // See https://www.mathsisfun.com/algebra/matrix-inverse.html\r\n    // Since we are actually only doing 2D transformations we can use this hack\r\n    // We don't actually use the 3rd or 4th dimension\r\n\r\n    const det = this.getBasisDeterminant();\r\n    const inverseDet = 1 / det; // todo zero check\r\n    const a = this.data[0];\r\n    const b = this.data[4];\r\n    const c = this.data[1];\r\n    const d = this.data[5];\r\n\r\n    const m = target || Matrix.identity();\r\n    // inverts rotation and scale\r\n    m.data[0] = d * inverseDet;\r\n    m.data[1] = -c * inverseDet;\r\n    m.data[4] = -b * inverseDet;\r\n    m.data[5] = a * inverseDet;\r\n\r\n    const tx = this.data[12];\r\n    const ty = this.data[13];\r\n    // invert translation\r\n    // transform translation into the matrix basis created by rot/scale\r\n    m.data[12] = -(tx * m.data[0] + ty * m.data[4]);\r\n    m.data[13] = -(tx * m.data[1] + ty * m.data[5]);\r\n\r\n    return m;\r\n  }\r\n\r\n  public isIdentity(): boolean {\r\n    return (\r\n      this.data[0] === 1 &&\r\n      this.data[1] === 0 &&\r\n      this.data[2] === 0 &&\r\n      this.data[3] === 0 &&\r\n      this.data[4] === 0 &&\r\n      this.data[5] === 1 &&\r\n      this.data[6] === 0 &&\r\n      this.data[7] === 0 &&\r\n      this.data[8] === 0 &&\r\n      this.data[9] === 0 &&\r\n      this.data[10] === 1 &&\r\n      this.data[11] === 0 &&\r\n      this.data[12] === 0 &&\r\n      this.data[13] === 0 &&\r\n      this.data[14] === 0 &&\r\n      this.data[15] === 1\r\n    );\r\n  }\r\n\r\n  public toString() {\r\n    return `\r\n[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]\r\n[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]\r\n[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]\r\n[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]\r\n`;\r\n  }\r\n}\r\n","import { Matrix } from './matrix';\r\nimport { canonicalizeAngle, sign } from './util';\r\nimport { vec, Vector } from './vector';\r\n\r\n\r\nexport class AffineMatrix {\r\n  /**\r\n   * |         |         |          |\r\n   * | ------- | ------- | -------- |\r\n   * | data[0] | data[2] | data[4]  |\r\n   * | data[1] | data[3] | data[5]  |\r\n   * |   0     |    0    |    1     |\r\n   */\r\n  public data = new Float64Array(6);\r\n\r\n  /**\r\n   * Converts the current matrix into a DOMMatrix\r\n   *\r\n   * This is useful when working with the browser Canvas context\r\n   * @returns {DOMMatrix} DOMMatrix\r\n   */\r\n  public toDOMMatrix(): DOMMatrix {\r\n    return new DOMMatrix([...this.data]);\r\n  }\r\n\r\n  public static identity(): AffineMatrix {\r\n    const mat = new AffineMatrix();\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 1;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 0;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new translation matrix at the specified 3d point\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public static translation(x: number, y: number): AffineMatrix {\r\n    const mat = AffineMatrix.identity();\r\n    mat.data[4] = x;\r\n    mat.data[5] = y;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new scaling matrix with the specified scaling factor\r\n   * @param sx\r\n   * @param sy\r\n   */\r\n  public static scale(sx: number, sy: number): AffineMatrix {\r\n    const mat = AffineMatrix.identity();\r\n    mat.data[0] = sx;\r\n    mat.data[3] = sy;\r\n    mat._scale[0] = sx;\r\n    mat._scale[1] = sy;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new rotation matrix with the specified angle\r\n   * @param angleRadians\r\n   */\r\n  public static rotation(angleRadians: number): AffineMatrix {\r\n    const mat = AffineMatrix.identity();\r\n    mat.data[0] = Math.cos(angleRadians);\r\n    mat.data[1] = Math.sin(angleRadians);\r\n    mat.data[2] = -Math.sin(angleRadians);\r\n    mat.data[3] = Math.cos(angleRadians);\r\n    return mat;\r\n  }\r\n\r\n  public setPosition(x: number, y: number) {\r\n    this.data[4] = x;\r\n    this.data[5] = y;\r\n  }\r\n\r\n  public getPosition(): Vector {\r\n    return vec(this.data[4], this.data[5]);\r\n  }\r\n\r\n  /**\r\n   * Applies rotation to the current matrix mutating it\r\n   * @param angle in Radians\r\n   */\r\n  rotate(angle: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n\r\n    const a12 = this.data[2];\r\n    const a22 = this.data[3];\r\n\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * a11 + sine * a12;\r\n    this.data[1] = cosine * a21 + sine * a22;\r\n\r\n    this.data[2] = cosine * a12 - sine * a11;\r\n    this.data[3] = cosine * a22 - sine * a21;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies translation to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    // const a31 = 0;\r\n\r\n    const a12 = this.data[2];\r\n    const a22 = this.data[3];\r\n    // const a32 = 0;\r\n\r\n    const a13 = this.data[4];\r\n    const a23 = this.data[5];\r\n    // const a33 = 1;\r\n\r\n    // Doesn't change z\r\n    this.data[4] = a11 * x + a12 * y + a13;\r\n    this.data[5] = a21 * x + a22 * y + a23;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies scaling to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n\r\n    const a12 = this.data[2];\r\n    const a22 = this.data[3];\r\n\r\n    this.data[0] = a11 * x;\r\n    this.data[1] = a21 * x;\r\n\r\n    this.data[2] = a12 * y;\r\n    this.data[3] = a22 * y;\r\n\r\n    this._scale[0] = x;\r\n    this._scale[1] = y;\r\n    return this;\r\n  }\r\n\r\n  public determinant() {\r\n    return this.data[0] * this.data[3] - this.data[1] * this.data[2];\r\n  }\r\n\r\n  /**\r\n   * Return the affine inverse, optionally store it in a target matrix.\r\n   *\r\n   * It's recommended you call .reset() the target unless you know what you're doing\r\n   * @param target\r\n   */\r\n  public inverse(target?: AffineMatrix): AffineMatrix {\r\n    // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\r\n    // See https://www.mathsisfun.com/algebra/matrix-inverse.html\r\n    // Since we are actually only doing 2D transformations we can use this hack\r\n    // We don't actually use the 3rd or 4th dimension\r\n\r\n    const det = this.determinant();\r\n    const inverseDet = 1 / det; // TODO zero check\r\n    const a = this.data[0];\r\n    const b = this.data[2];\r\n    const c = this.data[1];\r\n    const d = this.data[3];\r\n\r\n    const m = target || AffineMatrix.identity();\r\n    // inverts rotation and scale\r\n    m.data[0] = d * inverseDet;\r\n    m.data[1] = -c * inverseDet;\r\n    m.data[2] = -b * inverseDet;\r\n    m.data[3] = a * inverseDet;\r\n\r\n    const tx = this.data[4];\r\n    const ty = this.data[5];\r\n    // invert translation\r\n    // transform translation into the matrix basis created by rot/scale\r\n    m.data[4] = -(tx * m.data[0] + ty * m.data[2]);\r\n    m.data[5] = -(tx * m.data[1] + ty * m.data[3]);\r\n\r\n    return m;\r\n  }\r\n\r\n  /**\r\n   * Multiply the current matrix by a vector producing a new vector\r\n   * @param vector\r\n   * @param dest\r\n   */\r\n  multiply(vector: Vector, dest?: Vector): Vector;\r\n  /**\r\n   * Multiply the current matrix by another matrix producing a new matrix\r\n   * @param matrix\r\n   * @param dest\r\n   */\r\n  multiply(matrix: AffineMatrix, dest?: AffineMatrix): AffineMatrix;\r\n  multiply(vectorOrMatrix: Vector | AffineMatrix, dest?: Vector | AffineMatrix): Vector | AffineMatrix {\r\n    if (vectorOrMatrix instanceof Vector) {\r\n      const result = (dest as Vector) || new Vector(0, 0);\r\n      const vector = vectorOrMatrix;\r\n      // these shenanigans are to allow dest and vector to be the same instance\r\n      const resultX = vector.x * this.data[0] + vector.y * this.data[2] + this.data[4];\r\n      const resultY = vector.x * this.data[1] + vector.y * this.data[3] + this.data[5];\r\n\r\n      result.x = resultX;\r\n      result.y = resultY;\r\n      return result;\r\n    } else {\r\n      const result = (dest as AffineMatrix) || new AffineMatrix();\r\n      const other = vectorOrMatrix;\r\n      const a11 = this.data[0];\r\n      const a21 = this.data[1];\r\n      //  const a31 = 0;\r\n\r\n      const a12 = this.data[2];\r\n      const a22 = this.data[3];\r\n      //  const a32 = 0;\r\n\r\n      const a13 = this.data[4];\r\n      const a23 = this.data[5];\r\n      //  const a33 = 1;\r\n\r\n      const b11 = other.data[0];\r\n      const b21 = other.data[1];\r\n      //  const b31 = 0;\r\n\r\n      const b12 = other.data[2];\r\n      const b22 = other.data[3];\r\n      //  const b32 = 0;\r\n\r\n      const b13 = other.data[4];\r\n      const b23 = other.data[5];\r\n      //  const b33 = 1;\r\n\r\n\r\n      result.data[0] = a11 * b11 + a12 * b21;// + a13 * b31; // zero\r\n      result.data[1] = a21 * b11 + a22 * b21;// + a23 * b31; // zero\r\n\r\n      result.data[2] = a11 * b12 + a12 * b22;// + a13 * b32; // zero\r\n      result.data[3] = a21 * b12 + a22 * b22;// + a23 * b32; // zero\r\n\r\n      result.data[4] = a11 * b13 + a12 * b23 + a13;// * b33; // one\r\n      result.data[5] = a21 * b13 + a22 * b23 + a23;// * b33; // one\r\n\r\n      const s = this.getScale();\r\n      result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\r\n      result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  to4x4() {\r\n    const mat = new Matrix();\r\n    mat.data[0] = this.data[0];\r\n    mat.data[1] = this.data[1];\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = this.data[2];\r\n    mat.data[5] = this.data[3];\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = this.data[4];\r\n    mat.data[13] = this.data[5];\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  public setRotation(angle: number) {\r\n    const currentScale = this.getScale();\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * currentScale.x;\r\n    this.data[1] = sine * currentScale.y;\r\n    this.data[2] = -sine * currentScale.x;\r\n    this.data[3] = cosine * currentScale.y;\r\n  }\r\n\r\n  public getRotation(): number {\r\n    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\r\n    return canonicalizeAngle(angle);\r\n  }\r\n\r\n  public getScaleX(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const xscale = vec(this.data[0], this.data[2]).distance();\r\n    return this._scaleSignX * xscale;\r\n  }\r\n\r\n  public getScaleY(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const yscale = vec(this.data[1], this.data[3]).distance();\r\n    return this._scaleSignY * yscale;\r\n  }\r\n\r\n  /**\r\n   * Get the scale of the matrix\r\n   */\r\n  public getScale(): Vector {\r\n    return vec(this.getScaleX(), this.getScaleY());\r\n  }\r\n\r\n  private _scale = new Float64Array([1, 1]);\r\n  private _scaleSignX = 1;\r\n  public setScaleX(val: number) {\r\n    if (val === this._scale[0]) {\r\n      return;\r\n    }\r\n    this._scaleSignX = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();\r\n    this.data[0] = xscale.x * val;\r\n    this.data[2] = xscale.y * val;\r\n    this._scale[0] = val;\r\n  }\r\n\r\n  private _scaleSignY = 1;\r\n  public setScaleY(val: number) {\r\n    if (val === this._scale[1]) {\r\n      return;\r\n    }\r\n    this._scaleSignY = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();\r\n    this.data[1] = yscale.x * val;\r\n    this.data[3] = yscale.y * val;\r\n    this._scale[1] = val;\r\n  }\r\n\r\n  public setScale(scale: Vector) {\r\n    this.setScaleX(scale.x);\r\n    this.setScaleY(scale.y);\r\n  }\r\n\r\n  public isIdentity(): boolean {\r\n    return (\r\n      this.data[0] === 1 &&\r\n      this.data[1] === 0 &&\r\n      this.data[2] === 0 &&\r\n      this.data[3] === 1 &&\r\n      this.data[4] === 0 &&\r\n      this.data[5] === 0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Resets the current matrix to the identity matrix, mutating it\r\n   * @returns {AffineMatrix} Current matrix as identity\r\n   */\r\n  public reset(): AffineMatrix {\r\n    const mat = this;\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 1;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 0;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a new Matrix with the same data as the current 4x4\r\n   */\r\n  public clone(dest?: AffineMatrix): AffineMatrix {\r\n    const mat = dest || new AffineMatrix();\r\n    mat.data[0] = this.data[0];\r\n    mat.data[1] = this.data[1];\r\n\r\n    mat.data[2] = this.data[2];\r\n    mat.data[3] = this.data[3];\r\n\r\n    mat.data[4] = this.data[4];\r\n    mat.data[5] = this.data[5];\r\n    return mat;\r\n  }\r\n\r\n  public toString() {\r\n    return `\r\n[${this.data[0]} ${this.data[2]} ${this.data[4]}]\r\n[${this.data[1]} ${this.data[3]} ${this.data[5]}]\r\n[0 0 1]\r\n`;\r\n  }\r\n\r\n}","import { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport class TransformStack {\r\n  private _transforms: AffineMatrix[] = [];\r\n  private _currentTransform: AffineMatrix = AffineMatrix.identity();\r\n\r\n  public save(): void {\r\n    this._transforms.push(this._currentTransform);\r\n    this._currentTransform = this._currentTransform.clone();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentTransform = this._transforms.pop();\r\n  }\r\n\r\n  public translate(x: number, y: number): AffineMatrix {\r\n    return this._currentTransform.translate(x, y);\r\n  }\r\n\r\n  public rotate(angle: number): AffineMatrix {\r\n    return this._currentTransform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): AffineMatrix {\r\n    return this._currentTransform.scale(x, y);\r\n  }\r\n\r\n  public set current(matrix: AffineMatrix) {\r\n    this._currentTransform = matrix;\r\n  }\r\n\r\n  public get current(): AffineMatrix {\r\n    return this._currentTransform;\r\n  }\r\n}\r\n","import { Color } from '../../Color';\r\nimport { ExcaliburGraphicsContextState } from './ExcaliburGraphicsContext';\r\n\r\nexport class StateStack {\r\n  private _states: ExcaliburGraphicsContextState[] = [];\r\n  private _currentState: ExcaliburGraphicsContextState = this._getDefaultState();\r\n\r\n  private _getDefaultState() {\r\n    return {\r\n      opacity: 1,\r\n      z: 0,\r\n      tint: Color.White\r\n    };\r\n  }\r\n\r\n  private _cloneState() {\r\n    return {\r\n      opacity: this._currentState.opacity,\r\n      z: this._currentState.z,\r\n      tint: this._currentState.tint.clone()\r\n    };\r\n  }\r\n\r\n  public save(): void {\r\n    this._states.push(this._currentState);\r\n    this._currentState = this._cloneState();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentState = this._states.pop();\r\n  }\r\n\r\n  public get current(): ExcaliburGraphicsContextState {\r\n    return this._currentState;\r\n  }\r\n\r\n  public set current(val: ExcaliburGraphicsContextState) {\r\n    this._currentState = val;\r\n  }\r\n}\r\n","import { Scene } from './Scene';\r\nimport { Vector } from './Math/vector';\r\nimport { Actor } from './Actor';\r\nimport { Trigger } from './Trigger';\r\nimport { FrameStats } from './Debug';\r\nimport { Engine } from './Engine';\r\nimport { TileMap } from './TileMap';\r\nimport { Side } from './Collision/Side';\r\nimport * as Input from './Input/Index';\r\nimport { CollisionContact } from './Collision/Detection/CollisionContact';\r\nimport { Collider } from './Collision/Colliders/Collider';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { OnInitialize, OnPreUpdate, OnPostUpdate, SceneActivationContext } from './Interfaces/LifecycleEvents';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { ExcaliburGraphicsContext } from './Graphics';\r\n\r\nexport enum EventTypes {\r\n  Kill = 'kill',\r\n  PreKill = 'prekill',\r\n  PostKill = 'postkill',\r\n\r\n  PreDraw = 'predraw',\r\n  PostDraw = 'postdraw',\r\n\r\n  PreDebugDraw = 'predebugdraw',\r\n  PostDebugDraw = 'postdebugdraw',\r\n\r\n  PreUpdate = 'preupdate',\r\n  PostUpdate = 'postupdate',\r\n\r\n  PreFrame = 'preframe',\r\n  PostFrame = 'postframe',\r\n\r\n  PreCollision = 'precollision',\r\n  CollisionStart = 'collisionstart',\r\n  CollisionEnd = 'collisionend',\r\n  PostCollision = 'postcollision',\r\n\r\n  Initialize = 'initialize',\r\n  Activate = 'activate',\r\n  Deactivate = 'deactivate',\r\n\r\n  ExitViewport = 'exitviewport',\r\n  EnterViewport = 'enterviewport',\r\n\r\n  ExitTrigger = 'exit',\r\n  EnterTrigger = 'enter',\r\n\r\n  Connect = 'connect',\r\n  Disconnect = 'disconnect',\r\n  Button = 'button',\r\n  Axis = 'axis',\r\n\r\n  Visible = 'visible',\r\n  Hidden = 'hidden',\r\n  Start = 'start',\r\n  Stop = 'stop',\r\n\r\n  PointerUp = 'pointerup',\r\n  PointerDown = 'pointerdown',\r\n  PointerMove = 'pointermove',\r\n  PointerEnter = 'pointerenter',\r\n  PointerLeave = 'pointerleave',\r\n  PointerCancel = 'pointercancel',\r\n  PointerWheel = 'pointerwheel',\r\n\r\n  Up = 'up',\r\n  Down = 'down',\r\n  Move = 'move',\r\n  Enter = 'enter',\r\n  Leave = 'leave',\r\n  Cancel = 'cancel',\r\n  Wheel = 'wheel',\r\n\r\n  Press = 'press',\r\n  Release = 'release',\r\n  Hold = 'hold',\r\n\r\n  PointerDragStart = 'pointerdragstart',\r\n  PointerDragEnd = 'pointerdragend',\r\n  PointerDragEnter = 'pointerdragenter',\r\n  PointerDragLeave = 'pointerdragleave',\r\n  PointerDragMove = 'pointerdragmove'\r\n}\r\n\r\n/* istanbul ignore next */\r\n/* compiler only: these are internal to lib */\r\nexport type kill = 'kill';\r\nexport type prekill = 'prekill';\r\nexport type postkill = 'postkill';\r\n\r\nexport type predraw = 'predraw';\r\nexport type postdraw = 'postdraw';\r\n\r\nexport type predebugdraw = 'predebugdraw';\r\nexport type postdebugdraw = 'postdebugdraw';\r\n\r\nexport type preupdate = 'preupdate';\r\nexport type postupdate = 'postupdate';\r\n\r\nexport type preframe = 'preframe';\r\nexport type postframe = 'postframe';\r\n\r\nexport type precollision = 'precollision';\r\nexport type collisionstart = 'collisionstart';\r\nexport type collisionend = 'collisionend';\r\nexport type postcollision = 'postcollision';\r\n\r\nexport type initialize = 'initialize';\r\nexport type activate = 'activate';\r\nexport type deactivate = 'deactivate';\r\n\r\nexport type exitviewport = 'exitviewport';\r\nexport type enterviewport = 'enterviewport';\r\n\r\nexport type exittrigger = 'exit';\r\nexport type entertrigger = 'enter';\r\n\r\nexport type connect = 'connect';\r\nexport type disconnect = 'disconnect';\r\nexport type button = 'button';\r\nexport type axis = 'axis';\r\n\r\nexport type subscribe = 'subscribe';\r\nexport type unsubscribe = 'unsubscribe';\r\n\r\nexport type visible = 'visible';\r\nexport type hidden = 'hidden';\r\nexport type start = 'start';\r\nexport type stop = 'stop';\r\n\r\nexport type pointerup = 'pointerup';\r\nexport type pointerdown = 'pointerdown';\r\nexport type pointermove = 'pointermove';\r\nexport type pointerenter = 'pointerenter';\r\nexport type pointerleave = 'pointerleave';\r\nexport type pointercancel = 'pointercancel';\r\nexport type pointerwheel = 'pointerwheel';\r\n\r\nexport type up = 'up';\r\nexport type down = 'down';\r\nexport type move = 'move';\r\nexport type enter = 'enter';\r\nexport type leave = 'leave';\r\nexport type cancel = 'cancel';\r\nexport type wheel = 'wheel';\r\n\r\nexport type press = 'press';\r\nexport type release = 'release';\r\nexport type hold = 'hold';\r\n\r\nexport type pointerdragstart = 'pointerdragstart';\r\nexport type pointerdragend = 'pointerdragend';\r\nexport type pointerdragenter = 'pointerdragenter';\r\nexport type pointerdragleave = 'pointerdragleave';\r\nexport type pointerdragmove = 'pointerdragmove';\r\n\r\n/**\r\n * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,\r\n * some events are unique to a type, others are not.\r\n *\r\n */\r\nexport class GameEvent<T, U = T> {\r\n  /**\r\n   * Target object for this event.\r\n   */\r\n  public target: T;\r\n\r\n  /**\r\n   * Other target object for this event\r\n   */\r\n  public other: U | null;\r\n\r\n  /**\r\n   * If set to false, prevents event from propagating to other actors. If true it will be propagated\r\n   * to all actors that apply.\r\n   */\r\n  public get bubbles(): boolean {\r\n    return this._bubbles;\r\n  }\r\n\r\n  public set bubbles(value: boolean) {\r\n    this._bubbles = value;\r\n  }\r\n\r\n  private _bubbles: boolean = true;\r\n  /**\r\n   * Prevents event from bubbling\r\n   */\r\n  public stopPropagation() {\r\n    this.bubbles = false;\r\n  }\r\n}\r\n\r\n/**\r\n * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.\r\n */\r\nexport class KillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'prekill' event is emitted directly before an actor is killed.\r\n */\r\nexport class PreKillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postkill' event is emitted directly after the actor is killed.\r\n */\r\nexport class PostKillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'start' event is emitted on engine when has started and is ready for interaction.\r\n */\r\nexport class GameStartEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.\r\n */\r\nexport class GameStopEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nexport class PreDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public delta: number, public target: Entity | Scene | Engine | TileMap) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nexport class PostDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public delta: number, public target: Entity | Scene | Engine | TileMap) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.\r\n */\r\nexport class PreDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public target: Entity | Actor | Scene | Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.\r\n */\r\nexport class PostDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public target: Entity | Actor | Scene | Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.\r\n */\r\nexport class PreUpdateEvent<T extends OnPreUpdate = Entity> extends GameEvent<T> {\r\n  constructor(public engine: Engine, public delta: number, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.\r\n */\r\nexport class PostUpdateEvent<T extends OnPostUpdate = Entity> extends GameEvent<T> {\r\n  constructor(public engine: Engine, public delta: number, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'preframe' event is emitted on the engine, before the frame begins.\r\n */\r\nexport class PreFrameEvent extends GameEvent<Engine> {\r\n  constructor(public engine: Engine, public prevStats: FrameStats) {\r\n    super();\r\n    this.target = engine;\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postframe' event is emitted on the engine, after a frame ends.\r\n */\r\nexport class PostFrameEvent extends GameEvent<Engine> {\r\n  constructor(public engine: Engine, public stats: FrameStats) {\r\n    super();\r\n    this.target = engine;\r\n  }\r\n}\r\n\r\n/**\r\n * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.\r\n */\r\nexport class GamepadConnectEvent extends GameEvent<Input.Gamepad> {\r\n  constructor(public index: number, public gamepad: Input.Gamepad) {\r\n    super();\r\n    this.target = gamepad;\r\n  }\r\n}\r\n\r\n/**\r\n * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.\r\n */\r\nexport class GamepadDisconnectEvent extends GameEvent<Input.Gamepad> {\r\n  constructor(public index: number, public gamepad: Input.Gamepad) {\r\n    super();\r\n    this.target = gamepad;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nexport class GamepadButtonEvent extends GameEvent<Input.Gamepad> {\r\n  /**\r\n   * @param button  The Gamepad button\r\n   * @param value   A numeric value between 0 and 1\r\n   */\r\n  constructor(public button: Input.Buttons, public value: number, public target: Input.Gamepad) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nexport class GamepadAxisEvent extends GameEvent<Input.Gamepad> {\r\n  /**\r\n   * @param axis  The Gamepad axis\r\n   * @param value A numeric value between -1 and 1\r\n   */\r\n  constructor(public axis: Input.Axes, public value: number, public target: Input.Gamepad) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event received by the [[Engine]] when the browser window is visible on a screen.\r\n */\r\nexport class VisibleEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event received by the [[Engine]] when the browser window is hidden from all screens.\r\n */\r\nexport class HiddenEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves\r\n */\r\nexport class PreCollisionEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   * @param actor         The actor the event was thrown on\r\n   * @param other         The actor that will collided with the current actor\r\n   * @param side          The side that will be collided with the current actor\r\n   * @param intersection  Intersection vector\r\n   */\r\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame\r\n */\r\nexport class PostCollisionEvent<T extends Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   * @param actor         The actor the event was thrown on\r\n   * @param other         The actor that did collide with the current actor\r\n   * @param side          The side that did collide with the current actor\r\n   * @param intersection  Intersection vector\r\n   */\r\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\nexport class ContactStartEvent<T> {\r\n  constructor(public target: T, public other: T, public contact: CollisionContact) {}\r\n}\r\n\r\nexport class ContactEndEvent<T> {\r\n  constructor(public target: T, public other: T) {}\r\n}\r\n\r\nexport class CollisionPreSolveEvent<T> {\r\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\r\n}\r\n\r\nexport class CollisionPostSolveEvent<T> {\r\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\r\n}\r\n\r\n/**\r\n * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.\r\n */\r\nexport class CollisionStartEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   *\r\n   * @param actor\r\n   * @param other\r\n   * @param contact\r\n   */\r\n  constructor(actor: T, public other: T, public contact: CollisionContact) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown when the [[Actor|actor]] is no longer colliding with another\r\n */\r\nexport class CollisionEndEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   *\r\n   */\r\n  constructor(actor: T, public other: T) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call\r\n */\r\nexport class InitializeEvent<T extends OnInitialize = Entity> extends GameEvent<T> {\r\n  /**\r\n   * @param engine  The reference to the current engine\r\n   */\r\n  constructor(public engine: Engine, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on a [[Scene]] on activation\r\n */\r\nexport class ActivateEvent<TData = undefined> extends GameEvent<Scene> {\r\n  /**\r\n   * @param context  The context for the scene activation\r\n   */\r\n  constructor(public context: SceneActivationContext<TData>, public target: Scene) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on a [[Scene]] on deactivation\r\n */\r\nexport class DeactivateEvent extends GameEvent<Scene> {\r\n  /**\r\n   * @param context  The context for the scene deactivation\r\n   */\r\n  constructor(public context: SceneActivationContext<never>, public target: Scene) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nexport class ExitViewPortEvent extends GameEvent<Entity> {\r\n  constructor(public target: Entity) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nexport class EnterViewPortEvent extends GameEvent<Entity> {\r\n  constructor(public target: Entity) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class EnterTriggerEvent extends GameEvent<Actor> {\r\n  constructor(public target: Trigger, public actor: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class ExitTriggerEvent extends GameEvent<Actor> {\r\n  constructor(public target: Trigger, public actor: Actor) {\r\n    super();\r\n  }\r\n}\r\n","import { GameEvent } from './Events';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\nexport class EventDispatcher<T = any> implements Eventable {\r\n  private _handlers: { [key: string]: { (event: GameEvent<T>): void }[] } = {};\r\n  private _wiredEventDispatchers: Eventable[] = [];\r\n\r\n  /**\r\n   * Clears any existing handlers or wired event dispatchers on this event dispatcher\r\n   */\r\n  public clear() {\r\n    this._handlers = {};\r\n    this._wiredEventDispatchers = [];\r\n  }\r\n\r\n  private _deferedHandlerRemovals: {name: string, handler?: (...args: any[]) => any }[] = [];\r\n  private _processDeferredHandlerRemovals() {\r\n    for (const eventHandler of this._deferedHandlerRemovals) {\r\n      this._removeHandler(eventHandler.name, eventHandler.handler);\r\n    }\r\n    this._deferedHandlerRemovals.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Emits an event for target\r\n   * @param eventName  The name of the event to publish\r\n   * @param event      Optionally pass an event data object to the handler\r\n   */\r\n  public emit(eventName: string, event: GameEvent<T>) {\r\n    this._processDeferredHandlerRemovals();\r\n    if (!eventName) {\r\n      // key not mapped\r\n      return;\r\n    }\r\n    eventName = eventName.toLowerCase();\r\n    if (!event) {\r\n      event = new GameEvent();\r\n    }\r\n    let i: number, len: number;\r\n\r\n    if (this._handlers[eventName]) {\r\n      i = 0;\r\n      len = this._handlers[eventName].length;\r\n      for (i; i < len; i++) {\r\n        this._handlers[eventName][i](event);\r\n      }\r\n    }\r\n\r\n    i = 0;\r\n    len = this._wiredEventDispatchers.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this._wiredEventDispatchers[i].emit(eventName, event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.\r\n   * @param eventName  The name of the event to subscribe to\r\n   * @param handler    The handler callback to fire on this event\r\n   */\r\n  public on(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    this._processDeferredHandlerRemovals();\r\n    eventName = eventName.toLowerCase();\r\n\r\n    if (!this._handlers[eventName]) {\r\n      this._handlers[eventName] = [];\r\n    }\r\n    this._handlers[eventName].push(handler);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe an event handler(s) from an event. If a specific handler\r\n   * is specified for an event, only that handler will be unsubscribed.\r\n   * Otherwise all handlers will be unsubscribed for that event.\r\n   *\r\n   * @param eventName  The name of the event to unsubscribe\r\n   * @param handler    Optionally the specific handler to unsubscribe\r\n   */\r\n  public off(eventName: string, handler?: (event: GameEvent<T>) => void) {\r\n    this._deferedHandlerRemovals.push({name: eventName, handler});\r\n  }\r\n\r\n  private _removeHandler(eventName: string, handler?: (event: GameEvent<T>) => void) {\r\n    eventName = eventName.toLowerCase();\r\n    const eventHandlers = this._handlers[eventName];\r\n\r\n    if (eventHandlers) {\r\n      // if no explicit handler is give with the event name clear all handlers\r\n      if (!handler) {\r\n        this._handlers[eventName].length = 0;\r\n      } else {\r\n        const index = eventHandlers.indexOf(handler);\r\n        if (index > -1) {\r\n          this._handlers[eventName].splice(index, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    this._processDeferredHandlerRemovals();\r\n    const metaHandler = (event: GameEvent<T>) => {\r\n      const ev = event || new GameEvent();\r\n      this.off(eventName, metaHandler);\r\n      handler(ev);\r\n    };\r\n\r\n    this.on(eventName, metaHandler);\r\n  }\r\n\r\n  /**\r\n   * Wires this event dispatcher to also receive events from another\r\n   */\r\n  public wire(eventDispatcher: EventDispatcher): void {\r\n    eventDispatcher._wiredEventDispatchers.push(this);\r\n  }\r\n\r\n  /**\r\n   * Unwires this event dispatcher from another\r\n   */\r\n  public unwire(eventDispatcher: EventDispatcher): void {\r\n    const index = eventDispatcher._wiredEventDispatchers.indexOf(this);\r\n    if (index > -1) {\r\n      eventDispatcher._wiredEventDispatchers.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n","import { Loadable } from '../Interfaces/Loadable';\r\nimport { Logger } from '../Util/Log';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\n\r\n/**\r\n * The [[Resource]] type allows games built in Excalibur to load generic resources.\r\n * For any type of remote resource it is recommended to use [[Resource]] for preloading.\r\n */\r\nexport class Resource<T> implements Loadable<T> {\r\n  public data: T = null;\r\n  public logger: Logger = Logger.getInstance();\r\n  public events: EventDispatcher = new EventDispatcher();\r\n\r\n  /**\r\n   * @param path          Path to the remote resource\r\n   * @param responseType  The type to expect as a response: \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\n   * @param bustCache     Whether or not to cache-bust requests\r\n   */\r\n  constructor(\r\n    public path: string,\r\n    public responseType: '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text',\r\n    public bustCache: boolean = true\r\n  ) {}\r\n\r\n  /**\r\n   * Returns true if the Resource is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    return this.data !== null;\r\n  }\r\n\r\n\r\n  private _cacheBust(uri: string): string {\r\n    const query: RegExp = /\\?\\w*=\\w*/;\r\n    if (query.test(uri)) {\r\n      uri += '&__=' + Date.now();\r\n    } else {\r\n      uri += '?__=' + Date.now();\r\n    }\r\n    return uri;\r\n  }\r\n  /**\r\n   * Begin loading the resource and returns a promise to be resolved on completion\r\n   */\r\n  public load(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      // Exit early if we already have data\r\n      if (this.data !== null) {\r\n        this.logger.debug('Already have data for resource', this.path);\r\n        this.events.emit('complete', this.data as any);\r\n        resolve(this.data);\r\n        return;\r\n      }\r\n\r\n      const request = new XMLHttpRequest();\r\n      request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);\r\n      request.responseType = this.responseType;\r\n      request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e as any));\r\n      request.addEventListener('progress', (e) => this.events.emit('progress', e as any));\r\n      request.addEventListener('error', (e) => this.events.emit('error', e as any));\r\n      request.addEventListener('load', (e) => this.events.emit('load', e as any));\r\n      request.addEventListener('load', () => {\r\n        // XHR on file:// success status is 0, such as with PhantomJS\r\n        if (request.status !== 0 && request.status !== 200) {\r\n          this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);\r\n          this.events.emit('error', request.response);\r\n          reject(new Error(request.statusText));\r\n          return;\r\n        }\r\n\r\n        this.data = request.response;\r\n        this.events.emit('complete', this.data as any);\r\n        this.logger.debug('Completed loading resource', this.path);\r\n        resolve(this.data);\r\n      });\r\n      request.send();\r\n    });\r\n  }\r\n}\r\n","/**\r\n * Watch an object with a proxy, only fires if property value is different\r\n */\r\nexport function watch<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        if ((obj as any)[prop] !== value) {\r\n          (obj as any)[prop] = value;\r\n          // Avoid watching private junk\r\n          if (typeof prop === 'string') {\r\n            if (prop[0] !== '_') {\r\n              change(obj);\r\n            }\r\n          }\r\n        }\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n\r\n/**\r\n * Watch an object with a proxy, fires change on any property value change\r\n */\r\nexport function watchAny<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        (obj as any)[prop] = value;\r\n        // Avoid watching private junk\r\n        if (typeof prop === 'string') {\r\n          if (prop[0] !== '_') {\r\n            change(obj);\r\n          }\r\n        }\r\n\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ImageSource } from './ImageSource';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Logger } from '../Util/Log';\r\n\r\nexport type SourceView = { x: number; y: number; width: number; height: number };\r\nexport type DestinationSize = { width: number; height: number };\r\n\r\nexport interface SpriteOptions {\r\n  /**\r\n   * Image to create a sprite from\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * By default the source is the entire dimension of the [[ImageSource]]\r\n   */\r\n  sourceView?: { x: number; y: number; width: number; height: number };\r\n  /**\r\n   * By default the size of the final sprite is the size of the [[ImageSource]]\r\n   */\r\n  destSize?: { width: number; height: number };\r\n}\r\n\r\nexport class Sprite extends Graphic {\r\n  private _logger = Logger.getInstance();\r\n  public image: ImageSource;\r\n  public sourceView: SourceView;\r\n  public destSize: DestinationSize;\r\n  private _dirty = true;\r\n\r\n  public static from(image: ImageSource): Sprite {\r\n    return new Sprite({\r\n      image: image\r\n    });\r\n  }\r\n\r\n  constructor(options: GraphicOptions & SpriteOptions) {\r\n    super(options);\r\n    this.image = options.image;\r\n    const { width, height } = options;\r\n    this.sourceView = options.sourceView ?? { x: 0, y: 0, width: width ?? 0, height: height ?? 0 };\r\n    this.destSize = options.destSize ?? { width: width ?? 0, height: height ?? 0 };\r\n    this._updateSpriteDimensions();\r\n    this.image.ready.then(() => {\r\n      this._updateSpriteDimensions();\r\n    });\r\n  }\r\n\r\n  public override get width(): number {\r\n    return Math.abs(this.destSize.width * this.scale.x);\r\n  }\r\n\r\n  public override get height(): number {\r\n    return Math.abs(this.destSize.height * this.scale.y);\r\n  }\r\n\r\n  public override set width(newWidth: number) {\r\n    newWidth /= Math.abs(this.scale.x);\r\n    this.destSize.width = newWidth;\r\n    super.width = Math.ceil(this.destSize.width);\r\n  }\r\n\r\n  public override set height(newHeight: number) {\r\n    newHeight /= Math.abs(this.scale.y);\r\n    this.destSize.height = newHeight;\r\n    super.height = Math.ceil(this.destSize.height);\r\n  }\r\n\r\n  private _updateSpriteDimensions() {\r\n    const { width: nativeWidth, height: nativeHeight } = this.image;\r\n    // This code uses || to avoid 0's\r\n    // If the source is not specified, use the native dimension\r\n    this.sourceView.width = this.sourceView?.width || nativeWidth;\r\n    this.sourceView.height = this.sourceView?.height || nativeHeight;\r\n\r\n    // If the destination is not specified, use the source if specified, then native\r\n    this.destSize.width = this.destSize?.width || this.sourceView?.width || nativeWidth;\r\n    this.destSize.height = this.destSize?.height || this.sourceView?.height || nativeHeight;\r\n\r\n    this.width = Math.ceil(this.destSize.width) * this.scale.x;\r\n    this.height = Math.ceil(this.destSize.height) * this.scale.y;\r\n  }\r\n\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded() && this._dirty) {\r\n      this._dirty = false;\r\n      this._updateSpriteDimensions();\r\n    }\r\n    super._preDraw(ex, x, y);\r\n  }\r\n\r\n  private _logNotLoadedWarning = false;\r\n  public _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded()) {\r\n      ex.drawImage(\r\n        this.image.image,\r\n        this.sourceView.x,\r\n        this.sourceView.y,\r\n        this.sourceView.width,\r\n        this.sourceView.height,\r\n        x,\r\n        y,\r\n        this.destSize.width,\r\n        this.destSize.height\r\n      );\r\n    } else {\r\n      if (!this._logNotLoadedWarning) {\r\n        this._logger.warn(\r\n          `ImageSource ${this.image.path}` +\r\n          ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\\n\\n` +\r\n          `Read https://excaliburjs.com/docs/imagesource for more information.`\r\n        );\r\n      }\r\n      this._logNotLoadedWarning = true;\r\n    }\r\n  }\r\n\r\n  public clone(): Sprite {\r\n    return new Sprite({\r\n      image: this.image,\r\n      sourceView: { ...this.sourceView },\r\n      destSize: { ...this.destSize },\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n}\r\n","\r\n/**\r\n * Describes the different image filtering modes\r\n */\r\nexport enum ImageFiltering {\r\n\r\n  /**\r\n   * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.\r\n   *\r\n   * Useful for Pixel art aesthetics.\r\n   */\r\n  Pixel = 'Pixel',\r\n\r\n  /**\r\n   * Blended is useful when you have high resolution artwork and would like it blended and smoothed\r\n   */\r\n  Blended = 'Blended'\r\n}","import { Logger } from '../../Util/Log';\r\nimport { ImageFiltering } from '../Filtering';\r\nimport { HTMLImageSource } from './ExcaliburGraphicsContext';\r\n\r\n/**\r\n * Manages loading image sources into webgl textures, a unique id is associated with all sources\r\n */\r\nexport class TextureLoader {\r\n  private static _LOGGER = Logger.getInstance();\r\n  /**\r\n   * Sets the default filtering for the Excalibur texture loader, default [[ImageFiltering.Blended]]\r\n   */\r\n  public static filtering: ImageFiltering = ImageFiltering.Blended;\r\n\r\n  private static _GL: WebGLRenderingContext;\r\n\r\n  private static _TEXTURE_MAP = new Map<HTMLImageSource, WebGLTexture>();\r\n\r\n  private static _MAX_TEXTURE_SIZE: number  = 0;\r\n\r\n  public static register(context: WebGLRenderingContext): void {\r\n    TextureLoader._GL = context;\r\n    TextureLoader._MAX_TEXTURE_SIZE = context.getParameter(context.MAX_TEXTURE_SIZE);\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL Texture from a source image\r\n   * @param image\r\n   */\r\n  public static get(image: HTMLImageSource): WebGLTexture {\r\n    return TextureLoader._TEXTURE_MAP.get(image);\r\n  }\r\n\r\n  /**\r\n   * Returns whether a source image has been loaded as a texture\r\n   * @param image\r\n   */\r\n  public static has(image: HTMLImageSource): boolean {\r\n    return TextureLoader._TEXTURE_MAP.has(image);\r\n  }\r\n\r\n  /**\r\n   * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered\r\n   * @param image Source graphic\r\n   * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture\r\n   * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed\r\n   */\r\n  public static load(image: HTMLImageSource, filtering?: ImageFiltering, forceUpdate = false): WebGLTexture {\r\n    // Ignore loading if webgl is not registered\r\n    const gl = TextureLoader._GL;\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    let tex: WebGLTexture = null;\r\n    // If reuse the texture if it's from the same source\r\n    if (TextureLoader.has(image)) {\r\n      tex = TextureLoader.get(image);\r\n    }\r\n\r\n    // Update existing webgl texture and return early\r\n    if (tex) {\r\n      if (forceUpdate) {\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n      }\r\n      return tex;\r\n    }\r\n\r\n    // No texture exists create a new one\r\n    tex = gl.createTexture();\r\n\r\n    TextureLoader.checkImageSizeSupportedAndLog(image);\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    // NEAREST for pixel art, LINEAR for hi-res\r\n    const filterMode = filtering ?? TextureLoader.filtering;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n\r\n    TextureLoader._TEXTURE_MAP.set(image, tex);\r\n    return tex;\r\n  }\r\n\r\n  public static delete(image: HTMLImageSource): void {\r\n    // Ignore loading if webgl is not registered\r\n    const gl = TextureLoader._GL;\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    let tex: WebGLTexture = null;\r\n    if (TextureLoader.has(image)) {\r\n      tex = TextureLoader.get(image);\r\n      gl.deleteTexture(tex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Takes an image and returns if it meets size criteria for hardware\r\n   * @param image\r\n   * @returns if the image will be supported at runtime\r\n   */\r\n  public static checkImageSizeSupportedAndLog(image: HTMLImageSource) {\r\n    const originalSrc = image.dataset.originalSrc ?? 'internal canvas bitmap';\r\n    if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {\r\n      TextureLoader._LOGGER.error(\r\n        `The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of `+\r\n        `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image `\r\n        +`for excalibur to render properly.\\n\\nImages will likely render as black rectangles.\\n\\n`+\r\n        `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n      return false;\r\n    } else if (image.width > 4096 || image.height > 4096) {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits\r\n      TextureLoader._LOGGER.warn(\r\n        `The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, `+\r\n        `it is recommended you resize images to a maximum (4096x4096).\\n\\n` +\r\n        `Images will likely render as black rectangles on some mobile platforms.\\n\\n` +\r\n        `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import { Resource } from '../Resources/Resource';\r\nimport { Sprite } from './Sprite';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { Logger } from '../Util/Log';\r\nimport { TextureLoader } from '.';\r\nimport { ImageFiltering } from './Filtering';\r\nimport { Future } from '../Util/Future';\r\n\r\nexport class ImageSource implements Loadable<HTMLImageElement> {\r\n  private _logger = Logger.getInstance();\r\n  private _resource: Resource<Blob>;\r\n  private _filtering: ImageFiltering;\r\n\r\n  /**\r\n   * The original size of the source image in pixels\r\n   */\r\n  public get width() {\r\n    return this.image.naturalWidth;\r\n  }\r\n\r\n  /**\r\n   * The original height of the source image in pixels\r\n   */\r\n  public get height() {\r\n    return this.image.naturalHeight;\r\n  }\r\n\r\n  private _src: string;\r\n  /**\r\n   * Returns true if the Texture is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    if (!this._src) {\r\n      // this boosts speed of access\r\n      this._src = this.data.src;\r\n    }\r\n    return !!this._src;\r\n  }\r\n\r\n  /**\r\n   * Access to the underlying html image element\r\n   */\r\n  public data: HTMLImageElement = new Image();\r\n  public get image(): HTMLImageElement {\r\n    return this.data;\r\n  }\r\n\r\n  private _readyFuture = new Future<HTMLImageElement>();\r\n  /**\r\n   * Promise the resolves when the image is loaded and ready for use, does not initiate loading\r\n   */\r\n  public ready: Promise<HTMLImageElement> = this._readyFuture.promise;\r\n\r\n  /**\r\n   * The path to the image, can also be a data url like 'data:image/'\r\n   * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute\r\n   * @param bustCache {boolean} Should excalibur add a cache busting querystring?\r\n   * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]\r\n   */\r\n  constructor(public readonly path: string, bustCache: boolean = false, filtering?: ImageFiltering) {\r\n    this._resource = new Resource(path, 'blob', bustCache);\r\n    this._filtering = filtering;\r\n    if (path.endsWith('.svg') || path.endsWith('.gif')) {\r\n      this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Begins loading the image and returns a promise that resolves when the image is loaded\r\n   */\r\n  async load(): Promise<HTMLImageElement> {\r\n    if (this.isLoaded()) {\r\n      return this.data;\r\n    }\r\n    try {\r\n      // Load base64 or blob if needed\r\n      let url: string;\r\n      if (!this.path.includes('data:image/')) {\r\n        const blob = await this._resource.load();\r\n        url = URL.createObjectURL(blob);\r\n      } else {\r\n        url = this.path;\r\n      }\r\n\r\n      // Decode the image\r\n      const image = new Image();\r\n      // Use Image.onload over Image.decode()\r\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7\r\n      // Otherwise chrome will throw still Image.decode() failures for large textures\r\n      const loadedFuture = new Future<void>();\r\n      image.onload = () => loadedFuture.resolve();\r\n      image.src = url;\r\n      image.setAttribute('data-original-src', this.path);\r\n\r\n      await loadedFuture.promise;\r\n\r\n      // Set results\r\n      this.data = image;\r\n    } catch (error) {\r\n      throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;\r\n    }\r\n    TextureLoader.load(this.data, this._filtering);\r\n    // todo emit complete\r\n    this._readyFuture.resolve(this.data);\r\n    return this.data;\r\n  }\r\n\r\n  /**\r\n   * Build a sprite from this ImageSource\r\n   */\r\n  public toSprite(): Sprite {\r\n    return Sprite.from(this);\r\n  }\r\n\r\n  /**\r\n   * Unload images from memory\r\n   */\r\n  unload(): void {\r\n    this.data = new Image();\r\n  }\r\n}\r\n","import { ImageSource } from './ImageSource';\r\nimport { SourceView, Sprite } from './Sprite';\r\nimport { Logger } from '../Util/Log';\r\n\r\n/**\r\n * Specify sprite sheet spacing options, useful if your sprites are not tightly packed\r\n * and have space between them.\r\n */\r\nexport interface SpriteSheetSpacingDimensions {\r\n  /**\r\n   * The starting point to offset and start slicing the sprite sheet from the top left of the image.\r\n   * Default is (0, 0)\r\n   */\r\n  originOffset?: { x?: number, y?: number };\r\n\r\n  /**\r\n   * The margin between sprites.\r\n   * Default is (0, 0)\r\n   */\r\n  margin?: {x?: number, y?: number};\r\n}\r\n\r\n/**\r\n * Sprite sheet options for slicing up images\r\n */\r\nexport interface SpriteSheetGridOptions {\r\n  /**\r\n   * Source image to use for each sprite\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * Grid definition for the sprite sheet\r\n   */\r\n  grid: {\r\n    /**\r\n     * Number of rows in the sprite sheet\r\n     */\r\n    rows: number;\r\n    /**\r\n     * Number of columns in the sprite sheet\r\n     */\r\n    columns: number;\r\n    /**\r\n     * Width of each individual sprite\r\n     */\r\n    spriteWidth: number;\r\n    /**\r\n     * Height of each individual sprite\r\n     */\r\n    spriteHeight: number;\r\n  };\r\n  /**\r\n   * Optionally specify any spacing information between sprites\r\n   */\r\n  spacing?: SpriteSheetSpacingDimensions;\r\n}\r\n\r\nexport interface SpriteSheetSparseOptions {\r\n  /**\r\n   * Source image to use for each sprite\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * List of source view rectangles to create a sprite sheet from\r\n   */\r\n  sourceViews: SourceView[];\r\n}\r\n\r\nexport interface SpriteSheetOptions {\r\n  /**\r\n   * Source sprites for the sprite sheet\r\n   */\r\n  sprites: Sprite[];\r\n  /**\r\n   * Optionally specify the number of rows in a sprite sheet (default 1 row)\r\n   */\r\n  rows?: number;\r\n  /**\r\n   * Optionally specify the number of columns in a sprite sheet (default sprites.length)\r\n   */\r\n  columns?: number;\r\n}\r\n\r\n/**\r\n * Represents a collection of sprites from a source image with some organization in a grid\r\n */\r\nexport class SpriteSheet {\r\n  private _logger = Logger.getInstance();\r\n  public readonly sprites: Sprite[] = [];\r\n  public readonly rows: number;\r\n  public readonly columns: number;\r\n\r\n  /**\r\n   * Build a new sprite sheet from a list of sprites\r\n   *\r\n   * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   * @param options\r\n   */\r\n  constructor(options: SpriteSheetOptions) {\r\n    const { sprites, rows, columns } = options;\r\n    this.sprites = sprites;\r\n    this.rows = rows ?? 1;\r\n    this.columns = columns ?? this.sprites.length;\r\n  }\r\n\r\n  /**\r\n   * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public getSprite(x: number, y: number): Sprite | null {\r\n    if (x >= this.columns || x < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);\r\n      return null;\r\n    }\r\n    if (y >= this.rows || y < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);\r\n      return null;\r\n    }\r\n    const spriteIndex = x + y * this.columns;\r\n    return this.sprites[spriteIndex];\r\n  }\r\n\r\n  /**\r\n   * Create a sprite sheet from a sparse set of [[SourceView]] rectangles\r\n   * @param options\r\n   */\r\n  public static fromImageSourceWithSourceViews(options: SpriteSheetSparseOptions): SpriteSheet {\r\n    const sprites: Sprite[] = options.sourceViews.map(sourceView => {\r\n      return new Sprite({\r\n        image: options.image,\r\n        sourceView\r\n      });\r\n    });\r\n    return new SpriteSheet({sprites});\r\n  }\r\n\r\n  /**\r\n   * Create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   *\r\n   * Example:\r\n   * ```\r\n   * const spriteSheet = SpriteSheet.fromImageSource({\r\n   *   image: imageSource,\r\n   *   grid: {\r\n   *     rows: 5,\r\n   *     columns: 2,\r\n   *     spriteWidth: 32, // pixels\r\n   *     spriteHeight: 32 // pixels\r\n   *   },\r\n   *   // Optionally specify spacing\r\n   *   spacing: {\r\n   *     // pixels from the top left to start the sprite parsing\r\n   *     originOffset: {\r\n   *       x: 5,\r\n   *       y: 5\r\n   *     },\r\n   *     // pixels between each sprite while parsing\r\n   *     margin: {\r\n   *       x: 1,\r\n   *       y: 1\r\n   *     }\r\n   *   }\r\n   * })\r\n   * ```\r\n   *\r\n   * @param options\r\n   */\r\n  public static fromImageSource(options: SpriteSheetGridOptions): SpriteSheet {\r\n    const sprites: Sprite[] = [];\r\n    options.spacing = options.spacing ?? {};\r\n    const {\r\n      image,\r\n      grid: { rows, columns: cols, spriteWidth, spriteHeight },\r\n      spacing: { originOffset, margin }\r\n    } = options;\r\n    const offsetDefaults = { x: 0, y: 0, ...originOffset};\r\n    const marginDefaults = { x: 0, y: 0, ...margin};\r\n    for (let x = 0; x < cols; x++) {\r\n      for (let y = 0; y < rows; y++) {\r\n        sprites[x + y * cols] = new Sprite({\r\n          image: image,\r\n          sourceView: {\r\n            x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,\r\n            y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,\r\n            width: spriteWidth,\r\n            height: spriteHeight\r\n          },\r\n          destSize: { height: spriteHeight, width: spriteWidth }\r\n        });\r\n      }\r\n    }\r\n    return new SpriteSheet({\r\n      sprites: sprites,\r\n      rows: rows,\r\n      columns: cols\r\n    });\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Logger } from '../Util/Log';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { FontRenderer } from './FontCommon';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Sprite } from './Sprite';\r\nimport { SpriteSheet } from './SpriteSheet';\r\nimport { BoundingBox, Color } from '..';\r\n\r\nexport interface SpriteFontOptions {\r\n  /**\r\n   * Alphabet string in spritesheet order (default is row column order)\r\n   * example: 'abcdefghijklmnopqrstuvwxyz'\r\n   */\r\n  alphabet: string;\r\n  /**\r\n   * [[SpriteSheet]] to source character sprites from\r\n   */\r\n  spriteSheet: SpriteSheet;\r\n  /**\r\n   * Optionally ignore case in the supplied text;\r\n   */\r\n  caseInsensitive?: boolean;\r\n  /**\r\n   * Optionally adjust the spacing between character sprites\r\n   */\r\n  spacing?: number;\r\n  /**\r\n   * Optionally specify a \"shadow\"\r\n   */\r\n  shadow?: { offset: Vector };\r\n}\r\n\r\nexport class SpriteFont extends Graphic implements FontRenderer {\r\n  private _text: string = '';\r\n  public alphabet: string = '';\r\n  public spriteSheet: SpriteSheet;\r\n\r\n  public shadow: { offset: Vector } = null;\r\n  public caseInsensitive = false;\r\n  public spacing: number = 0;\r\n\r\n  private _logger = Logger.getInstance();\r\n\r\n  constructor(options: SpriteFontOptions & GraphicOptions) {\r\n    super(options);\r\n    const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;\r\n    this.alphabet = alphabet;\r\n    this.spriteSheet = spriteSheet;\r\n    this.caseInsensitive = caseInsensitive ?? this.caseInsensitive;\r\n    this.spacing = spacing ?? this.spacing;\r\n    this.shadow = shadow ?? this.shadow;\r\n  }\r\n\r\n  private _alreadyWarnedAlphabet = false;\r\n  private _alreadyWarnedSpriteSheet = false;\r\n  private _getCharacterSprites(text: string): Sprite[] {\r\n    const results: Sprite[] = [];\r\n    // handle case insensitive\r\n    const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;\r\n    const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;\r\n\r\n    // for each letter in text\r\n    for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {\r\n      // find the sprite index in alphabet , if there is an error pick the first\r\n      const letter = textToRender[letterIndex];\r\n      let spriteIndex = alphabet.indexOf(letter);\r\n      if (spriteIndex === -1) {\r\n        spriteIndex = 0;\r\n        if (!this._alreadyWarnedAlphabet) {\r\n          this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);\r\n          this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n          this._alreadyWarnedAlphabet = true;\r\n        }\r\n      }\r\n\r\n      const letterSprite = this.spriteSheet.sprites[spriteIndex];\r\n      if (letterSprite) {\r\n        results.push(letterSprite);\r\n      } else {\r\n        if (!this._alreadyWarnedSpriteSheet) {\r\n          this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);\r\n          this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n          this._alreadyWarnedSpriteSheet = true;\r\n        }\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  public measureText(text: string): BoundingBox {\r\n    const lines = text.split('\\n');\r\n    const maxWidthLine = lines.reduce((a, b) => {\r\n      return a.length > b.length ? a : b;\r\n    });\r\n    const sprites = this._getCharacterSprites(maxWidthLine);\r\n    let width = 0;\r\n    let height = 0;\r\n    for (const sprite of sprites) {\r\n      width += sprite.width + this.spacing;\r\n      height = Math.max(height, sprite.height);\r\n    }\r\n    return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    let xCursor = 0;\r\n    let yCursor = 0;\r\n    let height = 0;\r\n    const lines = this._text.split('\\n');\r\n    for (const line of lines) {\r\n      for (const sprite of this._getCharacterSprites(line)) {\r\n        // draw it in the right spot and increase the cursor by sprite width\r\n        sprite.draw(ex, x + xCursor, y + yCursor);\r\n        xCursor += sprite.width + this.spacing;\r\n        height = Math.max(height, sprite.height);\r\n      }\r\n      xCursor = 0;\r\n      yCursor += height;\r\n    }\r\n  }\r\n\r\n  render(ex: ExcaliburGraphicsContext, text: string, _color: Color, x: number, y: number) {\r\n    // SpriteFont doesn't support _color, yet...\r\n    this._text = text;\r\n    const bounds = this.measureText(text);\r\n    this.width = bounds.width;\r\n    this.height = bounds.height;\r\n    if (this.shadow) {\r\n      ex.save();\r\n      ex.translate(this.shadow.offset.x, this.shadow.offset.y);\r\n      this.draw(ex, x, y);\r\n      ex.restore();\r\n    }\r\n\r\n    this.draw(ex, x, y);\r\n  }\r\n\r\n  clone(): SpriteFont {\r\n    return new SpriteFont({\r\n      alphabet: this.alphabet,\r\n      spriteSheet: this.spriteSheet,\r\n      spacing: this.spacing\r\n    });\r\n  }\r\n}\r\n","export default \"data:image/png;base64,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\"","import { ExcaliburGraphicsContext, ImageSource, SpriteFont, SpriteSheet } from '..';\r\nimport { Vector } from '../..';\r\nimport debugFont from './debug-font.png';\r\n\r\n/**\r\n * Internal debugtext helper\r\n */\r\nexport class DebugText {\r\n  constructor() {\r\n    this.load();\r\n  }\r\n\r\n  /**\r\n   * base64 font\r\n   */\r\n  public readonly fontSheet = debugFont;\r\n  public size: number = 16;\r\n  private _imageSource: ImageSource;\r\n  private _spriteSheet: SpriteSheet;\r\n  private _spriteFont: SpriteFont;\r\n  public load() {\r\n    this._imageSource = new ImageSource(this.fontSheet);\r\n    return this._imageSource.load().then(() => {\r\n      this._spriteSheet = SpriteSheet.fromImageSource({\r\n        image: this._imageSource,\r\n        grid: {\r\n          rows: 3,\r\n          columns: 16,\r\n          spriteWidth: 16,\r\n          spriteHeight: 16\r\n        }\r\n      });\r\n      this._spriteFont = new SpriteFont({\r\n        alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\\'&.\"?-()+ ',\r\n        caseInsensitive: true,\r\n        spriteSheet: this._spriteSheet,\r\n        spacing: -6\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Writes debug text using the built in sprint font\r\n   * @param ctx\r\n   * @param text\r\n   * @param pos\r\n   */\r\n  public write(ctx: ExcaliburGraphicsContext, text: string, pos: Vector) {\r\n    if (this._imageSource.isLoaded()) {\r\n      this._spriteFont.render(ctx, text, null, pos.x, pos.y);\r\n    }\r\n  }\r\n}\r\n","export class RenderSource {\r\n  constructor(\r\n    private _gl: WebGLRenderingContext,\r\n    private _texture: WebGLTexture) {}\r\n\r\n  public use() {\r\n    const gl = this._gl;\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, this._texture);\r\n  }\r\n\r\n  public disable() {\r\n    const gl = this._gl;\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n  }\r\n}","import { RenderSource } from './render-source';\r\n\r\nexport class RenderTarget {\r\n  width: number;\r\n  height: number;\r\n  private _gl: WebGLRenderingContext;\r\n  constructor(options: {gl: WebGLRenderingContext, width: number, height: number}) {\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this._gl = options.gl;\r\n    this._setupFramebuffer();\r\n  }\r\n\r\n  setResolution(width: number, height: number) {\r\n    const gl = this._gl;\r\n    this.width = width;\r\n    this.height = height;\r\n    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n  }\r\n\r\n  private _frameBuffer: WebGLFramebuffer;\r\n  public get frameBuffer() {\r\n    return this._frameBuffer;\r\n  }\r\n  private _frameTexture: WebGLTexture;\r\n  public get frameTexture() {\r\n    return this._frameTexture;\r\n  }\r\n  private _setupFramebuffer() {\r\n    // Allocates frame buffer\r\n    const gl = this._gl;\r\n    this._frameTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n\r\n    // set the filtering so we don't need mips\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n\r\n    // attach the texture as the first color attachment\r\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\r\n\r\n    // After this bind all draw calls will draw to this framebuffer texture\r\n    this._frameBuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);\r\n    // Reset after initialized\r\n    this.disable();\r\n  }\r\n\r\n  public toRenderSource() {\r\n    const source = new RenderSource(this._gl, this._frameTexture);\r\n    return source;\r\n  }\r\n\r\n  /**\r\n   * When called, all drawing gets redirected to this render target\r\n   */\r\n  public use() {\r\n    const gl = this._gl;\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n    // very important to set the viewport to the size of the framebuffer texture\r\n    gl.viewport(0, 0, this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * When called, all drawing is sent back to the canvas\r\n   */\r\n  public disable() {\r\n    const gl = this._gl;\r\n    // passing null switches rendering back to the canvas\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n  }\r\n}","\r\n/**\r\n * Must be accessed after Engine construction time to ensure the context has been created\r\n */\r\nexport class ExcaliburWebGLContextAccessor {\r\n  private static _GL: WebGL2RenderingContext;\r\n  public static clear() {\r\n    ExcaliburWebGLContextAccessor._GL = null;\r\n  }\r\n  public static register(gl: WebGL2RenderingContext) {\r\n    ExcaliburWebGLContextAccessor._GL = gl;\r\n  }\r\n  // current webgl context\r\n  public static get gl(): WebGL2RenderingContext {\r\n    if (!ExcaliburWebGLContextAccessor._GL) {\r\n      throw Error('Attempted gl access before init');\r\n    }\r\n    return ExcaliburWebGLContextAccessor._GL;\r\n  }\r\n}","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Color\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  fragColor = v_color;\\r\\n}\";","/**\r\n * Return the size of the GlType in bytes\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getGlTypeSizeBytes(gl: WebGLRenderingContext, type: number): number {\r\n  switch (type) {\r\n    case gl.FLOAT:\r\n      return 4;\r\n    case gl.SHORT:\r\n      return 2;\r\n    case gl.UNSIGNED_SHORT:\r\n      return 2;\r\n    case gl.BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_BYTE:\r\n      return 1;\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Based on the type return the number of attribute components\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getAttributeComponentSize(gl: WebGLRenderingContext, type: number): number {\r\n  switch (type) {\r\n    case gl.LOW_FLOAT:\r\n    case gl.HIGH_FLOAT:\r\n    case gl.FLOAT:\r\n      return 1;\r\n    case gl.FLOAT_VEC2:\r\n      return 2;\r\n    case gl.FLOAT_VEC3:\r\n      return 3;\r\n    case gl.FLOAT_VEC4:\r\n      return 4;\r\n    case gl.BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_SHORT:\r\n    case gl.SHORT:\r\n      return 1;\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Based on the attribute return the corresponding supported attrib pointer type\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n *\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getAttributePointerType(gl: WebGLRenderingContext, type: number) {\r\n  switch (type) {\r\n    case gl.LOW_FLOAT:\r\n    case gl.HIGH_FLOAT:\r\n    case gl.FLOAT:\r\n    case gl.FLOAT_VEC2:\r\n    case gl.FLOAT_VEC3:\r\n    case gl.FLOAT_VEC4:\r\n      return gl.FLOAT;\r\n    case gl.BYTE:\r\n      return gl.BYTE;\r\n    case gl.UNSIGNED_BYTE:\r\n      return gl.UNSIGNED_BYTE;\r\n    case gl.SHORT:\r\n      return gl.SHORT;\r\n    case gl.UNSIGNED_SHORT:\r\n      return gl.UNSIGNED_SHORT;\r\n    default:\r\n      return gl.FLOAT;\r\n  }\r\n}","import { Vector } from '../..';\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { getAttributeComponentSize, getAttributePointerType } from './webgl-util';\r\n\r\nexport type UniformTypeNames =\r\n  'uniform1f' |\r\n  'uniform1i' |\r\n  'uniform2f' |\r\n  'uniform2i' |\r\n  'uniform3f' |\r\n  'uniform3i' |\r\n  'uniform4f' |\r\n  'uniform4i' |\r\n  'uniform1fv' |\r\n  'uniform1iv' |\r\n  'uniform2fv' |\r\n  'uniform2iv' |\r\n  'uniform3fv' |\r\n  'uniform3iv' |\r\n  'uniform4fv' |\r\n  'uniform4iv' |\r\n  'uniformMatrix2fv' |\r\n  'uniformMatrix3fv' |\r\n  'uniformMatrix4fv';\r\n\r\ntype RemoveFirstFromTuple<T extends any[]> =\r\n  T['length'] extends 0 ? undefined :\r\n    (((...b: T) => void) extends (a: any, ...b: infer I) => void ? I : [])\r\n\r\ntype UniformParameters<TUniformType extends UniformTypeNames> = RemoveFirstFromTuple<Parameters<WebGLRenderingContext[TUniformType]>>\r\n\r\nexport interface UniformDefinition {\r\n  name: string;\r\n  glType: number;\r\n  location: WebGLUniformLocation;\r\n}\r\n\r\n\r\nexport interface VertexAttributeDefinition {\r\n  /**\r\n   * string name of the attribute in the shader program, commonly `a_nameofmyvariable`\r\n   */\r\n  name: string;\r\n  /**\r\n   * Number of components for a given attribute\r\n   * Must be 1, 2, 3, or 4\r\n   *\r\n   * For example a vec4 attribute would be `4` floats, so 4\r\n   */\r\n  size: number;\r\n  /**\r\n   * Supported types in webgl 1\r\n   * * gl.BYTE\r\n   * * gl.SHORT\r\n   * * gl.UNSIGNED_BYTE\r\n   * * gl.UNSIGNED_SHORT\r\n   * * gl.FLOAT\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n   */\r\n  glType: number;\r\n  /**\r\n   * Is the attribute normalized between (0-1)\r\n   */\r\n  normalized: boolean;\r\n  /**\r\n   * Location index in the shader program\r\n   */\r\n  location: number;\r\n}\r\n\r\nexport interface ShaderOptions {\r\n  vertexSource: string;\r\n  fragmentSource: string;\r\n}\r\n\r\nexport class Shader {\r\n  private static _ACTIVE_SHADER_INSTANCE: Shader = null;\r\n  private _gl: WebGLRenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  public program: WebGLProgram;\r\n  public uniforms: { [variableName: string]: UniformDefinition } = {};\r\n  public attributes: { [variableName: string]: VertexAttributeDefinition } = {};\r\n  private _compiled = false;\r\n  public readonly vertexSource: string;\r\n  public readonly fragmentSource: string;\r\n\r\n  public get compiled() {\r\n    return this._compiled;\r\n  }\r\n\r\n  /**\r\n   * Create a shader program in excalibur\r\n   * @param options specify shader vertex and fragment source\r\n   */\r\n  constructor(options?: ShaderOptions) {\r\n    const { vertexSource, fragmentSource } = options;\r\n    this.vertexSource = vertexSource;\r\n    this.fragmentSource = fragmentSource;\r\n  }\r\n\r\n  /**\r\n   * Binds the shader program\r\n   */\r\n  use() {\r\n    const gl = this._gl;\r\n    gl.useProgram(this.program);\r\n    Shader._ACTIVE_SHADER_INSTANCE = this;\r\n  }\r\n\r\n  isCurrentlyBound() {\r\n    return Shader._ACTIVE_SHADER_INSTANCE === this;\r\n  }\r\n\r\n  /**\r\n   * Compile the current shader against a webgl context\r\n   */\r\n  compile(): WebGLProgram {\r\n    const gl = this._gl;\r\n    const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);\r\n    const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);\r\n    this.program = this._createProgram(gl, vertexShader, fragmentShader);\r\n\r\n    const attributes = this.getAttributes();\r\n    for (const attribute of attributes) {\r\n      this.attributes[attribute.name] = attribute;\r\n    }\r\n    const uniforms = this.getUniforms();\r\n    for (const uniform of uniforms) {\r\n      this.uniforms[uniform.name] = uniform;\r\n    }\r\n\r\n    this._compiled = true;\r\n    return this.program;\r\n  }\r\n\r\n  getUniforms(): UniformDefinition[] {\r\n    const gl = this._gl;\r\n    const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\r\n    const uniforms: UniformDefinition[] = [];\r\n    for (let i = 0; i < uniformCount; i++) {\r\n      const uniform = gl.getActiveUniform(this.program, i);\r\n      const uniformLocation = gl.getUniformLocation(this.program, uniform.name);\r\n      uniforms.push({\r\n        name: uniform.name,\r\n        glType: uniform.type,\r\n        location: uniformLocation\r\n      });\r\n    }\r\n    return uniforms;\r\n  }\r\n\r\n  getAttributes(): VertexAttributeDefinition[] {\r\n    const gl = this._gl;\r\n    const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\r\n    const attributes: VertexAttributeDefinition[] = [];\r\n    for (let i = 0; i < attributeCount; i++) {\r\n      const attribute = gl.getActiveAttrib(this.program, i);\r\n      const attributeLocation = gl.getAttribLocation(this.program, attribute.name);\r\n      attributes.push({\r\n        name: attribute.name,\r\n        glType: getAttributePointerType(gl, attribute.type),\r\n        size: getAttributeComponentSize(gl, attribute.type),\r\n        location: attributeLocation,\r\n        normalized: false\r\n      });\r\n    }\r\n    return attributes;\r\n  }\r\n\r\n  /**\r\n   * Set a texture in a gpu texture slot\r\n   * @param slotNumber\r\n   * @param texture\r\n   */\r\n  setTexture(slotNumber: number, texture: WebGLTexture) {\r\n    const gl = this._gl;\r\n    gl.activeTexture(gl.TEXTURE0 + slotNumber);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  }\r\n\r\n  /**\r\n   * Set an integer uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformInt(name: string, value: number) {\r\n    this.setUniform('uniform1i', name, ~~value);\r\n  }\r\n\r\n  /**\r\n   * Set an integer array uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformIntArray(name: string, value: number[]) {\r\n    this.setUniform('uniform1iv', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a boolean uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformBoolean(name: string, value: boolean) {\r\n    this.setUniform('uniform1i', name, value ? 1 : 0);\r\n  }\r\n\r\n  /**\r\n   * Set a float uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloat(name: string, value: number) {\r\n    this.setUniform('uniform1f', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a float array uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloatArray(name: string, value: number[]) {\r\n    this.setUniform('uniform1fv', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a [[Vector]] uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloatVector(name: string, value: Vector) {\r\n    this.setUniform('uniform2f', name, value.x, value.y);\r\n  }\r\n\r\n  /**\r\n   * Set an [[Matrix]] uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformMatrix(name: string, value: Matrix) {\r\n    this.setUniform('uniformMatrix4fv', name, false, value.data);\r\n  }\r\n\r\n  /**\r\n   * Set any available uniform type in webgl\r\n   *\r\n   * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);\r\n   */\r\n  setUniform<TUniformType extends UniformTypeNames>(uniformType: TUniformType, name: string, ...value: UniformParameters<TUniformType>) {\r\n    if (!this._compiled) {\r\n      throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);\r\n    }\r\n    if (!this.isCurrentlyBound()) {\r\n      throw Error('Currently accessed shader instance is not the current active shader in WebGL,' +\r\n      ' must call `shader.use()` before setting uniforms');\r\n    }\r\n    const gl = this._gl;\r\n    const location = gl.getUniformLocation(this.program, name);\r\n    if (location) {\r\n      const args = [location, ...value];\r\n      this._gl[uniformType].apply(this._gl, args);\r\n    } else {\r\n      throw Error(`Uniform ${uniformType}:${name} doesn\\'t exist or is not used in the shader source code,`+\r\n      ' unused uniforms are optimized away by most browsers');\r\n    }\r\n  }\r\n\r\n  private _createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\r\n    const program = gl.createProgram();\r\n    if (program === null) {\r\n      throw Error('Could not create graphics shader program');\r\n    }\r\n\r\n    // attach the shaders.\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n\r\n    // link the program.\r\n    gl.linkProgram(program);\r\n\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!success) {\r\n      throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);\r\n    }\r\n\r\n    return program;\r\n  }\r\n\r\n  private _compileShader(gl: WebGLRenderingContext, source: string, type: number): WebGLShader {\r\n    const typeName = gl.VERTEX_SHADER === type ? 'vertex' : 'fragment';\r\n    const shader = gl.createShader(type);\r\n    if (shader === null) {\r\n      throw Error(`Could not build shader: [${source}]`);\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!success) {\r\n      const errorInfo = gl.getShaderInfoLog(shader);\r\n      throw Error(`Could not compile ${typeName} shader:\\n\\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  private _processSourceForError(source: string, errorInfo: string) {\r\n    const lines = source.split('\\n');\r\n    const errorLineStart = errorInfo.search(/\\d:\\d/);\r\n    const errorLineEnd = errorInfo.indexOf(' ', errorLineStart);\r\n    const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(':').map(v => Number(v));\r\n    for (let i = 0; i < lines.length; i++) {\r\n      lines[i] = `${i+1}: ${lines[i]}${error2 === (i+1)? ' <----- ERROR!' : ''}`;\r\n    }\r\n\r\n    return '\\n\\nSource:\\n' + lines.join('\\n');\r\n  }\r\n}","import { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\n\r\nexport interface VertexBufferOptions {\r\n  /**\r\n   * Size in number of floats, so [4.2, 4.0, 2.1] is size = 3\r\n   *\r\n   * Ignored if data is passed directly\r\n   */\r\n  size?: number;\r\n  /**\r\n   * If the vertices never change switching 'static' can be more efficient on the gpu\r\n   *\r\n   * Default is 'dynamic'\r\n   */\r\n  type?: 'static' | 'dynamic';\r\n\r\n  /**\r\n   * Optionally pass pre-seeded data, size parameter is ignored\r\n   */\r\n  data?: Float32Array\r\n}\r\n\r\n/**\r\n * Helper around vertex buffer to simplify creating and uploading geometry\r\n *\r\n * Under the hood uses Float32Array\r\n */\r\nexport class VertexBuffer {\r\n  private _gl: WebGL2RenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n\r\n  /**\r\n   * Access to the webgl buffer handle\r\n   */\r\n  public readonly buffer: WebGLBuffer;\r\n  /**\r\n   * Access to the raw data of the vertex buffer\r\n   */\r\n  public readonly bufferData: Float32Array;\r\n\r\n  /**\r\n   * If the vertices never change switching 'static' can be more efficient on the gpu\r\n   *\r\n   * Default is 'dynamic'\r\n   */\r\n  public type: 'static' | 'dynamic' = 'dynamic';\r\n\r\n  constructor(options: VertexBufferOptions) {\r\n    const { size, type, data } = options;\r\n    this.buffer = this._gl.createBuffer();\r\n    if (!data && !size) {\r\n      throw Error('Must either provide data or a size to the VertexBuffer');\r\n    }\r\n\r\n    if (!data) {\r\n      this.bufferData = new Float32Array(size);\r\n    } else {\r\n      this.bufferData = data;\r\n    }\r\n    this.type = type ?? this.type;\r\n    // Allocate buffer\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n  }\r\n\r\n  /**\r\n   * Bind this vertex buffer\r\n   */\r\n  bind() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n\r\n  }\r\n\r\n  /**\r\n   * Upload vertex buffer geometry to the GPU\r\n   */\r\n  upload(count?: number) {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n    if (count) {\r\n      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);\r\n    } else {\r\n      // TODO always use bufferSubData? need to perf test it\r\n      gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n    }\r\n  }\r\n}","import { Logger } from '../..';\r\nimport { Shader, VertexAttributeDefinition } from './shader';\r\nimport { VertexBuffer } from './vertex-buffer';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { getGlTypeSizeBytes } from './webgl-util';\r\n\r\n\r\nexport interface VertexLayoutOptions {\r\n  /**\r\n   * Shader that this layout will be for\r\n   */\r\n  shader: Shader;\r\n  /**\r\n   * Vertex buffer to use for vertex data\r\n   */\r\n  vertexBuffer: VertexBuffer,\r\n  /**\r\n   * Specify the attributes that will exist in the vertex buffer\r\n   *\r\n   * **Important** must specify them in the order that they will be in the vertex buffer!!\r\n   */\r\n  attributes: [name: string, numberOfComponents: number][]\r\n}\r\n\r\n/**\r\n * Helper around creating vertex attributes in a given [[VertexBuffer]], this is useful for describing\r\n * the memory layout for your vertices inside a particular buffer\r\n *\r\n * Note: This helper assumes interleaved attributes in one [[VertexBuffer]], not many.\r\n *\r\n * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you\r\n */\r\nexport class VertexLayout {\r\n  private _gl: WebGLRenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  private _logger = Logger.getInstance();\r\n  private _shader: Shader;\r\n  private _layout: VertexAttributeDefinition[] = [];\r\n  private _attributes: [name: string, numberOfComponents: number][] = [];\r\n  private _vertexBuffer: VertexBuffer;\r\n  public get vertexBuffer() {\r\n    return this._vertexBuffer;\r\n  }\r\n\r\n  public get attributes(): readonly [name: string, numberOfComponents: number][] {\r\n    return this._attributes;\r\n  }\r\n\r\n  constructor(options: VertexLayoutOptions) {\r\n    const {shader, vertexBuffer, attributes} = options;\r\n    this._vertexBuffer = vertexBuffer;\r\n    this._attributes = attributes;\r\n    this._shader = shader;\r\n    this.initialize();\r\n  }\r\n\r\n  private _vertexTotalSizeBytes = 0;\r\n  /**\r\n   * Total number of bytes that the vertex will take up\r\n   */\r\n  public get totalVertexSizeBytes(): number {\r\n    return this._vertexTotalSizeBytes;\r\n  }\r\n\r\n  /**\r\n   * Layouts need shader locations and must be bound to a shader\r\n   */\r\n  initialize() {\r\n    if (!this._shader.compiled) {\r\n      throw Error('Shader not compiled, shader must be compiled before defining a vertex layout');\r\n    }\r\n    this._layout.length = 0;\r\n    const shaderAttributes = this._shader.attributes;\r\n    for (const attribute of this._attributes) {\r\n      const attrib = shaderAttributes[attribute[0]];\r\n      if (!attrib) {\r\n        throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}`+\r\n        ` not found in the shader source code:\\n ${this._shader.vertexSource}`);\r\n      }\r\n      if (attrib.size !== attribute[1]) {\r\n        throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],`\r\n        +` doesnt match shader source size ${attrib.size}:\\n ${this._shader.vertexSource}`);\r\n      }\r\n      this._layout.push(attrib);\r\n    }\r\n\r\n    // calc size\r\n    let componentsPerVertex = 0;\r\n    for (const vertAttribute of this._layout) {\r\n      const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);\r\n      this._vertexTotalSizeBytes += typeSize * vertAttribute.size;\r\n      componentsPerVertex += vertAttribute.size;\r\n    }\r\n\r\n    if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {\r\n      this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer`\r\n      +` (${this._vertexBuffer.bufferData.length})`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind this layout with it's associated vertex buffer\r\n   *\r\n   * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout\r\n   */\r\n  use(uploadBuffer = false, count?: number) {\r\n    const gl = this._gl;\r\n    if (!this._shader.isCurrentlyBound()) {\r\n      throw Error('Shader associated with this vertex layout is not active! Call shader.use() before layout.use()');\r\n    }\r\n    this._vertexBuffer.bind();\r\n    if (uploadBuffer) {\r\n      this._vertexBuffer.upload(count);\r\n    }\r\n    let offset = 0;\r\n    // TODO switch to VAOs if the extension is\r\n    for (const vert of this._layout) {\r\n      gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);\r\n      gl.enableVertexAttribArray(vert.location);\r\n      offset += getGlTypeSizeBytes(gl, vert.glType) * vert.size;\r\n    }\r\n  }\r\n}","export class GraphicsDiagnostics {\r\n  public static DrawCallCount: number = 0;\r\n  public static DrawnImagesCount: number = 0;\r\n  public static clear(): void {\r\n    GraphicsDiagnostics.DrawCallCount = 0;\r\n    GraphicsDiagnostics.DrawnImagesCount = 0;\r\n  }\r\n}\r\n","import { Vector } from '../../../Math/vector';\r\nimport { Color } from '../../../Color';\r\nimport lineVertexSource from './line-vertex.glsl';\r\nimport lineFragmentSource from './line-fragment.glsl';\r\nimport { ExcaliburGraphicsContextWebGL } from '../ExcaliburGraphicsContextWebGL';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader, VertexBuffer, VertexLayout } from '../..';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\n\r\nexport class LineRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.line';\r\n  public priority: number = 0;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _maxLines: number = 10922;\r\n  private _vertexBuffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _vertexIndex = 0;\r\n  private _lineCount = 0;\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      vertexSource: lineVertexSource,\r\n      fragmentSource: lineFragmentSource\r\n    });\r\n    this._shader.compile();\r\n    this._shader.use();\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    this._vertexBuffer = new VertexBuffer({\r\n      size: 6 * 2 * this._maxLines,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      vertexBuffer: this._vertexBuffer,\r\n      shader: this._shader,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_color', 4]\r\n      ]\r\n    });\r\n  }\r\n\r\n  draw(start: Vector, end: Vector, color: Color): void {\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._lineCount++;\r\n\r\n    const transform = this._context.getTransform();\r\n    const finalStart = transform.multiply(start);\r\n    const finalEnd = transform.multiply(end);\r\n\r\n\r\n    const vertexBuffer = this._vertexBuffer.bufferData;\r\n    // Start\r\n    vertexBuffer[this._vertexIndex++] = finalStart.x;\r\n    vertexBuffer[this._vertexIndex++] = finalStart.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n\r\n    // End\r\n    vertexBuffer[this._vertexIndex++] = finalEnd.x;\r\n    vertexBuffer[this._vertexIndex++] = finalEnd.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._lineCount >= this._maxLines) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._lineCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._lineCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use(true);\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._lineCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // reset\r\n    this._vertexIndex = 0;\r\n    this._lineCount = 0;\r\n  }\r\n}\r\n","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\nin float a_size;\\r\\nout lowp vec4 v_color;\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n  gl_PointSize = a_size * 2.0;\\r\\n  v_color = a_color;\\r\\n}\";","import pointVertexSource from './point-vertex.glsl';\r\nimport pointFragmentSource from './point-fragment.glsl';\r\nimport { Vector } from '../../../Math/vector';\r\nimport { Color } from '../../../Color';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\n\r\nexport class PointRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.point';\r\n  public priority: number = 0;\r\n  private _shader: Shader;\r\n  private _maxPoints: number = 10922;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _gl: WebGLRenderingContext;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _pointCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      vertexSource: pointVertexSource,\r\n      fragmentSource: pointFragmentSource\r\n    });\r\n    this._shader.compile();\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n    this._buffer = new VertexBuffer({\r\n      size: 7 * this._maxPoints,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_color', 4],\r\n        ['a_size', 1]\r\n      ]\r\n    });\r\n  }\r\n\r\n  draw(point: Vector, color: Color, size: number): void {\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._pointCount++;\r\n\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const finalPoint = transform.multiply(point);\r\n\r\n    if (snapToPixel) {\r\n      finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);\r\n      finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    const vertexBuffer = this._buffer.bufferData;\r\n    vertexBuffer[this._vertexIndex++] = finalPoint.x;\r\n    vertexBuffer[this._vertexIndex++] = finalPoint.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a * opacity;\r\n    vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._pointCount >= this._maxPoints) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._pointCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._pointCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use(true);\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    gl.drawArrays(gl.POINTS, 0, this._pointCount);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._pointCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    this._pointCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n}\r\n","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\nin vec2 a_texcoord;\\r\\nout vec2 v_texcoord;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n  // Pass the texcoord to the fragment shader.\\r\\n  v_texcoord = a_texcoord;\\r\\n}\";","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// The texture.\\r\\nuniform sampler2D u_texture;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   fragColor = texture(u_texture, v_texcoord);\\r\\n}\";","\r\nimport screenVertex from './screen-vertex.glsl';\r\nimport screenFragment from './screen-fragment.glsl';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport { PostProcessor } from '../../PostProcessor/PostProcessor';\r\n\r\n/**\r\n * This is responsible for painting the entire screen during the render passes\r\n */\r\nexport class ScreenPassPainter {\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  constructor(gl: WebGLRenderingContext) {\r\n    this._gl = gl;\r\n    this._shader = new Shader({\r\n      vertexSource: screenVertex,\r\n      fragmentSource: screenFragment\r\n    });\r\n    this._shader.compile();\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      type: 'static',\r\n      // clip space quad + uv since we don't need a camera\r\n      data: new Float32Array([\r\n        -1, -1,          0, 0,\r\n        -1, 1,           0, 1,\r\n        1, -1,           1, 0,\r\n\r\n        1, -1,            1, 0,\r\n        -1, 1,           0, 1,\r\n        1, 1,            1, 1\r\n      ])\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_texcoord', 2]\r\n      ]\r\n    });\r\n    this._buffer.upload();\r\n  }\r\n\r\n  renderWithPostProcessor(postprocessor: PostProcessor): void {\r\n    const gl = this._gl;\r\n    postprocessor.getShader().use();\r\n    postprocessor.getLayout().use();\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n\r\n  renderToScreen(): void {\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use();\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n}","import { Logger } from '../..';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\n\r\n/**\r\n * Helper that defines and index buffer for quad geometry\r\n *\r\n * Index buffers allow you to save space in vertex buffers when you share vertices in geometry\r\n * it is almost always worth it in terms of performance to use an index buffer.\r\n */\r\nexport class QuadIndexBuffer {\r\n  private _gl: WebGL2RenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  private _logger: Logger = Logger.getInstance();\r\n  /**\r\n   * Access to the webgl buffer handle\r\n   */\r\n  public buffer: WebGLBuffer;\r\n  /**\r\n   * Access to the raw data of the index buffer\r\n   */\r\n  public bufferData: Uint16Array | Uint32Array;\r\n  /**\r\n   * Depending on the browser this is either gl.UNSIGNED_SHORT or gl.UNSIGNED_INT\r\n   */\r\n  public bufferGlType: number;\r\n\r\n  /**\r\n   * @param numberOfQuads Specify the max number of quads you want to draw\r\n   * @param useUint16 Optionally force a uint16 buffer\r\n   */\r\n  constructor(numberOfQuads: number, useUint16?: boolean) {\r\n    const gl = this._gl;\r\n    this.buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n\r\n    const totalVertices = numberOfQuads * 6;\r\n\r\n    if (!useUint16) {\r\n      this.bufferData = new Uint32Array(totalVertices);\r\n    } else {\r\n      // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck\r\n      const maxUint16 = 65_535;\r\n      const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads\r\n\r\n      this.bufferGlType = gl.UNSIGNED_SHORT;\r\n      this.bufferData = new Uint16Array(totalVertices);\r\n      // TODO Should we error if this happens?? maybe not might crash mid game\r\n      if (numberOfQuads > maxUint16Index) {\r\n        this._logger.warn(\r\n          `Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);\r\n      }\r\n    }\r\n\r\n\r\n    let currentQuad = 0;\r\n    for (let i = 0; i < totalVertices; i += 6) {\r\n      // first triangle\r\n      this.bufferData[i + 0] = currentQuad + 0;\r\n      this.bufferData[i + 1] = currentQuad + 1;\r\n      this.bufferData[i + 2] = currentQuad + 2;\r\n      // second triangle\r\n      this.bufferData[i + 3] = currentQuad + 2;\r\n      this.bufferData[i + 4] = currentQuad + 1;\r\n      this.bufferData[i + 5] = currentQuad + 3;\r\n      currentQuad += 4;\r\n    }\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n  }\r\n\r\n  public get size() {\r\n    return this.bufferData.length;\r\n  }\r\n\r\n  /**\r\n   * Upload data to the GPU\r\n   */\r\n  public upload() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n  }\r\n\r\n  /**\r\n   * Bind this index buffer\r\n   */\r\n  public bind() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n  }\r\n}","import { vec } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { HTMLImageSource } from '../ExcaliburGraphicsContext';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { TextureLoader } from '../texture-loader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport frag from './image-renderer.frag.glsl';\r\nimport vert from './image-renderer.vert.glsl';\r\n\r\nexport class ImageRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.image';\r\n  public priority: number = 0;\r\n\r\n  private _maxImages: number = 10922; // max(uint16) / 6 verts\r\n  private _maxTextures: number = 0;\r\n\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n\r\n  // Per flush vars\r\n  private _imageCount: number = 0;\r\n  private _textures: WebGLTexture[] = [];\r\n  private _vertexIndex: number = 0;\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    // Transform shader source\r\n    // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...\r\n    this._maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), 125);\r\n    const transformedFrag = this._transformFragmentSource(frag, this._maxTextures);\r\n    // Compile shader\r\n    this._shader = new Shader({\r\n      fragmentSource: transformedFrag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n    // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]\r\n    this._shader.setUniformIntArray(\r\n      'u_textures',\r\n      [...Array(this._maxTextures)].map((_, i) => i)\r\n    );\r\n\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      size: 10 * 4 * this._maxImages, // 10 components * 4 verts\r\n      type: 'dynamic'\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_opacity', 1],\r\n        ['a_texcoord', 2],\r\n        ['a_textureIndex', 1],\r\n        ['a_tint', 4]\r\n      ]\r\n    });\r\n\r\n    // Setup index buffer\r\n    this._quads = new QuadIndexBuffer(this._maxImages, true);\r\n  }\r\n\r\n  private _transformFragmentSource(source: string, maxTextures: number): string {\r\n    let newSource = source.replace('%%count%%', maxTextures.toString());\r\n    let texturePickerBuilder = '';\r\n    for (let i = 0; i < maxTextures; i++) {\r\n      if (i === 0) {\r\n        texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\\n`;\r\n      } else {\r\n        texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\\n`;\r\n      }\r\n      texturePickerBuilder += `      color = texture(u_textures[${i}], v_texcoord);\\n`;\r\n      texturePickerBuilder += `   }\\n`;\r\n    }\r\n    newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);\r\n    return newSource;\r\n  }\r\n\r\n  private _addImageAsTexture(image: HTMLImageSource) {\r\n    const texture = TextureLoader.load(image);\r\n    if (this._textures.indexOf(texture) === -1) {\r\n      this._textures.push(texture);\r\n    }\r\n  }\r\n\r\n  private _bindTextures(gl: WebGLRenderingContext) {\r\n    // Bind textures in the correct order\r\n    for (let i = 0; i < this._maxTextures; i++) {\r\n      gl.activeTexture(gl.TEXTURE0 + i);\r\n      gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);\r\n    }\r\n  }\r\n\r\n  private _getTextureIdForImage(image: HTMLImageSource) {\r\n    if (image) {\r\n      return this._textures.indexOf(TextureLoader.get(image));\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._imageCount >= this._maxImages) {\r\n      return true;\r\n    }\r\n    if (this._textures.length >= this._maxTextures) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  draw(image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number): void {\r\n\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._imageCount++;\r\n    this._addImageAsTexture(image);\r\n\r\n    let width = image?.width || swidth || 0;\r\n    let height = image?.height || sheight || 0;\r\n    let view = [0, 0, swidth ?? image?.width ?? 0, sheight ?? image?.height ?? 0];\r\n    let dest = [sx ?? 1, sy ?? 1];\r\n    // If destination is specified, update view and dest\r\n    if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {\r\n      view = [sx ?? 1, sy ?? 1, swidth ?? image?.width ?? 0, sheight ?? image?.height ?? 0];\r\n      dest = [dx, dy];\r\n      width = dwidth;\r\n      height = dheight;\r\n    }\r\n\r\n    sx = view[0];\r\n    sy = view[1];\r\n    const sw = view[2];\r\n    const sh = view[3];\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    let topLeft = vec(dest[0], dest[1]);\r\n    let topRight = vec(dest[0] + width, dest[1]);\r\n    let bottomLeft = vec(dest[0], dest[1] + height);\r\n    let bottomRight = vec(dest[0] + width, dest[1] + height);\r\n\r\n    topLeft = transform.multiply(topLeft);\r\n    topRight = transform.multiply(topRight);\r\n    bottomLeft = transform.multiply(bottomLeft);\r\n    bottomRight = transform.multiply(bottomRight);\r\n\r\n    if (snapToPixel) {\r\n      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n\r\n      topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n      topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n\r\n      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n\r\n      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    const tint = this._context.tint;\r\n\r\n    const textureId = this._getTextureIdForImage(image);\r\n    const imageWidth = image.width || width;\r\n    const imageHeight = image.height || height;\r\n\r\n    const uvx0 = (sx) / imageWidth;\r\n    const uvy0 = (sy) / imageHeight;\r\n    const uvx1 = (sx + sw - 0.01) / imageWidth;\r\n    const uvy1 = (sy + sh - 0.01) / imageHeight;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._imageCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._imageCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true, 4 * 10 * this._imageCount);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind textures to\r\n    this._bindTextures(gl);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._imageCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._imageCount = 0;\r\n    this._vertexIndex = 0;\r\n    this._textures.length = 0;\r\n  }\r\n}","import { Color } from '../../../Color';\r\nimport { vec, Vector } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\n\r\nimport frag from './rectangle-renderer.frag.glsl';\r\nimport vert from './rectangle-renderer.vert.glsl';\r\n\r\nexport class RectangleRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.rectangle';\r\n  public priority: number = 0;\r\n\r\n  private _maxRectangles: number = 10922; // max(uint16) / 6 verts\r\n\r\n  private _shader: Shader;\r\n  private _gl: WebGLRenderingContext;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n  private _rectangleCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n    this._shader = new Shader({\r\n      fragmentSource: frag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n\r\n    this._buffer = new VertexBuffer({\r\n      size: 16 * 4 * this._maxRectangles,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_uv', 2],\r\n        ['a_size', 2],\r\n        ['a_opacity', 1],\r\n        ['a_color', 4],\r\n        ['a_strokeColor', 4],\r\n        ['a_strokeThickness', 1]\r\n      ]\r\n    });\r\n    this._quads = new QuadIndexBuffer(this._maxRectangles, true);\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._rectangleCount >= this._maxRectangles) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  draw(...args: any[]): void {\r\n    if (args[0] instanceof Vector && args[1] instanceof Vector) {\r\n      this.drawLine.apply(this, args);\r\n    } else {\r\n      this.drawRectangle.apply(this, args);\r\n    }\r\n  }\r\n\r\n  drawLine(start: Vector, end: Vector, color: Color, thickness: number = 1) {\r\n\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._rectangleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const dir = end.sub(start);\r\n    const length = dir.size;\r\n    const normal = dir.normalize().perpendicular();\r\n    const halfThick = thickness / 2;\r\n\r\n    /**\r\n     *    +---------------------^----------------------+\r\n     *    |                     | (normal)             |\r\n     *   (startx, starty)------------------>(endx, endy)\r\n     *    |                                            |\r\n     *    + -------------------------------------------+\r\n     */\r\n    const startTop = transform.multiply(normal.scale(halfThick).add(start));\r\n    const startBottom = transform.multiply(normal.scale(-halfThick).add(start));\r\n    const endTop = transform.multiply(normal.scale(halfThick).add(end));\r\n    const endBottom = transform.multiply(normal.scale(-halfThick).add(end));\r\n\r\n    if (snapToPixel) {\r\n      startTop.x = ~~(startTop.x + pixelSnapEpsilon);\r\n      startTop.y = ~~(startTop.y + pixelSnapEpsilon);\r\n\r\n      endTop.x = ~~(endTop.x + pixelSnapEpsilon);\r\n      endTop.y = ~~(endTop.y + pixelSnapEpsilon);\r\n\r\n      startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);\r\n      startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);\r\n\r\n      endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);\r\n      endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    // TODO uv could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    const stroke = Color.Transparent;\r\n    const strokeThickness = 0;\r\n    const width = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = startTop.x;\r\n    vertexBuffer[this._vertexIndex++] = startTop.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = startBottom.x;\r\n    vertexBuffer[this._vertexIndex++] = startBottom.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = endTop.x;\r\n    vertexBuffer[this._vertexIndex++] = endTop.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = endBottom.x;\r\n    vertexBuffer[this._vertexIndex++] = endBottom.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n  }\r\n\r\n  drawRectangle(\r\n    pos: Vector,\r\n    width: number,\r\n    height: number,\r\n    color: Color,\r\n    stroke: Color = Color.Transparent,\r\n    strokeThickness: number = 0): void {\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._rectangleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const topLeft = transform.multiply(pos.add(vec(0, 0)));\r\n    const topRight = transform.multiply(pos.add(vec(width, 0)));\r\n    const bottomRight = transform.multiply(pos.add(vec(width, height)));\r\n    const bottomLeft = transform.multiply(pos.add(vec(0, height)));\r\n\r\n    if (snapToPixel) {\r\n      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n\r\n      topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n      topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n\r\n      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n\r\n      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    // TODO uv could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._rectangleCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._rectangleCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._rectangleCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n\r\n}","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_uv;\\r\\nout vec2 v_uv;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\nin vec4 a_color;\\r\\nout vec4 v_color;\\r\\n\\r\\nin vec4 a_strokeColor;\\r\\nout vec4 v_strokeColor;\\r\\n\\r\\nin float a_strokeThickness;\\r\\nout float v_strokeThickness;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through UV coords\\r\\n   v_uv = a_uv;\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n   // Pass through the stroke color to the fragment shader\\r\\n   v_strokeColor = a_strokeColor;\\r\\n   // Pass through the stroke thickenss to the fragment shader\\r\\n   v_strokeThickness = a_strokeThickness;\\r\\n}\";","import { Color } from '../../../Color';\r\nimport { vec, Vector } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\n\r\nimport frag from './circle-renderer.frag.glsl';\r\nimport vert from './circle-renderer.vert.glsl';\r\n\r\nexport class CircleRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.circle';\r\n  public priority: number = 0;\r\n\r\n  private _maxCircles: number = 10922; // max(uint16) / 6 verts\r\n\r\n  private _shader: Shader;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n\r\n  private _circleCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      fragmentSource: frag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n\r\n    this._buffer = new VertexBuffer({\r\n      size: 14 * 4 * this._maxCircles,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_uv', 2],\r\n        ['a_opacity', 1],\r\n        ['a_color', 4],\r\n        ['a_strokeColor', 4],\r\n        ['a_strokeThickness', 1]\r\n      ]\r\n    });\r\n\r\n    this._quads = new QuadIndexBuffer(this._maxCircles, true);\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._circleCount >= this._maxCircles) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  draw(pos: Vector, radius: number, color: Color, stroke: Color = Color.Transparent, strokeThickness: number = 0): void {\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._circleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));\r\n    const topRight = transform.multiply(pos.add(vec(radius, -radius)));\r\n    const bottomRight = transform.multiply(pos.add(vec(radius, radius)));\r\n    const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));\r\n\r\n    if (snapToPixel) {\r\n      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n\r\n      topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n      topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n\r\n      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n\r\n      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    // TODO UV could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._circleCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._circleCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._circleCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._circleCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n\r\n}","import { Logger } from '..';\r\nexport class Pool<Type> {\r\n  public totalAllocations = 0;\r\n  public index = 0;\r\n  public objects: Type[] = [];\r\n  public disableWarnings = false;\r\n  private _logger = Logger.getInstance();\r\n\r\n  constructor(\r\n    public builder: (...args: any[]) => Type,\r\n    public recycler: (instance: Type, ...args: any[]) => Type,\r\n    public maxObjects: number = 100\r\n  ) {}\r\n\r\n  preallocate() {\r\n    for (let i = 0; i < this.maxObjects; i++) {\r\n      this.objects[i] = this.builder();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use many instances out of the in the context and return all to the pool.\r\n   *\r\n   * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers\r\n   * @param context\r\n   */\r\n  using(context: (pool: Pool<Type>) => Type[] | void) {\r\n    const result = context(this);\r\n    if (result) {\r\n      return this.done(...result);\r\n    }\r\n    return this.done();\r\n  }\r\n\r\n  /**\r\n   * Use a single instance out of th pool and immediately return it to the pool\r\n   * @param context\r\n   */\r\n  borrow(context: (object: Type) => void) {\r\n    const object = this.get();\r\n    context(object);\r\n    this.index--;\r\n  }\r\n\r\n  /**\r\n   * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool\r\n   * @param args\r\n   */\r\n  get(...args: any[]): Type {\r\n    if (this.index === this.maxObjects) {\r\n      if (!this.disableWarnings) {\r\n        this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');\r\n      }\r\n      this.maxObjects = this.maxObjects * 2;\r\n    }\r\n\r\n    if (this.objects[this.index]) {\r\n      // Pool has an available object already constructed\r\n      return this.recycler(this.objects[this.index++], ...args);\r\n    } else {\r\n      // New allocation\r\n      this.totalAllocations++;\r\n      const object = (this.objects[this.index++] = this.builder(...args));\r\n      return object;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Signals we are done with the pool objects for now, Reclaims all objects in the pool.\r\n   *\r\n   * If a list of pooled objects is passed to done they are un-hooked from the pool and are free\r\n   * to be passed to consumers\r\n   * @param objects A list of object to separate from the pool\r\n   */\r\n  done(...objects: Type[]): Type[];\r\n  done(): void;\r\n  done(...objects: Type[]): Type[] | void {\r\n    // All objects in pool now considered \"free\"\r\n    this.index = 0;\r\n    for (const object of objects) {\r\n      const poolIndex = this.objects.indexOf(object);\r\n      // Build a new object to take the pool place\r\n      this.objects[poolIndex] = (this as any).builder(); // TODO problematic 0-arg only support\r\n      this.totalAllocations++;\r\n    }\r\n    return objects;\r\n  }\r\n}\r\n","import { AffineMatrix } from '../../Math/affine-matrix';\r\nimport { Color } from '../../Color';\r\nimport { ExcaliburGraphicsContextState } from './ExcaliburGraphicsContext';\r\n\r\nexport class DrawCall {\r\n  public z: number = 0;\r\n  public priority: number = 0;\r\n  public renderer: string;\r\n  public transform: AffineMatrix = AffineMatrix.identity();\r\n  public state: ExcaliburGraphicsContextState = {\r\n    z: 0,\r\n    opacity: 1,\r\n    tint: Color.White\r\n  };\r\n  public args: any[];\r\n}","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  RectGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\n\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { TransformStack } from './transform-stack';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { Logger } from '../../Util/Log';\r\nimport { DebugText } from './debug-text';\r\nimport { ScreenDimension } from '../../Screen';\r\nimport { RenderTarget } from './render-target';\r\nimport { PostProcessor } from '../PostProcessor/PostProcessor';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { TextureLoader } from './texture-loader';\r\nimport { RendererPlugin } from './renderer';\r\n\r\n// renderers\r\nimport { LineRenderer } from './line-renderer/line-renderer';\r\nimport { PointRenderer } from './point-renderer/point-renderer';\r\nimport { ScreenPassPainter } from './screen-pass-painter/screen-pass-painter';\r\nimport { ImageRenderer } from './image-renderer/image-renderer';\r\nimport { RectangleRenderer } from './rectangle-renderer/rectangle-renderer';\r\nimport { CircleRenderer } from './circle-renderer/circle-renderer';\r\nimport { Pool } from '../../Util/Pool';\r\nimport { DrawCall } from './draw-call';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport const pixelSnapEpsilon = 0.0001;\r\n\r\nclass ExcaliburGraphicsContextWebGLDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _webglCtx: ExcaliburGraphicsContextWebGL) {}\r\n\r\n  /**\r\n   * Draw a debugging rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number, rectOptions: RectGraphicsOptions = { color: Color.Black }): void {\r\n    this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging line to the context\r\n   * @param start\r\n   * @param end\r\n   * @param lineOptions\r\n   */\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._webglCtx.draw<LineRenderer>('ex.line', start, end, lineOptions.color);\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging point to the context\r\n   * @param point\r\n   * @param pointOptions\r\n   */\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._webglCtx.draw<PointRenderer>('ex.point', point, pointOptions.color, pointOptions.size);\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._webglCtx, text, pos);\r\n  }\r\n}\r\n\r\nexport interface WebGLGraphicsContextInfo {\r\n  transform: TransformStack;\r\n  state: StateStack;\r\n  ortho: Matrix;\r\n  context: ExcaliburGraphicsContextWebGL;\r\n}\r\n\r\nexport class ExcaliburGraphicsContextWebGL implements ExcaliburGraphicsContext {\r\n  private _logger = Logger.getInstance();\r\n  private _renderers: Map<string, RendererPlugin> = new Map<string, RendererPlugin>();\r\n  private _isDrawLifecycle = false;\r\n  public useDrawSorting = true;\r\n\r\n  private _drawCallPool = new Pool<DrawCall>(\r\n    () => new DrawCall(),\r\n    (instance) => {\r\n      instance.priority = 0;\r\n      instance.z = 0;\r\n      instance.renderer = undefined;\r\n      instance.args = undefined;\r\n      return instance;\r\n    }, 4000);\r\n  private _drawCalls: DrawCall[] = [];\r\n\r\n  // Main render target\r\n  private _renderTarget: RenderTarget;\r\n\r\n  // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process\r\n  private _postProcessTargets: RenderTarget[] = [];\r\n\r\n  private _screenRenderer: ScreenPassPainter;\r\n\r\n  private _postprocessors: PostProcessor[] = [];\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __gl: WebGL2RenderingContext;\r\n\r\n  private _transform = new TransformStack();\r\n  private _state = new StateStack();\r\n  private _ortho!: Matrix;\r\n\r\n  public snapToPixel: boolean = false;\r\n\r\n  public smoothing: boolean = false;\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  public get z(): number {\r\n    return this._state.current.z;\r\n  }\r\n\r\n  public set z(value: number) {\r\n    this._state.current.z = value;\r\n  }\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public get tint(): Color {\r\n    return this._state.current.tint;\r\n  }\r\n\r\n  public set tint(color: Color) {\r\n    this._state.current.tint = color;\r\n  }\r\n\r\n  public get width() {\r\n    return this.__gl.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__gl.canvas.height;\r\n  }\r\n\r\n  public get ortho(): Matrix {\r\n    return this._ortho;\r\n  }\r\n\r\n  /**\r\n   * Checks the underlying webgl implementation if the requested internal resolution is supported\r\n   * @param dim\r\n   */\r\n  public checkIfResolutionSupported(dim: ScreenDimension): boolean {\r\n    // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo\r\n    let supported = true;\r\n    if (dim.width > 4096 || dim.height > 4096) {\r\n      supported = false;\r\n    }\r\n    return supported;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor, useDrawSorting } = options;\r\n    this.__gl = canvasElement.getContext('webgl2', {\r\n      antialias: smoothing ?? this.smoothing,\r\n      premultipliedAlpha: false,\r\n      alpha: enableTransparency ?? true,\r\n      depth: true,\r\n      powerPreference: 'high-performance'\r\n      // TODO Chromium fixed the bug where this didn't work now it breaks CI :(\r\n      // failIfMajorPerformanceCaveat: true\r\n    });\r\n    if (!this.__gl) {\r\n      throw Error('Failed to retrieve webgl context from browser');\r\n    }\r\n    ExcaliburWebGLContextAccessor.register(this.__gl);\r\n    TextureLoader.register(this.__gl);\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this.useDrawSorting = useDrawSorting ?? this.useDrawSorting;\r\n    this._drawCallPool.disableWarnings = true;\r\n    this._drawCallPool.preallocate();\r\n    this._init();\r\n  }\r\n\r\n  private _init() {\r\n    const gl = this.__gl;\r\n    // Setup viewport and view matrix\r\n    this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n    // Clear background\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // Enable alpha blending\r\n    // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/\r\n    gl.enable(gl.BLEND);\r\n    gl.blendEquation(gl.FUNC_ADD);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\r\n    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n    // Setup builtin renderers\r\n    this.register(new ImageRenderer());\r\n    this.register(new RectangleRenderer());\r\n    this.register(new CircleRenderer());\r\n    this.register(new PointRenderer());\r\n    this.register(new LineRenderer());\r\n\r\n    this._screenRenderer = new ScreenPassPainter(gl);\r\n\r\n    this._renderTarget = new RenderTarget({\r\n      gl,\r\n      width: gl.canvas.width,\r\n      height: gl.canvas.height\r\n    });\r\n\r\n\r\n    this._postProcessTargets = [\r\n      new RenderTarget({\r\n        gl,\r\n        width: gl.canvas.width,\r\n        height: gl.canvas.height\r\n      }),\r\n      new RenderTarget({\r\n        gl,\r\n        width: gl.canvas.width,\r\n        height: gl.canvas.height\r\n      })\r\n    ];\r\n  }\r\n\r\n  public register<T extends RendererPlugin>(renderer: T) {\r\n    this._renderers.set(renderer.type, renderer);\r\n    renderer.initialize(this.__gl, this);\r\n  }\r\n\r\n  public get(rendererName: string): RendererPlugin {\r\n    return this._renderers.get(rendererName);\r\n  }\r\n\r\n  private _currentRenderer: RendererPlugin;\r\n\r\n  private _isCurrentRenderer(renderer: RendererPlugin): boolean {\r\n    if (!this._currentRenderer || this._currentRenderer === renderer) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public beginDrawLifecycle() {\r\n    this._isDrawLifecycle = true;\r\n  }\r\n\r\n  public endDrawLifecycle() {\r\n    this._isDrawLifecycle = false;\r\n  }\r\n\r\n  private _alreadyWarnedDrawLifecycle = false;\r\n\r\n  public draw<TRenderer extends RendererPlugin>(rendererName: TRenderer['type'], ...args: Parameters<TRenderer['draw']>) {\r\n    if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {\r\n      this._logger.warn(\r\n        `Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\\n` +\r\n        `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);\r\n      this._alreadyWarnedDrawLifecycle = true;\r\n    }\r\n\r\n    const renderer = this._renderers.get(rendererName);\r\n    if (renderer) {\r\n      if (this.useDrawSorting) {\r\n        const drawCall = this._drawCallPool.get();\r\n        drawCall.z = this._state.current.z;\r\n        drawCall.priority = renderer.priority;\r\n        drawCall.renderer = rendererName;\r\n        this.getTransform().clone(drawCall.transform);\r\n        drawCall.state.z = this._state.current.z;\r\n        drawCall.state.opacity = this._state.current.opacity;\r\n        drawCall.state.tint = this._state.current.tint;\r\n        drawCall.args = args;\r\n        this._drawCalls.push(drawCall);\r\n      } else {\r\n        // Set the current renderer if not defined\r\n        if (!this._currentRenderer) {\r\n          this._currentRenderer = renderer;\r\n        }\r\n\r\n        if (!this._isCurrentRenderer(renderer)) {\r\n          // switching graphics means we must flush the previous\r\n          this._currentRenderer.flush();\r\n        }\r\n\r\n        // If we are still using the same renderer we can add to the current batch\r\n        renderer.draw(...args);\r\n\r\n        this._currentRenderer = renderer;\r\n      }\r\n    } else {\r\n      throw Error(`No renderer with name ${rendererName} has been registered`);\r\n    }\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this._transform.current = AffineMatrix.identity();\r\n  }\r\n\r\n  public updateViewport(resolution: ScreenDimension): void {\r\n    const gl = this.__gl;\r\n    this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);\r\n\r\n    this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);\r\n    this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);\r\n    this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);\r\n  }\r\n\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    if (!image) {\r\n      Logger.getInstance().warn('Cannot draw a null or undefined image');\r\n      // tslint:disable-next-line: no-console\r\n      if (console.trace) {\r\n        // tslint:disable-next-line: no-console\r\n        console.trace();\r\n      }\r\n      return;\r\n    }\r\n    this.draw<ImageRenderer>('ex.image', image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.draw<RectangleRenderer>('ex.rectangle', start, end, color, thickness);\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color, stroke?: Color, strokeThickness?: number) {\r\n    this.draw<RectangleRenderer>('ex.rectangle', pos, width, height, color, stroke, strokeThickness);\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color, stroke?: Color, thickness?: number) {\r\n    this.draw<CircleRenderer>('ex.circle', pos, radius, color, stroke, thickness);\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContextWebGLDebug(this);\r\n\r\n  public save(): void {\r\n    this._transform.save();\r\n    this._state.save();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._transform.restore();\r\n    this._state.restore();\r\n  }\r\n\r\n  public translate(x: number, y: number): void {\r\n    this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);\r\n  }\r\n\r\n  public rotate(angle: number): void {\r\n    this._transform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): void {\r\n    this._transform.scale(x, y);\r\n  }\r\n\r\n  public transform(matrix: AffineMatrix) {\r\n    this._transform.current = matrix;\r\n  }\r\n\r\n  public getTransform(): AffineMatrix {\r\n    return this._transform.current;\r\n  }\r\n\r\n  public multiply(m: AffineMatrix) {\r\n    this._transform.current.multiply(m, this._transform.current);\r\n  }\r\n\r\n  public addPostProcessor(postprocessor: PostProcessor) {\r\n    this._postprocessors.push(postprocessor);\r\n    postprocessor.initialize(this.__gl);\r\n  }\r\n\r\n  public removePostProcessor(postprocessor: PostProcessor) {\r\n    const index = this._postprocessors.indexOf(postprocessor);\r\n    if (index !== -1) {\r\n      this._postprocessors.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  public clearPostProcessors() {\r\n    this._postprocessors.length = 0;\r\n  }\r\n\r\n  clear() {\r\n    const gl = this.__gl;\r\n    this._renderTarget.use();\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    // Clear the context with the newly set color. This is\r\n    // the function call that actually does the drawing.\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n  }\r\n\r\n  /**\r\n   * Flushes all batched rendering to the screen\r\n   */\r\n  flush() {\r\n    const gl = this.__gl;\r\n\r\n    // render target captures all draws and redirects to the render target\r\n    this._renderTarget.use();\r\n\r\n    if (this.useDrawSorting) {\r\n      // sort draw calls\r\n      // Find the original order of the first instance of the draw call\r\n      const originalSort = new Map<string, number>();\r\n      for (const [name] of this._renderers) {\r\n        const firstIndex = this._drawCalls.findIndex(dc => dc.renderer === name);\r\n        originalSort.set(name, firstIndex);\r\n      }\r\n\r\n      this._drawCalls.sort((a, b) => {\r\n        const zIndex = a.z - b.z;\r\n        const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);\r\n        const priority = a.priority - b.priority;\r\n        if (zIndex === 0) { // sort by z first\r\n          if (priority === 0) { // sort by priority\r\n            return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order\r\n          }\r\n          return priority;\r\n        }\r\n        return zIndex;\r\n      });\r\n\r\n      const oldTransform = this._transform.current;\r\n      const oldState = this._state.current;\r\n\r\n      if (this._drawCalls.length) {\r\n        let currentRendererName = this._drawCalls[0].renderer;\r\n        let currentRenderer = this._renderers.get(currentRendererName);\r\n        for (let i = 0; i < this._drawCalls.length; i++) {\r\n          // hydrate the state for renderers\r\n          this._transform.current = this._drawCalls[i].transform;\r\n          this._state.current = this._drawCalls[i].state;\r\n\r\n          if (this._drawCalls[i].renderer !== currentRendererName) {\r\n            // switching graphics renderer means we must flush the previous\r\n            currentRenderer.flush();\r\n            currentRendererName = this._drawCalls[i].renderer;\r\n            currentRenderer = this._renderers.get(currentRendererName);\r\n          }\r\n\r\n          // If we are still using the same renderer we can add to the current batch\r\n          currentRenderer.draw(...this._drawCalls[i].args);\r\n        }\r\n        if (currentRenderer.hasPendingDraws()) {\r\n          currentRenderer.flush();\r\n        }\r\n      }\r\n\r\n      // reset state\r\n      this._transform.current = oldTransform;\r\n      this._state.current = oldState;\r\n\r\n      // reclaim draw calls\r\n      this._drawCallPool.done();\r\n      this._drawCalls.length = 0;\r\n    } else {\r\n      // This is the final flush at the moment to draw any leftover pending draw\r\n      for (const renderer of this._renderers.values()) {\r\n        if (renderer.hasPendingDraws()) {\r\n          renderer.flush();\r\n        }\r\n      }\r\n    }\r\n\r\n    this._renderTarget.disable();\r\n\r\n    // post process step\r\n    const source = this._renderTarget.toRenderSource();\r\n    source.use();\r\n\r\n    // flip flop render targets\r\n    for (let i = 0; i < this._postprocessors.length; i++) {\r\n      this._postProcessTargets[i % 2].use();\r\n      this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);\r\n      this._postProcessTargets[i % 2].toRenderSource().use();\r\n    }\r\n\r\n    // passing null switches rendering back to the canvas\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    this._screenRenderer.renderToScreen();\r\n  }\r\n}\r\n","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { GraphicsDiagnostics } from '../GraphicsDiagnostics';\r\nimport { DebugText } from './debug-text';\r\nimport { ScreenDimension } from '../../Screen';\r\nimport { PostProcessor } from '../PostProcessor/PostProcessor';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nconst pixelSnapEpsilon = 0.0001;\r\n\r\nclass ExcaliburGraphicsContext2DCanvasDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _ex: ExcaliburGraphicsContext2DCanvas) {}\r\n  /**\r\n   * Draw a debug rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.strokeStyle = 'red';\r\n    this._ex.__ctx.strokeRect(\r\n      this._ex.snapToPixel ? ~~(x + pixelSnapEpsilon) : x,\r\n      this._ex.snapToPixel ? ~~(y + pixelSnapEpsilon) : y,\r\n      this._ex.snapToPixel ? ~~(width + pixelSnapEpsilon) : width,\r\n      this._ex.snapToPixel ? ~~(height + pixelSnapEpsilon) : height\r\n    );\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.strokeStyle = lineOptions.color.toString();\r\n    this._ex.__ctx.moveTo(\r\n      this._ex.snapToPixel ? ~~(start.x + pixelSnapEpsilon) : start.x,\r\n      this._ex.snapToPixel ? ~~(start.y + pixelSnapEpsilon) : start.y\r\n    );\r\n    this._ex.__ctx.lineTo(\r\n      this._ex.snapToPixel ? ~~(end.x + pixelSnapEpsilon) : end.x,\r\n      this._ex.snapToPixel ? ~~(end.y + pixelSnapEpsilon) : end.y\r\n    );\r\n    this._ex.__ctx.lineWidth = 2;\r\n    this._ex.__ctx.stroke();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.fillStyle = pointOptions.color.toString();\r\n    this._ex.__ctx.arc(\r\n      this._ex.snapToPixel ? ~~(point.x + pixelSnapEpsilon) : point.x,\r\n      this._ex.snapToPixel ? ~~(point.y + pixelSnapEpsilon) : point.y,\r\n      pointOptions.size,\r\n      0,\r\n      Math.PI * 2\r\n    );\r\n    this._ex.__ctx.fill();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._ex, text, pos);\r\n  }\r\n}\r\n\r\nexport class ExcaliburGraphicsContext2DCanvas implements ExcaliburGraphicsContext {\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __ctx: CanvasRenderingContext2D;\r\n  public get width() {\r\n    return this.__ctx.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__ctx.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Unused in Canvas implementation\r\n   */\r\n  public readonly useDrawSorting: boolean = false;\r\n\r\n  /**\r\n   * Unused in Canvas implementation\r\n   */\r\n  public z: number = 0;\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  private _state = new StateStack();\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public get tint(): Color {\r\n    return this._state.current.tint;\r\n  }\r\n\r\n  public set tint(color: Color) {\r\n    this._state.current.tint = color;\r\n  }\r\n\r\n  public snapToPixel: boolean = false;\r\n\r\n  public get smoothing(): boolean {\r\n    return this.__ctx.imageSmoothingEnabled;\r\n  }\r\n\r\n  public set smoothing(value: boolean) {\r\n    this.__ctx.imageSmoothingEnabled = value;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;\r\n    this.__ctx = canvasElement.getContext('2d', {\r\n      alpha: enableTransparency ?? true\r\n    });\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this.__ctx.resetTransform();\r\n  }\r\n\r\n  public updateViewport(_resolution: ScreenDimension): void {\r\n    // pass\r\n  }\r\n\r\n  /**\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate using the images width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate with a specific width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context specifying the source image coordinates (sx, sy, swidth, sheight)\r\n   * and to a specific destination on the context (dx, dy, dwidth, dheight)\r\n   */\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    this.__ctx.globalAlpha = this.opacity;\r\n    const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]\r\n      .filter((a) => a !== undefined)\r\n      .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));\r\n    this.__ctx.drawImage.apply(this.__ctx, args);\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n    GraphicsDiagnostics.DrawnImagesCount = 1;\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    this.__ctx.strokeStyle = color.toString();\r\n    this.__ctx.moveTo(\r\n      this.snapToPixel ? ~~ (start.x + pixelSnapEpsilon) : start.x,\r\n      this.snapToPixel ? ~~(start.y + pixelSnapEpsilon) : start.y\r\n    );\r\n    this.__ctx.lineTo(\r\n      this.snapToPixel ? ~~ (end.x + pixelSnapEpsilon) : end.x,\r\n      this.snapToPixel ? ~~(end.y + pixelSnapEpsilon) : end.y\r\n    );\r\n    this.__ctx.lineWidth = thickness;\r\n    this.__ctx.stroke();\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color) {\r\n    this.__ctx.save();\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.fillRect(\r\n      this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon) : pos.x,\r\n      this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon) : pos.y,\r\n      this.snapToPixel ? ~~(width + pixelSnapEpsilon) : width,\r\n      this.snapToPixel ? ~~(height + pixelSnapEpsilon) : height\r\n    );\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color, stroke?: Color, thickness?: number) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    if (stroke) {\r\n      this.__ctx.strokeStyle = stroke.toString();\r\n    }\r\n    if (thickness) {\r\n      this.__ctx.lineWidth = thickness;\r\n    }\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.arc(\r\n      this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon) : pos.x,\r\n      this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2\r\n    );\r\n    this.__ctx.fill();\r\n    if (stroke) {\r\n      this.__ctx.stroke();\r\n    }\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContext2DCanvasDebug(this);\r\n\r\n  /**\r\n   * Save the current state of the canvas to the stack (transforms and opacity)\r\n   */\r\n  save(): void {\r\n    this.__ctx.save();\r\n  }\r\n\r\n  /**\r\n   * Restore the state of the canvas from the stack\r\n   */\r\n  restore(): void {\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Translate the origin of the context by an x and y\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number): void {\r\n    this.__ctx.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);\r\n  }\r\n\r\n  /**\r\n   * Rotate the context about the current origin\r\n   */\r\n  rotate(angle: number): void {\r\n    this.__ctx.rotate(angle);\r\n  }\r\n\r\n  /**\r\n   * Scale the context by an x and y factor\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number): void {\r\n    this.__ctx.scale(x, y);\r\n  }\r\n\r\n  public getTransform(): AffineMatrix {\r\n    throw new Error('Not implemented');\r\n  }\r\n\r\n  public multiply(_m: AffineMatrix): void {\r\n    this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));\r\n  }\r\n\r\n  public addPostProcessor(_postprocessor: PostProcessor) {\r\n    // pass\r\n  }\r\n\r\n  public removePostProcessor(_postprocessor: PostProcessor) {\r\n    // pass\r\n  }\r\n\r\n  public clearPostProcessors() {\r\n    // pass\r\n  }\r\n\r\n  public beginDrawLifecycle() {\r\n    // pass\r\n  }\r\n\r\n  public endDrawLifecycle() {\r\n    // pass\r\n  }\r\n\r\n  clear(): void {\r\n    // Clear frame\r\n    this.__ctx.clearRect(0, 0, this.width, this.height);\r\n    this.__ctx.fillStyle = this.backgroundColor.toString();\r\n    this.__ctx.fillRect(0, 0, this.width, this.height);\r\n    GraphicsDiagnostics.clear();\r\n  }\r\n\r\n  /**\r\n   * Flushes the batched draw calls to the screen\r\n   */\r\n  flush(): void {\r\n    // pass\r\n  }\r\n}\r\n","import { vec, Vector } from './Math/vector';\r\nimport { Logger } from './Util/Log';\r\nimport { Camera } from './Camera';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { BoundingBox } from './Collision/Index';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { getPosition } from './Util/Util';\r\nimport { ExcaliburGraphicsContextWebGL } from './Graphics/Context/ExcaliburGraphicsContextWebGL';\r\nimport { ExcaliburGraphicsContext2DCanvas } from './Graphics/Context/ExcaliburGraphicsContext2DCanvas';\r\n\r\n/**\r\n * Enum representing the different display modes available to Excalibur.\r\n */\r\nexport enum DisplayMode {\r\n  /**\r\n   * Default, use a specified resolution for the game. Like 800x600 pixels for example.\r\n   */\r\n  Fixed = 'Fixed',\r\n\r\n  /**\r\n   * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.\r\n   * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n   * is guaranteed to be on screen.\r\n   */\r\n  FitContainerAndFill = 'FitContainerAndFill',\r\n\r\n  /**\r\n   * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.\r\n   * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n   * is guaranteed to be on screen.\r\n   */\r\n  FitScreenAndFill = 'FitScreenAndFill',\r\n\r\n  /**\r\n   * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n   * (letterbox) that would otherwise be present in [[FitContainer]].\r\n   *\r\n   * **warning** This will clip some drawable area from the user because of the zoom,\r\n   * use [[Screen.contentArea]] to know the safe to draw area.\r\n   */\r\n  FitContainerAndZoom = 'FitContainerAndZoom',\r\n\r\n  /**\r\n   * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n   * (letterbox) that would otherwise be present in [[FitScreen]].\r\n   *\r\n   * **warning** This will clip some drawable area from the user because of the zoom,\r\n   * use [[Screen.contentArea]] to know the safe to draw area.\r\n   */\r\n  FitScreenAndZoom = 'FitScreenAndZoom',\r\n\r\n  /**\r\n   * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.\r\n   * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.\r\n   *\r\n   * You may want to center your game here is an example\r\n   * ```html\r\n   * <!-- html -->\r\n   * <body>\r\n   * <main>\r\n   *   <canvas id=\"game\"></canvas>\r\n   * </main>\r\n   * </body>\r\n   * ```\r\n   *\r\n   * ```css\r\n   * // css\r\n   * main {\r\n   *   display: flex;\r\n   *   align-items: center;\r\n   *   justify-content: center;\r\n   *   height: 100%;\r\n   *   width: 100%;\r\n   * }\r\n   * ```\r\n   */\r\n  FitScreen = 'FitScreen',\r\n\r\n  /**\r\n   * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will\r\n   * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]\r\n   */\r\n  FillScreen = 'FillScreen',\r\n\r\n  /**\r\n   * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.\r\n   */\r\n  FitContainer = 'FitContainer',\r\n\r\n  /**\r\n   * Use the parent DOM container's css width/height for the game resolution dynamically\r\n   */\r\n  FillContainer = 'FillContainer'\r\n}\r\n\r\n/**\r\n * Convenience class for quick resolutions\r\n * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution\r\n */\r\nexport class Resolution {\r\n  /* istanbul ignore next */\r\n  public static get SVGA(): ScreenDimension {\r\n    return { width: 800, height: 600 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Standard(): ScreenDimension {\r\n    return { width: 1920, height: 1080 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Atari2600(): ScreenDimension {\r\n    return { width: 160, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoy(): ScreenDimension {\r\n    return { width: 160, height: 144 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoyAdvance(): ScreenDimension {\r\n    return { width: 240, height: 160 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NintendoDS(): ScreenDimension {\r\n    return { width: 256, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NES(): ScreenDimension {\r\n    return { width: 256, height: 224 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get SNES(): ScreenDimension {\r\n    return { width: 256, height: 244 };\r\n  }\r\n}\r\n\r\nexport interface ScreenDimension {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface ScreenOptions {\r\n  /**\r\n   * Canvas element to build a screen on\r\n   */\r\n  canvas: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Graphics context for the screen\r\n   */\r\n  context: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Browser abstraction\r\n   */\r\n  browser: BrowserEvents;\r\n  /**\r\n   * Optionally set antialiasing, defaults to true. If set to true, images will be smoothed\r\n   */\r\n  antialiasing?: boolean;\r\n  /**\r\n   * Optionally override the pixel ratio to use for the screen, otherwise calculated automatically from the browser\r\n   */\r\n  pixelRatio?: number;\r\n  /**\r\n   * Optionally specify the actual pixel resolution in width/height pixels (also known as logical resolution), by default the\r\n   * resolution will be the same as the viewport. Resolution will be overridden by [[DisplayMode.FillContainer]] and\r\n   * [[DisplayMode.FillScreen]].\r\n   */\r\n  resolution?: ScreenDimension;\r\n  /**\r\n   * Visual viewport size in css pixel, if resolution is not specified it will be the same as the viewport\r\n   */\r\n  viewport: ScreenDimension;\r\n  /**\r\n   * Set the display mode of the screen, by default DisplayMode.Fixed.\r\n   */\r\n  displayMode?: DisplayMode;\r\n}\r\n\r\n/**\r\n * The Screen handles all aspects of interacting with the screen for Excalibur.\r\n */\r\nexport class Screen {\r\n  public graphicsContext: ExcaliburGraphicsContext;\r\n  private _canvas: HTMLCanvasElement;\r\n  private _antialiasing: boolean = true;\r\n  private _contentResolution: ScreenDimension;\r\n  private _browser: BrowserEvents;\r\n  private _camera: Camera;\r\n  private _resolution: ScreenDimension;\r\n  private _resolutionStack: ScreenDimension[] = [];\r\n  private _viewport: ScreenDimension;\r\n  private _viewportStack: ScreenDimension[] = [];\r\n  private _pixelRatioOverride: number | null = null;\r\n  private _displayMode: DisplayMode;\r\n  private _isFullScreen = false;\r\n  private _mediaQueryList: MediaQueryList;\r\n  private _isDisposed = false;\r\n  private _logger = Logger.getInstance();\r\n  private _resizeObserver: ResizeObserver;\r\n\r\n  constructor(options: ScreenOptions) {\r\n    this.viewport = options.viewport;\r\n    this.resolution = options.resolution ?? { ...this.viewport };\r\n    this._contentResolution = this.resolution;\r\n    this._displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    this._canvas = options.canvas;\r\n    this.graphicsContext = options.context;\r\n    this._antialiasing = options.antialiasing ?? this._antialiasing;\r\n    this._browser = options.browser;\r\n    this._pixelRatioOverride = options.pixelRatio;\r\n\r\n    this._applyDisplayMode();\r\n\r\n    this._listenForPixelRatio();\r\n\r\n    this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    this.applyResolutionAndViewport();\r\n  }\r\n\r\n  private _listenForPixelRatio() {\r\n    if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {\r\n      // Safari <=13.1 workaround, remove any existing handlers\r\n      this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n    }\r\n    this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\r\n\r\n    // Safari <=13.1 workaround\r\n    if (this._mediaQueryList.addEventListener) {\r\n      this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler, { once: true });\r\n    } else {\r\n      this._mediaQueryList.addListener(this._pixelRatioChangeHandler);\r\n    }\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (!this._isDisposed) {\r\n      // Clean up handlers\r\n      this._isDisposed = true;\r\n      this._browser.window.off('resize', this._resizeHandler);\r\n      if (this._resizeObserver) {\r\n        this._resizeObserver.disconnect();\r\n      }\r\n      this.parent.removeEventListener('resize', this._resizeHandler);\r\n      // Safari <=13.1 workaround\r\n      if (this._mediaQueryList.removeEventListener) {\r\n        this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);\r\n      } else {\r\n        this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n      }\r\n      this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    }\r\n  }\r\n\r\n  private _fullscreenChangeHandler = () => {\r\n    this._isFullScreen = !this._isFullScreen;\r\n    this._logger.debug('Fullscreen Change', this._isFullScreen);\r\n  };\r\n\r\n  private _pixelRatioChangeHandler = () => {\r\n    this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);\r\n    this._listenForPixelRatio();\r\n    this._devicePixelRatio = this._calculateDevicePixelRatio();\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _resizeHandler = () => {\r\n    const parent = this.parent;\r\n    this._logger.debug('View port resized');\r\n    this._setResolutionAndViewportByDisplayMode(parent);\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _calculateDevicePixelRatio() {\r\n    if (window.devicePixelRatio < 1) {\r\n      return 1;\r\n    }\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n\r\n    return devicePixelRatio;\r\n  }\r\n\r\n  // Asking the window.devicePixelRatio is expensive we do it once\r\n  private _devicePixelRatio = this._calculateDevicePixelRatio();\r\n\r\n  public get pixelRatio(): number {\r\n    if (this._pixelRatioOverride) {\r\n      return this._pixelRatioOverride;\r\n    }\r\n\r\n    return this._devicePixelRatio;\r\n  }\r\n\r\n  public get isHiDpi() {\r\n    return this.pixelRatio !== 1;\r\n  }\r\n\r\n  public get displayMode(): DisplayMode {\r\n    return this._displayMode;\r\n  }\r\n\r\n  public get canvas(): HTMLCanvasElement {\r\n    return this._canvas;\r\n  }\r\n\r\n  public get parent(): HTMLElement | Window {\r\n    switch (this.displayMode) {\r\n      case DisplayMode.FillContainer:\r\n      case DisplayMode.FitContainer:\r\n      case DisplayMode.FitContainerAndFill:\r\n      case DisplayMode.FitContainerAndZoom:\r\n        return this.canvas.parentElement || document.body;\r\n      default:\r\n        return window;\r\n    }\r\n  }\r\n\r\n  public get resolution(): ScreenDimension {\r\n    return this._resolution;\r\n  }\r\n\r\n  public set resolution(resolution: ScreenDimension) {\r\n    this._resolution = resolution;\r\n  }\r\n\r\n  public get viewport(): ScreenDimension {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n    return this._resolution;\r\n  }\r\n\r\n  public set viewport(viewport: ScreenDimension) {\r\n    this._viewport = viewport;\r\n  }\r\n\r\n  public get aspectRatio() {\r\n    return this._resolution.width / this._resolution.height;\r\n  }\r\n\r\n  public get scaledWidth() {\r\n    return this._resolution.width * this.pixelRatio;\r\n  }\r\n\r\n  public get scaledHeight() {\r\n    return this._resolution.height * this.pixelRatio;\r\n  }\r\n\r\n  public setCurrentCamera(camera: Camera) {\r\n    this._camera = camera;\r\n  }\r\n\r\n  public pushResolutionAndViewport() {\r\n    this._resolutionStack.push(this.resolution);\r\n    this._viewportStack.push(this.viewport);\r\n\r\n    this.resolution = { ...this.resolution };\r\n    this.viewport = { ...this.viewport };\r\n  }\r\n\r\n  public peekViewport(): ScreenDimension {\r\n    return this._viewportStack[this._viewportStack.length - 1];\r\n  }\r\n\r\n  public peekResolution(): ScreenDimension {\r\n    return this._resolutionStack[this._resolutionStack.length - 1];\r\n  }\r\n\r\n  public popResolutionAndViewport() {\r\n    this.resolution = this._resolutionStack.pop();\r\n    this.viewport = this._viewportStack.pop();\r\n  }\r\n\r\n  private _alreadyWarned = false;\r\n  public applyResolutionAndViewport() {\r\n    this._canvas.width = this.scaledWidth;\r\n    this._canvas.height = this.scaledHeight;\r\n\r\n    if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      const supported = this.graphicsContext.checkIfResolutionSupported({\r\n        width: this.scaledWidth,\r\n        height: this.scaledHeight\r\n      });\r\n      if (!supported && !this._alreadyWarned) {\r\n        this._alreadyWarned = true; // warn once\r\n        this._logger.warn(\r\n          `The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` +\r\n          ' are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +\r\n          ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +\r\n          ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');\r\n      }\r\n    }\r\n\r\n    if (this._antialiasing) {\r\n      this._canvas.style.imageRendering = 'auto';\r\n    } else {\r\n      this._canvas.style.imageRendering = 'pixelated';\r\n      // Fall back to 'crisp-edges' if 'pixelated' is not supported\r\n      // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering\r\n      if (this._canvas.style.imageRendering === '') {\r\n        this._canvas.style.imageRendering = 'crisp-edges';\r\n      }\r\n    }\r\n    this._canvas.style.width = this.viewport.width + 'px';\r\n    this._canvas.style.height = this.viewport.height + 'px';\r\n\r\n    // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset\r\n    this.graphicsContext.updateViewport(this.resolution);\r\n    this.graphicsContext.resetTransform();\r\n    this.graphicsContext.smoothing = this._antialiasing;\r\n    if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {\r\n      this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);\r\n    }\r\n  }\r\n\r\n  public get antialiasing() {\r\n    return this._antialiasing;\r\n  }\r\n\r\n  public set antialiasing(isSmooth: boolean) {\r\n    this._antialiasing = isSmooth;\r\n    this.graphicsContext.smoothing = this._antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Returns true if excalibur is fullscreen using the browser fullscreen api\r\n   */\r\n  public get isFullScreen() {\r\n    return this._isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.\r\n   * For example, wire this to a user click handler.\r\n   *\r\n   * Optionally specify a target element id to go fullscreen, by default the game canvas is used\r\n   * @param elementId\r\n   */\r\n  public goFullScreen(elementId?: string): Promise<void> {\r\n    if (elementId) {\r\n      const maybeElement = document.getElementById(elementId);\r\n      if (maybeElement) {\r\n        return maybeElement.requestFullscreen();\r\n      }\r\n    }\r\n    return this._canvas.requestFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Requests to exit fullscreen using the browser fullscreen api\r\n   */\r\n  public exitFullScreen(): Promise<void> {\r\n    return document.exitFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to\r\n   * Excalibur screen space.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public pageToScreenCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    if (!this._isFullScreen) {\r\n      newX -= getPosition(this._canvas).x;\r\n      newY -= getPosition(this._canvas).y;\r\n    }\r\n\r\n    // if fullscreen api on it centers with black bars\r\n    // we need to adjust the screen to world coordinates in this case\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;\r\n        newX = (newX / window.innerWidth) * this.viewport.width;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;\r\n        newY = (newY / window.innerHeight) * this.viewport.height;\r\n      }\r\n    }\r\n\r\n    newX = (newX / this.viewport.width) * this.resolution.width;\r\n    newY = (newY / this.viewport.height) * this.resolution.height;\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,\r\n   * this is where html elements might live if you want to position them relative to Excalibur.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public screenToPageCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    newX = (newX / this.resolution.width) * this.viewport.width;\r\n    newY = (newY / this.resolution.height) * this.viewport.height;\r\n\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = (newY / this.viewport.height) * screenHeight + screenMarginY;\r\n        newX = (newX / this.viewport.width) * window.innerWidth;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = (newX / this.viewport.width) * screenWidth + screenMarginX;\r\n        newY = (newY / this.viewport.height) * window.innerHeight;\r\n      }\r\n    }\r\n\r\n    if (!this._isFullScreen) {\r\n      newX += getPosition(this._canvas).x;\r\n      newY += getPosition(this._canvas).y;\r\n    }\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.\r\n   *\r\n   * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]\r\n   * and extends infinitely out relative from the [[Camera]].\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    // the only difference between screen & world is the camera transform\r\n    if (this._camera) {\r\n      return this._camera.inverse.multiply(point);\r\n    }\r\n    return point.sub(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.\r\n   *\r\n   * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    if (this._camera) {\r\n      return this._camera.transform.multiply(point);\r\n    }\r\n    return point.add(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n  }\r\n\r\n  public pageToWorldCoordinates(point: Vector): Vector {\r\n    const screen = this.pageToScreenCoordinates(point);\r\n    return this.screenToWorldCoordinates(screen);\r\n  }\r\n\r\n  public worldToPageCoordinates(point: Vector): Vector {\r\n    const screen = this.worldToScreenCoordinates(point);\r\n    return this.screenToPageCoordinates(screen);\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   *\r\n   * World bounds are in world coordinates, useful for culling objects offscreen\r\n   */\r\n  public getWorldBounds(): BoundingBox {\r\n    const topLeft = this.screenToWorldCoordinates(Vector.Zero);\r\n    const right = topLeft.x + this.drawWidth;\r\n    const bottom = topLeft.y + this.drawHeight;\r\n\r\n    return new BoundingBox(topLeft.x, topLeft.y, right, bottom);\r\n  }\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.canvas.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.canvas.width / 2;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.canvas.height / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    if (this._camera) {\r\n      return this.resolution.width / this._camera.zoom;\r\n    }\r\n    return this.resolution.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.drawWidth / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    if (this._camera) {\r\n      return this.resolution.height / this._camera.zoom;\r\n    }\r\n    return this.resolution.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.drawHeight / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns screen center coordinates including zoom and device pixel ratio.\r\n   */\r\n  public get center(): Vector {\r\n    return vec(this.halfDrawWidth, this.halfDrawHeight);\r\n  }\r\n\r\n  /**\r\n   * Returns the content area in screen space where it is safe to place content\r\n   */\r\n  public get contentArea(): BoundingBox {\r\n    return this._contentArea;\r\n  }\r\n\r\n  private _computeFit() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    if (window.innerWidth / aspect < window.innerHeight) {\r\n      adjustedWidth = window.innerWidth;\r\n      adjustedHeight = window.innerWidth / aspect;\r\n    } else {\r\n      adjustedWidth = window.innerHeight * aspect;\r\n      adjustedHeight = window.innerHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n  }\r\n\r\n  private _contentArea: BoundingBox = new BoundingBox();\r\n  private _computeFitScreenAndFill() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const vw = window.innerWidth;\r\n    const vh = window.innerHeight;\r\n    this._computeFitAndFill(vw, vh);\r\n  }\r\n\r\n\r\n\r\n  private _computeFitContainerAndFill() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const parent = this.canvas.parentElement;\r\n    const vw = parent.clientWidth;\r\n    const vh = parent.clientHeight;\r\n    this._computeFitAndFill(vw, vh);\r\n  }\r\n\r\n  private _computeFitAndFill(vw: number, vh: number) {\r\n    this.viewport = {\r\n      width: vw,\r\n      height: vh\r\n    };\r\n    // if the current screen aspectRatio is less than the original aspectRatio\r\n    if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {\r\n      // compute new resolution to match the original aspect ratio\r\n      this.resolution = {\r\n        width:  vw * this._contentResolution.width / vw,\r\n        height: vw * this._contentResolution.width / vw * vh / vw\r\n      };\r\n      const clip = (this.resolution.height - this._contentResolution.height) / 2;\r\n      this._contentArea = new BoundingBox({\r\n        top: clip,\r\n        left: 0,\r\n        right: this._contentResolution.width,\r\n        bottom: this.resolution.height - clip\r\n      });\r\n    } else {\r\n      this.resolution = {\r\n        width: vh *  this._contentResolution.height / vh * vw / vh,\r\n        height: vh *  this._contentResolution.height / vh\r\n      };\r\n      const clip = (this.resolution.width - this._contentResolution.width) / 2;\r\n      this._contentArea = new BoundingBox({\r\n        top: 0,\r\n        left: clip,\r\n        right: this.resolution.width - clip,\r\n        bottom: this._contentResolution.height\r\n      });\r\n    }\r\n  }\r\n\r\n  private _computeFitScreenAndZoom() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    this.canvas.style.position = 'absolute';\r\n\r\n    const vw = window.innerWidth;\r\n    const vh = window.innerHeight;\r\n\r\n    this._computeFitAndZoom(vw, vh);\r\n  }\r\n\r\n  private _computeFitContainerAndZoom() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    this.canvas.style.position = 'absolute';\r\n    const parent = this.canvas.parentElement;\r\n    parent.style.position = 'relative';\r\n    parent.style.overflow = 'hidden';\r\n\r\n    const vw = parent.clientWidth;\r\n    const vh = parent.clientHeight;\r\n\r\n    this._computeFitAndZoom(vw, vh);\r\n  }\r\n\r\n  private _computeFitAndZoom(vw: number, vh: number) {\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    if (vw / aspect < vh) {\r\n      adjustedWidth = vw;\r\n      adjustedHeight = vw / aspect;\r\n    } else {\r\n      adjustedWidth = vh * aspect;\r\n      adjustedHeight = vh;\r\n    }\r\n\r\n    const scaleX = vw / adjustedWidth;\r\n    const scaleY = vh / adjustedHeight;\r\n\r\n    const maxScaleFactor = Math.max(scaleX, scaleY);\r\n\r\n    const zoomedWidth = adjustedWidth * maxScaleFactor;\r\n    const zoomedHeight = adjustedHeight * maxScaleFactor;\r\n\r\n    // Center zoomed dimension if bigger than the screen\r\n    if (zoomedWidth > vw) {\r\n      this.canvas.style.left = -(zoomedWidth - vw) / 2 + 'px';\r\n    } else {\r\n      this.canvas.style.left = '';\r\n    }\r\n\r\n    if (zoomedHeight > vh) {\r\n      this.canvas.style.top = -(zoomedHeight - vh) / 2 + 'px';\r\n    } else {\r\n      this.canvas.style.top = '';\r\n    }\r\n\r\n    this.viewport = {\r\n      width: zoomedWidth,\r\n      height: zoomedHeight\r\n    };\r\n\r\n    const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);\r\n    // return safe area\r\n    if (this.viewport.width > vw) {\r\n      const clip = (this.viewport.width - vw)/this.viewport.width * this.resolution.width;\r\n      bounds.top = 0;\r\n      bounds.left = clip / 2;\r\n      bounds.right = this.resolution.width - clip / 2;\r\n      bounds.bottom = this.resolution.height;\r\n    }\r\n\r\n    if (this.viewport.height > vh) {\r\n      const clip = (this.viewport.height - vh)/this.viewport.height * this.resolution.height;\r\n      bounds.top = clip / 2;\r\n      bounds.left = 0;\r\n      bounds.bottom = this.resolution.height - clip / 2;\r\n      bounds.right = this.resolution.width;\r\n    }\r\n    this._contentArea = bounds;\r\n  }\r\n\r\n  private _computeFitContainer() {\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    const parent = this.canvas.parentElement;\r\n    if (parent.clientWidth / aspect < parent.clientHeight) {\r\n      adjustedWidth = parent.clientWidth;\r\n      adjustedHeight = parent.clientWidth / aspect;\r\n    } else {\r\n      adjustedWidth = parent.clientHeight * aspect;\r\n      adjustedHeight = parent.clientHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n  }\r\n\r\n  private _applyDisplayMode() {\r\n    this._setResolutionAndViewportByDisplayMode(this.parent);\r\n\r\n    // watch resizing\r\n    if (this.parent instanceof Window) {\r\n      this._browser.window.on('resize', this._resizeHandler);\r\n    } else {\r\n      this._resizeObserver = new ResizeObserver(() => {\r\n        this._resizeHandler();\r\n      });\r\n      this._resizeObserver.observe(this.parent);\r\n    }\r\n    this.parent.addEventListener('resize', this._resizeHandler);\r\n  }\r\n\r\n  /**\r\n   * Sets the resolution and viewport based on the selected display mode.\r\n   */\r\n  private _setResolutionAndViewportByDisplayMode(parent: HTMLElement | Window) {\r\n    if (this.displayMode === DisplayMode.FillContainer) {\r\n      this.resolution = {\r\n        width: (<HTMLElement> parent).clientWidth,\r\n        height: (<HTMLElement> parent).clientHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FillScreen) {\r\n      document.body.style.margin = '0px';\r\n      document.body.style.overflow = 'hidden';\r\n      this.resolution = {\r\n        width: (<Window> parent).innerWidth,\r\n        height: (<Window> parent).innerHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreen) {\r\n      this._computeFit();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainer) {\r\n      this._computeFitContainer();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreenAndFill) {\r\n      this._computeFitScreenAndFill();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainerAndFill){\r\n      this._computeFitContainerAndFill();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreenAndZoom) {\r\n      this._computeFitScreenAndZoom();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainerAndZoom){\r\n      this._computeFitContainerAndZoom();\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Internal class used to build instances of AudioContext\r\n */\r\n/* istanbul ignore next */\r\nexport class AudioContextFactory {\r\n  private static _INSTANCE: AudioContext = null;\r\n\r\n  public static create(): AudioContext {\r\n    if (!this._INSTANCE) {\r\n      if ((<any>window).AudioContext || (<any>window).webkitAudioContext) {\r\n        this._INSTANCE = new AudioContext();\r\n      }\r\n    }\r\n\r\n    return this._INSTANCE;\r\n  }\r\n}\r\n","import { AudioContextFactory } from '../Resources/Sound/AudioContext';\r\nimport { Logger } from './Log';\r\n\r\nexport interface LegacyWebAudioSource {\r\n  playbackState: string;\r\n  PLAYING_STATE: 'playing';\r\n  FINISHED_STATE: 'finished';\r\n}\r\n\r\n/**\r\n * Patch for detecting legacy web audio in browsers\r\n * @internal\r\n * @param source\r\n */\r\nfunction isLegacyWebAudioSource(source: any): source is LegacyWebAudioSource {\r\n  return !!source.playbackState;\r\n}\r\n\r\nexport class WebAudio {\r\n  private static _UNLOCKED: boolean = false;\r\n\r\n  /**\r\n   * Play an empty sound to unlock Safari WebAudio context. Call this function\r\n   * right after a user interaction event.\r\n   * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n   */\r\n  static unlock(): Promise<boolean> {\r\n    const promise = new Promise<boolean>((resolve, reject) => {\r\n      if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {\r\n        return resolve(true);\r\n      }\r\n      const unlockTimeoutTimer = setTimeout(() => {\r\n        Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');\r\n        resolve(false);\r\n      }, 200);\r\n\r\n      const audioContext = AudioContextFactory.create();\r\n      audioContext.resume().then(\r\n        () => {\r\n          // create empty buffer and play it\r\n          const buffer = audioContext.createBuffer(1, 1, 22050);\r\n          const source = audioContext.createBufferSource();\r\n          let ended = false;\r\n\r\n          source.buffer = buffer;\r\n          source.connect(audioContext.destination);\r\n          source.onended = () => (ended = true);\r\n\r\n          source.start(0);\r\n\r\n          // by checking the play state after some time, we know if we're really unlocked\r\n          setTimeout(() => {\r\n            if (isLegacyWebAudioSource(source)) {\r\n              if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            } else {\r\n              if (audioContext.currentTime > 0 || ended) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            }\r\n          }, 0);\r\n\r\n          clearTimeout(unlockTimeoutTimer);\r\n          resolve(true);\r\n        },\r\n        () => {\r\n          reject();\r\n        }\r\n      );\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  static isUnlocked() {\r\n    return this._UNLOCKED;\r\n  }\r\n}\r\n","import { EventDispatcher } from './EventDispatcher';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\n/**\r\n * Excalibur base class that provides basic functionality such as [[EventDispatcher]]\r\n * and extending abilities for vanilla Javascript projects\r\n */\r\nexport class Class implements Eventable {\r\n  /**\r\n   * Direct access to the game object event dispatcher.\r\n   */\r\n  public eventDispatcher: EventDispatcher;\r\n\r\n  constructor() {\r\n    this.eventDispatcher = new EventDispatcher();\r\n  }\r\n\r\n  /**\r\n   * Alias for `addEventListener`. You can listen for a variety of\r\n   * events off of the engine; see the events section below for a complete list.\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public on(eventName: string, handler: (event: any) => void) {\r\n    this.eventDispatcher.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Alias for `removeEventListener`. If only the eventName is specified\r\n   * it will remove all handlers registered for that specific event. If the eventName\r\n   * and the handler instance are specified only that handler will be removed.\r\n   *\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public off(eventName: string, handler?: (event: any) => void) {\r\n    this.eventDispatcher.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Emits a new event\r\n   * @param eventName   Name of the event to emit\r\n   * @param eventObject Data associated with this event\r\n   */\r\n  public emit(eventName: string, eventObject: any) {\r\n    this.eventDispatcher.emit(eventName, eventObject);\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: any) => void) {\r\n    this.eventDispatcher.once(eventName, handler);\r\n  }\r\n}\r\n","import { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\n\r\n/**\r\n * A canvas linecap style. \"butt\" is the default flush style, \"round\" is a semi-circle cap with a radius half the width of\r\n * the line, and \"square\" is a rectangle that is an equal width and half height cap.\r\n */\r\nexport type LineCapStyle = 'butt' | 'round' | 'square';\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Draw a line on canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param color The color of the line\r\n * @param x1 The start x coordinate\r\n * @param y1 The start y coordinate\r\n * @param x2 The ending x coordinate\r\n * @param y2 The ending y coordinate\r\n * @param thickness The line thickness\r\n * @param cap The [[LineCapStyle]] (butt, round, or square)\r\n */\r\nexport function line(\r\n  ctx: CanvasRenderingContext2D,\r\n  color: Color = Color.Red,\r\n  x1: number,\r\n  y1: number,\r\n  x2: number,\r\n  y2: number,\r\n  thickness: number = 1,\r\n  cap: LineCapStyle = 'butt'\r\n) {\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  ctx.lineWidth = thickness;\r\n  ctx.lineCap = cap;\r\n  ctx.strokeStyle = color.toString();\r\n  ctx.moveTo(x1, y1);\r\n  ctx.lineTo(x2, y2);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Draw the vector as a point onto the canvas.\r\n */\r\nexport function point(ctx: CanvasRenderingContext2D, color: Color = Color.Red, point: Vector): void {\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = color.toString();\r\n  ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n}\r\n\r\n/**\r\n * Draw the vector as a line onto the canvas starting a origin point.\r\n */\r\n/* istanbul ignore next */\r\n/**\r\n *\r\n */\r\nexport function vector(ctx: CanvasRenderingContext2D, color: Color, origin: Vector, vector: Vector, scale: number = 1.0): void {\r\n  const c = color ? color.toString() : 'blue';\r\n  const v = vector.scale(scale);\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = c;\r\n  ctx.moveTo(origin.x, origin.y);\r\n  ctx.lineTo(origin.x + v.x, origin.y + v.y);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n}\r\n\r\n/**\r\n * Represents border radius values\r\n */\r\nexport interface BorderRadius {\r\n  /**\r\n   * Top-left\r\n   */\r\n  tl: number;\r\n  /**\r\n   * Top-right\r\n   */\r\n  tr: number;\r\n  /**\r\n   * Bottom-right\r\n   */\r\n  br: number;\r\n  /**\r\n   * Bottom-left\r\n   */\r\n  bl: number;\r\n}\r\n\r\n/**\r\n * Draw a round rectangle on a canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param x The top-left x coordinate\r\n * @param y The top-left y coordinate\r\n * @param width The width of the rectangle\r\n * @param height The height of the rectangle\r\n * @param radius The border radius of the rectangle\r\n * @param stroke The [[Color]] to stroke rectangle with\r\n * @param fill The [[Color]] to fill rectangle with\r\n */\r\nexport function roundRect(\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n  radius: number | BorderRadius = 5,\r\n  stroke: Color = Color.White,\r\n  fill: Color = null\r\n) {\r\n  let br: BorderRadius;\r\n\r\n  if (typeof radius === 'number') {\r\n    br = { tl: radius, tr: radius, br: radius, bl: radius };\r\n  } else {\r\n    const defaultRadius: BorderRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n\r\n    for (const prop in defaultRadius) {\r\n      if (defaultRadius.hasOwnProperty(prop)) {\r\n        const side = <keyof BorderRadius>prop;\r\n        br[side] = radius[side] || defaultRadius[side];\r\n      }\r\n    }\r\n  }\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(x + br.tl, y);\r\n  ctx.lineTo(x + width - br.tr, y);\r\n  ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);\r\n  ctx.lineTo(x + width, y + height - br.br);\r\n  ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);\r\n  ctx.lineTo(x + br.bl, y + height);\r\n  ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);\r\n  ctx.lineTo(x, y + br.tl);\r\n  ctx.quadraticCurveTo(x, y, x + br.tl, y);\r\n  ctx.closePath();\r\n\r\n  if (fill) {\r\n    ctx.fillStyle = fill.toString();\r\n    ctx.fill();\r\n  }\r\n\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke.toString();\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function circle(\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  radius: number,\r\n  stroke: Color = Color.White,\r\n  fill: Color = null\r\n) {\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\r\n  ctx.closePath();\r\n\r\n  if (fill) {\r\n    ctx.fillStyle = fill.toString();\r\n    ctx.fill();\r\n  }\r\n\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke.toString();\r\n    ctx.stroke();\r\n  }\r\n}\r\n","export default \"data:image/png;base64,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\"","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { watch } from '../Util/Watch';\r\nimport { TextureLoader } from './Context/texture-loader';\r\nimport { ImageFiltering } from './Filtering';\r\n\r\n\r\nexport interface RasterOptions {\r\n  /**\r\n   * Optionally specify a quality number, which is how much to scale the internal Raster. Default is 1.\r\n   *\r\n   * For example if the quality is set to 2, it doubles the internal raster bitmap in memory.\r\n   *\r\n   * Adjusting this value can be useful if you are working with small rasters.\r\n   */\r\n  quality?: number;\r\n  /**\r\n   * Optionally specify \"smoothing\" if you want antialiasing to apply to the raster's bitmap context, by default `false`\r\n   */\r\n  smoothing?: boolean;\r\n\r\n  /**\r\n   * Optionally specify the color of the raster's bitmap context, by default [[Color.Black]]\r\n   */\r\n  color?: Color;\r\n\r\n  /**\r\n   * Optionally specify the stroke color of the raster's bitmap context, by default undefined\r\n   */\r\n  strokeColor?: Color;\r\n\r\n  /**\r\n   * Optionally specify the line width of the raster's bitmap, by default 1 pixel\r\n   */\r\n  lineWidth?: number;\r\n\r\n  /**\r\n   * Optionally specify the line dash of the raster's bitmap, by default `[]` which means none\r\n   */\r\n  lineDash?: number[];\r\n\r\n  /**\r\n   * Optionally specify the line end style, default is \"butt\".\r\n   */\r\n  lineCap?: 'butt' | 'round' | 'square';\r\n\r\n  /**\r\n   * Optionally specify the padding to apply to the bitmap\r\n   */\r\n  padding?: number;\r\n\r\n  /**\r\n   * Optionally specify what image filtering mode should be used, [[ImageFiltering.Pixel]] for pixel art,\r\n   * [[ImageFiltering.Blended]] for hi-res art\r\n   *\r\n   * By default unset, rasters defer to the engine antialiasing setting\r\n   */\r\n  filtering?: ImageFiltering;\r\n}\r\n\r\n/**\r\n * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the\r\n * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.\r\n *\r\n * Implementors must implement the [[Raster.execute]] method to rasterize their drawing.\r\n */\r\nexport abstract class Raster extends Graphic {\r\n  public filtering: ImageFiltering = null;\r\n  public lineCap: 'butt' | 'round' | 'square' = 'butt';\r\n  public quality: number = 1;\r\n\r\n  public _bitmap: HTMLCanvasElement;\r\n  protected _ctx: CanvasRenderingContext2D;\r\n  private _dirty: boolean = true;\r\n\r\n  constructor(options?: GraphicOptions & RasterOptions) {\r\n    super(options);\r\n    if (options) {\r\n      this.quality = options.quality ?? this.quality;\r\n      this.color = options.color ?? Color.Black;\r\n      this.strokeColor = options?.strokeColor;\r\n      this.smoothing = options.smoothing ?? this.smoothing;\r\n      this.lineWidth = options.lineWidth ?? this.lineWidth;\r\n      this.lineDash = options.lineDash ?? this.lineDash;\r\n      this.lineCap = options.lineCap ?? this.lineCap;\r\n      this.padding = options.padding ?? this.padding;\r\n      this.filtering = options.filtering ?? this.filtering;\r\n    }\r\n    this._bitmap = document.createElement('canvas');\r\n    // get the default canvas width/height as a fallback\r\n    const bitmapWidth = options?.width ?? this._bitmap.width;\r\n    const bitmapHeight = options?.height ?? this._bitmap.height;\r\n    this.width = bitmapWidth;\r\n    this.height = bitmapHeight;\r\n    const maybeCtx = this._bitmap.getContext('2d');\r\n    if (!maybeCtx) {\r\n      /* istanbul ignore next */\r\n      throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');\r\n    } else {\r\n      this._ctx = maybeCtx;\r\n    }\r\n  }\r\n\r\n  public cloneRasterOptions(): RasterOptions {\r\n    return {\r\n      color: this.color ? this.color.clone() : null,\r\n      strokeColor: this.strokeColor ? this.strokeColor.clone() : null,\r\n      smoothing: this.smoothing,\r\n      lineWidth: this.lineWidth,\r\n      lineDash: this.lineDash,\r\n      lineCap: this.lineCap,\r\n      quality: this.quality,\r\n      padding: this.padding\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized\r\n   */\r\n  public get dirty() {\r\n    return this._dirty;\r\n  }\r\n\r\n  /**\r\n   * Flags the graphic as dirty, meaning it must be re-rasterized before draw.\r\n   * This should be called any time the graphics state changes such that it affects the outputted drawing\r\n   */\r\n  public flagDirty() {\r\n    this._dirty = true;\r\n  }\r\n\r\n  private _originalWidth: number;\r\n  /**\r\n   * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   *\r\n   * Any `padding`s or `quality` set will be factored into the width\r\n   */\r\n  public get width() {\r\n    return Math.abs(this._getTotalWidth() * this.scale.x);\r\n  }\r\n  public set width(value: number) {\r\n    value /= Math.abs(this.scale.x);\r\n    this._bitmap.width = value;\r\n    this._originalWidth = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _originalHeight: number;\r\n  /**\r\n   * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   *\r\n   * Any `padding` or `quality` set will be factored into the height\r\n   */\r\n  public get height() {\r\n    return Math.abs(this._getTotalHeight() * this.scale.y);\r\n  }\r\n\r\n  public set height(value: number) {\r\n    value /= Math.abs(this.scale.y);\r\n    this._bitmap.height = value;\r\n    this._originalHeight = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _getTotalWidth() {\r\n    return ((this._originalWidth ?? this._bitmap.width) + this.padding * 2) * 1;\r\n  }\r\n\r\n  private _getTotalHeight() {\r\n    return ((this._originalHeight ?? this._bitmap.height) + this.padding * 2) * 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the local bounds of the Raster including the padding\r\n   */\r\n  public get localBounds() {\r\n    return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);\r\n  }\r\n\r\n  private _smoothing: boolean = false;\r\n  /**\r\n   * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get smoothing() {\r\n    return this._smoothing;\r\n  }\r\n  public set smoothing(value: boolean) {\r\n    this._smoothing = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _color: Color = watch(Color.Black, () => this.flagDirty());\r\n  /**\r\n   * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get color() {\r\n    return this._color;\r\n  }\r\n  public set color(value) {\r\n    this.flagDirty();\r\n    this._color = watch(value, () => this.flagDirty());\r\n  }\r\n\r\n  private _strokeColor: Color;\r\n  /**\r\n   * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get strokeColor() {\r\n    return this._strokeColor;\r\n  }\r\n  public set strokeColor(value) {\r\n    this.flagDirty();\r\n    this._strokeColor = watch(value, () => this.flagDirty());\r\n  }\r\n\r\n  private _lineWidth: number = 1;\r\n  /**\r\n   * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get lineWidth() {\r\n    return this._lineWidth;\r\n  }\r\n  public set lineWidth(value) {\r\n    this._lineWidth = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _lineDash: number[] = [];\r\n  public get lineDash() {\r\n    return this._lineDash;\r\n  }\r\n\r\n  public set lineDash(value) {\r\n    this._lineDash = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _padding: number = 0;\r\n  public get padding() {\r\n    return this._padding;\r\n  }\r\n\r\n  public set padding(value: number) {\r\n    this._padding = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  /**\r\n   * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if\r\n   * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call\r\n   */\r\n  public rasterize(): void {\r\n    this._dirty = false;\r\n    this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());\r\n    this._ctx.save();\r\n    this._applyRasterProperties(this._ctx);\r\n    this.execute(this._ctx);\r\n    this._ctx.restore();\r\n    // The webgl texture needs to be updated if it exists after a raster cycle\r\n    TextureLoader.load(this._bitmap, this.filtering, true);\r\n  }\r\n\r\n  protected _applyRasterProperties(ctx: CanvasRenderingContext2D) {\r\n    this._bitmap.width = this._getTotalWidth() * this.quality;\r\n    this._bitmap.height = this._getTotalHeight() * this.quality;\r\n    ctx.scale(this.quality, this.quality);\r\n    ctx.translate(this.padding, this.padding);\r\n    ctx.imageSmoothingEnabled = this.smoothing;\r\n    ctx.lineWidth = this.lineWidth;\r\n    ctx.setLineDash(this.lineDash ?? ctx.getLineDash());\r\n    ctx.lineCap = this.lineCap;\r\n    ctx.strokeStyle = this.strokeColor?.toString();\r\n    ctx.fillStyle = this.color?.toString();\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this._dirty) {\r\n      this.rasterize();\r\n    }\r\n    ex.scale(1 / this.quality, 1 / this.quality);\r\n    ex.drawImage(this._bitmap, x, y);\r\n  }\r\n\r\n  /**\r\n   * Executes drawing implementation of the graphic, this is where the specific drawing code for the graphic\r\n   * should be implemented. Once `rasterize()` the graphic can be drawn to the [[ExcaliburGraphicsContext]] via `draw(...)`\r\n   * @param ctx Canvas to draw the graphic to\r\n   */\r\n  abstract execute(ctx: CanvasRenderingContext2D): void;\r\n}\r\n","import { GraphicOptions } from './Graphic';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CanvasOptions {\r\n  draw?: (ctx: CanvasRenderingContext2D) => void;\r\n  cache?: boolean;\r\n}\r\n\r\n/**\r\n * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].\r\n *\r\n * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed\r\n * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.\r\n *\r\n * **Low performance API**\r\n */\r\nexport class Canvas extends Raster {\r\n  /**\r\n   * Return the 2D graphics context of this canvas\r\n   */\r\n  public get ctx() {\r\n    return this._ctx;\r\n  }\r\n\r\n  constructor(private _options: GraphicOptions & RasterOptions & CanvasOptions) {\r\n    super(_options);\r\n  }\r\n\r\n  public clone(): Canvas {\r\n    return new Canvas({\r\n      ...this._options,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this._options?.draw) {\r\n      this._options?.draw(ctx);\r\n    }\r\n    if (!this._options.cache) {\r\n      this.flagDirty();\r\n    }\r\n  }\r\n}\r\n","import { Audio } from './Audio';\r\n\r\nexport type ExResponseType = '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text';\r\n\r\nexport interface ExResponseTypesLookup {\r\n  [name: string]: ExResponseType;\r\n}\r\n\r\nexport class ExResponse {\r\n  public static type: ExResponseTypesLookup = {\r\n    any: '',\r\n    blob: 'blob',\r\n    json: 'json',\r\n    text: 'text',\r\n    document: 'document',\r\n    arraybuffer: 'arraybuffer'\r\n  };\r\n}\r\n\r\n/**\r\n * Represents an audio implementation like [[WebAudioInstance]]\r\n */\r\nexport interface AudioImplementation {\r\n  /**\r\n   * XHR response type\r\n   */\r\n  responseType: ExResponseType;\r\n\r\n  /**\r\n   * Processes raw data and transforms into sound data\r\n   */\r\n  processData(data: Blob | ArrayBuffer): Promise<string | AudioBuffer>;\r\n\r\n  /**\r\n   * Factory method that returns an instance of a played audio track\r\n   */\r\n  createInstance(data: string | AudioBuffer): Audio;\r\n}\r\n","\r\nexport interface State {\r\n  name?: string;\r\n  transitions: string[];\r\n  onEnter?: (context: {from: string, eventData?: any, data: any}) => boolean | void;\r\n  onState?: () => any;\r\n  onExit?: (context: {to: string, data: any}) => boolean | void;\r\n  onUpdate?: (data: any, elapsedMs: number) => any;\r\n}\r\n\r\nexport interface StateMachineDescription {\r\n  start: string,\r\n  states: { [name: string]: State }\r\n}\r\n\r\nexport type PossibleStates<TMachine> = TMachine extends StateMachineDescription ? Extract<keyof TMachine['states'], string> : never;\r\n\r\nexport interface StateMachineState {\r\n  data: any;\r\n  currentState: string;\r\n}\r\n\r\nexport class StateMachine<TPossibleStates extends string, TData> {\r\n  public startState: State;\r\n  private _currentState: State;\r\n  public get currentState(): State {\r\n    return this._currentState;\r\n  }\r\n  public set currentState(state: State) {\r\n    this._currentState = state;\r\n  }\r\n  public states = new Map<string, State>();\r\n  public data: TData;\r\n\r\n  static create<TMachine extends StateMachineDescription, TData>(\r\n    machineDescription: TMachine, data?: TData): StateMachine<PossibleStates<TMachine>, TData> {\r\n    const machine = new StateMachine<PossibleStates<TMachine>, TData>();\r\n    machine.data = data;\r\n    for (const stateName in machineDescription.states) {\r\n      machine.states.set(stateName as PossibleStates<TMachine>, {\r\n        name: stateName,\r\n        ...machineDescription.states[stateName]\r\n      });\r\n    }\r\n\r\n    // validate transitions are states\r\n    for (const state of machine.states.values()) {\r\n      for (const transitionState of state.transitions) {\r\n        if (transitionState === '*') {\r\n          continue;\r\n        }\r\n        if (!machine.states.has(transitionState)) {\r\n          throw Error(\r\n            `Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`\r\n          );\r\n        }\r\n      }\r\n    }\r\n    machine.currentState = machine.startState = machine.states.get(machineDescription.start);\r\n    return machine;\r\n  }\r\n\r\n  in(state: TPossibleStates): boolean {\r\n    return this.currentState.name === state;\r\n  }\r\n\r\n  go(stateName: TPossibleStates, eventData?: any): boolean {\r\n    if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes('*')) {\r\n      const potentialNewState = this.states.get(stateName);\r\n      if (this.currentState.onExit) {\r\n        const canExit = this.currentState?.onExit({to: potentialNewState.name, data: this.data});\r\n        if (canExit === false) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (potentialNewState?.onEnter) {\r\n        const canEnter = potentialNewState?.onEnter({from: this.currentState.name, eventData, data: this.data});\r\n        if (canEnter === false) {\r\n          return false;\r\n        }\r\n      }\r\n      // console.log(`${this.currentState.name} => ${potentialNewState.name} (${eventData})`);\r\n      this.currentState = potentialNewState;\r\n      if (this.currentState?.onState) {\r\n        this.currentState.onState();\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  update(elapsedMs: number) {\r\n    if (this.currentState.onUpdate) {\r\n      this.currentState.onUpdate(this.data, elapsedMs);\r\n    }\r\n  }\r\n\r\n  save(saveKey: string) {\r\n    localStorage.setItem(saveKey, JSON.stringify({\r\n      currentState: this.currentState.name,\r\n      data: this.data\r\n    }));\r\n  }\r\n\r\n  restore(saveKey: string) {\r\n    const state: StateMachineState = JSON.parse(localStorage.getItem(saveKey));\r\n    this.currentState = this.states.get(state.currentState);\r\n    this.data = state.data;\r\n  }\r\n}\r\n\r\n","import { StateMachine } from '../../Util/StateMachine';\r\nimport { Audio } from '../../Interfaces/Audio';\r\nimport { clamp } from '../../Math/util';\r\nimport { AudioContextFactory } from './AudioContext';\r\n\r\ninterface SoundState {\r\n  startedAt: number;\r\n  pausedAt: number;\r\n}\r\n\r\n/**\r\n * Internal class representing a Web Audio AudioBufferSourceNode instance\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\r\n */\r\nexport class WebAudioInstance implements Audio {\r\n  private _instance: AudioBufferSourceNode;\r\n  private _audioContext: AudioContext = AudioContextFactory.create();\r\n  private _volumeNode = this._audioContext.createGain();\r\n  private _playingResolve: (value: boolean) => void;\r\n  private _playingPromise = new Promise<boolean>((resolve) => {\r\n    this._playingResolve = resolve;\r\n  });\r\n  private _stateMachine = StateMachine.create({\r\n    start: 'STOPPED',\r\n    states: {\r\n      PLAYING: {\r\n        onEnter: ({data}: {from: string, data: SoundState}) => {\r\n\r\n          // Buffer nodes are single use\r\n          this._createNewBufferSource();\r\n          this._handleEnd();\r\n          this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);\r\n          data.startedAt = (this._audioContext.currentTime - data.pausedAt);\r\n          data.pausedAt = 0;\r\n        },\r\n        onState: () => this._playStarted(),\r\n        onExit: ({to}) => {\r\n          // If you've exited early only resolve if explicitly STOPPED\r\n          if (to === 'STOPPED') {\r\n            this._playingResolve(true);\r\n          }\r\n          // Whenever you're not playing... you stop!\r\n          this._instance.onended = null; // disconnect the wired on-end handler\r\n          this._instance.disconnect();\r\n          this._instance.stop(0);\r\n          this._instance = null;\r\n        },\r\n        transitions: ['STOPPED', 'PAUSED', 'SEEK']\r\n      },\r\n      SEEK: {\r\n        onEnter: ({ eventData: position, data }: {eventData?: number, data: SoundState}) => {\r\n          data.pausedAt = (position ?? 0) / this._playbackRate;\r\n          data.startedAt = 0;\r\n        },\r\n        transitions: ['*']\r\n      },\r\n      STOPPED: {\r\n        onEnter: ({data}: {from: string, data: SoundState}) => {\r\n          data.pausedAt = 0;\r\n          data.startedAt = 0;\r\n          this._playingResolve(true);\r\n        },\r\n        transitions: ['PLAYING', 'PAUSED', 'SEEK']\r\n      },\r\n      PAUSED: {\r\n        onEnter: ({data}: {data: SoundState}) => {\r\n          // Playback rate will be a scale factor of how fast/slow the audio is being played\r\n          // default is 1.0\r\n          // we need to invert it to get the time scale\r\n          data.pausedAt = (this._audioContext.currentTime - data.startedAt);\r\n        },\r\n        transitions: ['PLAYING', 'STOPPED', 'SEEK']\r\n      }\r\n    }\r\n  }, {\r\n    startedAt: 0,\r\n    pausedAt: 0\r\n  } as SoundState);\r\n\r\n  private _createNewBufferSource() {\r\n    this._instance = this._audioContext.createBufferSource();\r\n    this._instance.buffer = this._src;\r\n    this._instance.loop = this.loop;\r\n    this._instance.playbackRate.value = this._playbackRate;\r\n    this._instance.connect(this._volumeNode);\r\n    this._volumeNode.connect(this._audioContext.destination);\r\n  }\r\n\r\n  private _handleEnd() {\r\n    if (!this.loop) {\r\n      this._instance.onended = () => {\r\n        this._playingResolve(true);\r\n      };\r\n    }\r\n  }\r\n\r\n  private _volume = 1;\r\n  private _loop = false;\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  private _playStarted: () => any = () => {};\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    if (this._instance) {\r\n      this._instance.loop = value;\r\n      if (!this.loop) {\r\n        this._instance.onended = () => {\r\n          this._playingResolve(true);\r\n        };\r\n      }\r\n    }\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    value = clamp(value, 0, 1.0);\r\n\r\n    this._volume = value;\r\n\r\n    if (this._stateMachine.in('PLAYING') && this._volumeNode.gain.setTargetAtTime) {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime\r\n      // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.\r\n      // This exponential ramp provides a more pleasant transition in gain\r\n      this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);\r\n    } else {\r\n      this._volumeNode.gain.value = value;\r\n    }\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  private _duration: number | undefined;\r\n  /**\r\n   * Returns the set duration to play, otherwise returns the total duration if unset\r\n   */\r\n  public get duration() {\r\n    return this._duration ?? this.getTotalPlaybackDuration();\r\n  }\r\n\r\n  /**\r\n   * Set the duration that this audio should play.\r\n   *\r\n   * Note: if you seek to a specific point the duration will start from that point, for example\r\n   *\r\n   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n   */\r\n  public set duration(duration: number) {\r\n    this._duration = duration;\r\n  }\r\n\r\n  constructor(private _src: AudioBuffer) {\r\n    this._createNewBufferSource();\r\n  }\r\n\r\n  public isPlaying() {\r\n    return this._stateMachine.in('PLAYING');\r\n  }\r\n\r\n  public isPaused() {\r\n    return this._stateMachine.in('PAUSED') || this._stateMachine.in('SEEK');\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  public play(playStarted: () => any = () => {}) {\r\n    this._playStarted = playStarted;\r\n    this._stateMachine.go('PLAYING');\r\n    return this._playingPromise;\r\n  }\r\n\r\n  public pause() {\r\n    this._stateMachine.go('PAUSED');\r\n  }\r\n\r\n  public stop() {\r\n    this._stateMachine.go('STOPPED');\r\n  }\r\n\r\n  public seek(position: number) {\r\n    this._stateMachine.go('PAUSED');\r\n    this._stateMachine.go('SEEK', position);\r\n  }\r\n\r\n  public getTotalPlaybackDuration() {\r\n    return this._src.duration;\r\n  }\r\n\r\n  public getPlaybackPosition() {\r\n    const {pausedAt, startedAt} =  this._stateMachine.data;\r\n    if (pausedAt) {\r\n      return pausedAt * this._playbackRate;\r\n    }\r\n    if (startedAt) {\r\n      return (this._audioContext.currentTime - startedAt) * this._playbackRate;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private _playbackRate = 1.0;\r\n  public set playbackRate(playbackRate: number) {\r\n    this._instance.playbackRate.value = this._playbackRate = playbackRate;\r\n  }\r\n\r\n  public get playbackRate() {\r\n    return this._instance.playbackRate.value;\r\n  }\r\n}\r\n","import { GameEvent } from '../Events';\r\nimport { Sound } from '../Resources/Sound/Sound';\r\nimport { Actor } from '../Actor';\r\nimport { WebAudioInstance } from '../Resources/Sound/WebAudioInstance';\r\n\r\nexport class MediaEvent extends GameEvent<Sound> {\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public set bubbles(_value: boolean) {\r\n    // stubbed\r\n  }\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public get bubbles(): boolean {\r\n    return false;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected get _path(): Actor[] {\r\n    return null;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected set _path(_val: Actor[]) {\r\n    // stubbed\r\n  }\r\n\r\n  constructor(public target: Sound, protected _name: string = 'MediaEvent') {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Prevents event from bubbling\r\n   */\r\n  public stopPropagation(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Action, that calls when event happens\r\n   */\r\n  public action(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Propagate event further through event path\r\n   */\r\n  public propagate(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n\r\n  public layPath(_actor: Actor): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n}\r\n\r\nexport class NativeSoundEvent extends MediaEvent {\r\n  constructor(target: Sound, public track?: WebAudioInstance) {\r\n    super(target, 'NativeSoundEvent');\r\n  }\r\n}\r\n\r\nexport class NativeSoundProcessedEvent extends MediaEvent {\r\n  public data: string | AudioBuffer;\r\n\r\n  constructor(target: Sound, private _processedData: string | AudioBuffer) {\r\n    super(target, 'NativeSoundProcessedEvent');\r\n\r\n    this.data = this._processedData;\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n\r\n/**\r\n * Whether or not the browser can play this file as HTML5 Audio\r\n */\r\nexport function canPlayFile(file: string): boolean {\r\n  try {\r\n    const a = new Audio();\r\n    const filetype = /.*\\.([A-Za-z0-9]+)$/;\r\n    const type = file.match(filetype)[1];\r\n    if (a.canPlayType('audio/' + type)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  } catch (e) {\r\n    Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);\r\n    return false;\r\n  }\r\n}\r\n","import { ExResponse } from '../../Interfaces/AudioImplementation';\r\nimport { Audio } from '../../Interfaces/Audio';\r\nimport { Engine } from '../../Engine';\r\nimport { Resource } from '../Resource';\r\nimport { WebAudioInstance } from './WebAudioInstance';\r\nimport { AudioContextFactory } from './AudioContext';\r\nimport { NativeSoundEvent, NativeSoundProcessedEvent } from '../../Events/MediaEvents';\r\nimport { canPlayFile } from '../../Util/Sound';\r\nimport { Loadable } from '../../Interfaces/Index';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Class } from '../../Class';\r\n\r\n/**\r\n * The [[Sound]] object allows games built in Excalibur to load audio\r\n * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]\r\n * which means it can be passed to a [[Loader]] to pre-load before a game or level.\r\n */\r\nexport class Sound extends Class implements Audio, Loadable<AudioBuffer> {\r\n  public logger: Logger = Logger.getInstance();\r\n  public data: AudioBuffer;\r\n  private _resource: Resource<ArrayBuffer>;\r\n  /**\r\n   * Indicates whether the clip should loop when complete\r\n   * @param value  Set the looping flag\r\n   */\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.loop = this._loop;\r\n    }\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    this._volume = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.volume = this._volume;\r\n    }\r\n\r\n    this.emit('volumechange', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  private _duration: number | undefined;\r\n  /**\r\n   * Get the duration that this audio should play. If unset the total natural playback duration will be used.\r\n   */\r\n  public get duration(): number | undefined {\r\n    return this._duration;\r\n  }\r\n  /**\r\n   * Set the duration that this audio should play. If unset the total natural playback duration will be used.\r\n   *\r\n   * Note: if you seek to a specific point the duration will start from that point, for example\r\n   *\r\n   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n   */\r\n  public set duration(duration: number | undefined){\r\n    this._duration = duration;\r\n  }\r\n\r\n  /**\r\n   * Return array of Current AudioInstances playing or being paused\r\n   */\r\n  public get instances(): Audio[] {\r\n    return this._tracks;\r\n  }\r\n\r\n  public get path() {\r\n    return this._resource.path;\r\n  }\r\n\r\n  public set path(val: string) {\r\n    this._resource.path = val;\r\n  }\r\n\r\n  private _loop = false;\r\n  private _volume = 1;\r\n  private _isStopped = false;\r\n  // private _isPaused = false;\r\n  private _tracks: Audio[] = [];\r\n  private _engine: Engine;\r\n  private _wasPlayingOnHidden: boolean = false;\r\n  private _playbackRate = 1.0;\r\n  private _audioContext = AudioContextFactory.create();\r\n\r\n  /**\r\n   * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.\r\n   */\r\n  constructor(...paths: string[]) {\r\n    super();\r\n    this._resource = new Resource('', ExResponse.type.arraybuffer);\r\n    /**\r\n     * Chrome : MP3, WAV, Ogg\r\n     * Firefox : WAV, Ogg,\r\n     * IE : MP3, WAV coming soon\r\n     * Safari MP3, WAV, Ogg\r\n     */\r\n    for (const path of paths) {\r\n      if (canPlayFile(path)) {\r\n        this.path = path;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!this.path) {\r\n      this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));\r\n      this.logger.warn('Attempting to use', paths[0]);\r\n      this.path = paths[0]; // select the first specified\r\n    }\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  public async load(): Promise<AudioBuffer> {\r\n    if (this.data) {\r\n      return this.data;\r\n    }\r\n    const arraybuffer = await this._resource.load();\r\n    const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));\r\n    this._duration = this._duration ?? audiobuffer?.duration ?? undefined;\r\n    this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));\r\n    return this.data = audiobuffer;\r\n  }\r\n\r\n  public async decodeAudio(data: ArrayBuffer): Promise<AudioBuffer> {\r\n    try {\r\n      return await this._audioContext.decodeAudioData(data.slice(0));\r\n    } catch (e) {\r\n      this.logger.error(\r\n        'Unable to decode ' +\r\n          ' this browser may not fully support this format, or the file may be corrupt, ' +\r\n          'if this is an mp3 try removing id3 tags and album art from the file.'\r\n      );\r\n      return await Promise.reject();\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    if (engine) {\r\n      this._engine = engine;\r\n\r\n      this._engine.on('hidden', () => {\r\n        if (engine.pauseAudioWhenHidden && this.isPlaying()) {\r\n          this._wasPlayingOnHidden = true;\r\n          this.pause();\r\n        }\r\n      });\r\n\r\n      this._engine.on('visible', () => {\r\n        if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {\r\n          this.play();\r\n          this._wasPlayingOnHidden = false;\r\n        }\r\n      });\r\n\r\n      this._engine.on('start', () => {\r\n        this._isStopped = false;\r\n      });\r\n\r\n      this._engine.on('stop', () => {\r\n        this.stop();\r\n        this._isStopped = true;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns how many instances of the sound are currently playing\r\n   */\r\n  public instanceCount(): number {\r\n    return this._tracks.length;\r\n  }\r\n\r\n  /**\r\n   * Whether or not the sound is playing right now\r\n   */\r\n  public isPlaying(): boolean {\r\n    return this._tracks.some((t) => t.isPlaying());\r\n  }\r\n\r\n  public isPaused(): boolean {\r\n    return this._tracks.some(t => t.isPaused());\r\n  }\r\n\r\n  /**\r\n   * Play the sound, returns a promise that resolves when the sound is done playing\r\n   * An optional volume argument can be passed in to play the sound. Max volume is 1.0\r\n   */\r\n  public play(volume?: number): Promise<boolean> {\r\n    if (!this.isLoaded()) {\r\n      this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');\r\n\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    if (this._isStopped) {\r\n      this.logger.warn('Cannot start playing. Engine is in a stopped state.');\r\n      return Promise.resolve(false);\r\n    }\r\n\r\n    this.volume = volume || this.volume;\r\n\r\n    if (this.isPaused()) {\r\n      return this._resumePlayback();\r\n    } else {\r\n      return this._startPlayback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the sound, and do not rewind\r\n   */\r\n  public pause() {\r\n    if (!this.isPlaying()) {\r\n      return;\r\n    }\r\n\r\n    for (const track of this._tracks) {\r\n      track.pause();\r\n    }\r\n\r\n    this.emit('pause', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Paused all instances of sound', this.path);\r\n  }\r\n\r\n  /**\r\n   * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.\r\n   */\r\n  public stop() {\r\n    for (const track of this._tracks) {\r\n      track.stop();\r\n    }\r\n\r\n    this.emit('stop', new NativeSoundEvent(this));\r\n\r\n    this._tracks.length = 0;\r\n    this.logger.debug('Stopped all instances of sound', this.path);\r\n  }\r\n\r\n  public get playbackRate(): number {\r\n    return this._playbackRate;\r\n  }\r\n\r\n  public set playbackRate(playbackRate: number) {\r\n    this._playbackRate = playbackRate;\r\n    this._tracks.forEach(t => {\r\n      t.playbackRate = this._playbackRate;\r\n    });\r\n  }\r\n\r\n  public seek(position: number, trackId = 0) {\r\n    if (this._tracks.length === 0) {\r\n      this._getTrackInstance(this.data);\r\n    }\r\n\r\n    this._tracks[trackId].seek(position);\r\n  }\r\n\r\n  public getTotalPlaybackDuration() {\r\n    return this.data.duration;\r\n  }\r\n\r\n  /**\r\n   * Return the current playback time of the playing track in seconds from the start.\r\n   *\r\n   * Optionally specify the track to query if multiple are playing at once.\r\n   * @param trackId\r\n   */\r\n  public getPlaybackPosition(trackId = 0) {\r\n    if (this._tracks.length) {\r\n      return this._tracks[trackId].getPlaybackPosition();\r\n    }\r\n    return 0;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get Id of provided AudioInstance in current trackList\r\n   * @param track [[Audio]] which Id is to be given\r\n   */\r\n  public getTrackId(track: Audio): number {\r\n    return this._tracks.indexOf(track);\r\n  }\r\n\r\n  private async _resumePlayback(): Promise<boolean> {\r\n    if (this.isPaused) {\r\n      const resumed: Promise<boolean>[] = [];\r\n      // ensure we resume *current* tracks (if paused)\r\n      for (const track of this._tracks) {\r\n        resumed.push(track.play().then(() => {\r\n          this.emit('playbackend', new NativeSoundEvent(this, track as WebAudioInstance));\r\n          this._tracks.splice(this.getTrackId(track), 1);\r\n          return true;\r\n        }));\r\n      }\r\n\r\n      this.emit('resume', new NativeSoundEvent(this));\r\n\r\n      this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);\r\n      // resolve when resumed tracks are done\r\n      await Promise.all(resumed);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Starts playback, returns a promise that resolves when playback is complete\r\n   */\r\n  private async _startPlayback(): Promise<boolean> {\r\n    const track = await this._getTrackInstance(this.data);\r\n\r\n    const complete = await track.play(() => {\r\n      this.emit('playbackstart', new NativeSoundEvent(this, track));\r\n      this.logger.debug('Playing new instance for sound', this.path);\r\n    });\r\n\r\n    // when done, remove track\r\n    this.emit('playbackend', new NativeSoundEvent(this, track));\r\n    this._tracks.splice(this.getTrackId(track), 1);\r\n\r\n    return complete;\r\n  }\r\n\r\n  private _getTrackInstance(data: AudioBuffer): WebAudioInstance {\r\n    const newTrack = new WebAudioInstance(data);\r\n\r\n    newTrack.loop = this.loop;\r\n    newTrack.volume = this.volume;\r\n    newTrack.duration = this.duration;\r\n    newTrack.playbackRate = this._playbackRate;\r\n\r\n    this._tracks.push(newTrack);\r\n\r\n    return newTrack;\r\n  }\r\n}\r\n","import { Color } from './Color';\r\nimport { WebAudio } from './Util/WebAudio';\r\nimport { Engine } from './Engine';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Class } from './Class';\r\nimport * as DrawUtil from './Util/DrawUtil';\r\n\r\nimport logoImg from './Loader.logo.png';\r\nimport loaderCss from './Loader.css';\r\nimport { Canvas } from './Graphics/Canvas';\r\nimport { Vector } from './Math/vector';\r\nimport { delay } from './Util/Util';\r\nimport { ImageFiltering } from './Graphics/Filtering';\r\nimport { clamp } from './Math/util';\r\nimport { Sound } from './Resources/Sound/Sound';\r\nimport { Future } from './Util/Future';\r\n\r\n/**\r\n * Pre-loading assets\r\n *\r\n * The loader provides a mechanism to preload multiple resources at\r\n * one time. The loader must be passed to the engine in order to\r\n * trigger the loading progress bar.\r\n *\r\n * The [[Loader]] itself implements [[Loadable]] so you can load loaders.\r\n *\r\n * ## Example: Pre-loading resources for a game\r\n *\r\n * ```js\r\n * // create a loader\r\n * var loader = new ex.Loader();\r\n *\r\n * // create a resource dictionary (best practice is to keep a separate file)\r\n * var resources = {\r\n *   TextureGround: new ex.Texture(\"/images/textures/ground.png\"),\r\n *   SoundDeath: new ex.Sound(\"/sound/death.wav\", \"/sound/death.mp3\")\r\n * };\r\n *\r\n * // loop through dictionary and add to loader\r\n * for (var loadable in resources) {\r\n *   if (resources.hasOwnProperty(loadable)) {\r\n *     loader.addResource(resources[loadable]);\r\n *   }\r\n * }\r\n *\r\n * // start game\r\n * game.start(loader).then(function () {\r\n *   console.log(\"Game started!\");\r\n * });\r\n * ```\r\n *\r\n * ## Customize the Loader\r\n *\r\n * The loader can be customized to show different, text, logo, background color, and button.\r\n *\r\n * ```typescript\r\n * const loader = new ex.Loader([playerTexture]);\r\n *\r\n * // The loaders button text can simply modified using this\r\n * loader.playButtonText = 'Start the best game ever';\r\n *\r\n * // The logo can be changed by inserting a base64 image string here\r\n *\r\n * loader.logo = 'data:image/png;base64,iVBORw...';\r\n * loader.logoWidth = 15;\r\n * loader.logoHeight = 14;\r\n *\r\n * // The background color can be changed like so by supplying a valid CSS color string\r\n *\r\n * loader.backgroundColor = 'red'\r\n * loader.backgroundColor = '#176BAA'\r\n *\r\n * // To build a completely new button\r\n * loader.startButtonFactory = () => {\r\n *     let myButton = document.createElement('button');\r\n *     myButton.textContent = 'The best button';\r\n *     return myButton;\r\n * };\r\n *\r\n * engine.start(loader).then(() => {});\r\n * ```\r\n */\r\nexport class Loader extends Class implements Loadable<Loadable<any>[]> {\r\n  public canvas: Canvas = new Canvas({\r\n    filtering: ImageFiltering.Blended,\r\n    smoothing: true,\r\n    cache: true,\r\n    draw: this.draw.bind(this)\r\n  });\r\n  private _resourceList: Loadable<any>[] = [];\r\n  private _index = 0;\r\n\r\n  private _playButtonShown: boolean = false;\r\n  private _resourceCount: number = 0;\r\n  private _numLoaded: number = 0;\r\n  private _progressCounts: { [key: string]: number } = {};\r\n  private _totalCounts: { [key: string]: number } = {};\r\n  private _engine: Engine;\r\n\r\n  // logo drawing stuff\r\n\r\n  // base64 string encoding of the excalibur logo (logo-white.png)\r\n  public logo = logoImg;\r\n  public logoWidth = 468;\r\n  public logoHeight = 118;\r\n  /**\r\n   * Positions the top left corner of the logo image\r\n   * If not set, the loader automatically positions the logo\r\n   */\r\n  public logoPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the play button.\r\n   * If not set, the loader automatically positions the play button\r\n   */\r\n  public playButtonPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the loading bar\r\n   * If not set, the loader automatically positions the loading bar\r\n   */\r\n  public loadingBarPosition: Vector | null;\r\n\r\n  /**\r\n   * Gets or sets the color of the loading bar, default is [[Color.White]]\r\n   */\r\n  public loadingBarColor: Color = Color.White;\r\n\r\n  /**\r\n   * Gets or sets the background color of the loader as a hex string\r\n   */\r\n  public backgroundColor: string = '#176BAA';\r\n\r\n  protected _imageElement: HTMLImageElement;\r\n  protected get _image() {\r\n    if (!this._imageElement) {\r\n      this._imageElement = new Image();\r\n      this._imageElement.src = this.logo;\r\n    }\r\n\r\n    return this._imageElement;\r\n  }\r\n\r\n  public suppressPlayButton: boolean = false;\r\n  public get playButtonRootElement(): HTMLElement | null {\r\n    return this._playButtonRootElement;\r\n  }\r\n  public get playButtonElement(): HTMLButtonElement | null {\r\n    return this._playButtonElement;\r\n  }\r\n  protected _playButtonRootElement: HTMLElement;\r\n  protected _playButtonElement: HTMLButtonElement;\r\n  protected _styleBlock: HTMLStyleElement;\r\n  /** Loads the css from Loader.css */\r\n  protected _playButtonStyles: string = loaderCss.toString();\r\n  protected get _playButton() {\r\n    const existingRoot = document.getElementById('excalibur-play-root');\r\n    if (existingRoot) {\r\n      this._playButtonRootElement = existingRoot;\r\n    }\r\n    if (!this._playButtonRootElement) {\r\n      this._playButtonRootElement = document.createElement('div');\r\n      this._playButtonRootElement.id = 'excalibur-play-root';\r\n      this._playButtonRootElement.style.position = 'absolute';\r\n      document.body.appendChild(this._playButtonRootElement);\r\n    }\r\n    if (!this._styleBlock) {\r\n      this._styleBlock = document.createElement('style');\r\n      this._styleBlock.textContent = this._playButtonStyles;\r\n      document.head.appendChild(this._styleBlock);\r\n    }\r\n    if (!this._playButtonElement) {\r\n      this._playButtonElement = this.startButtonFactory();\r\n      this._playButtonRootElement.appendChild(this._playButtonElement);\r\n    }\r\n    return this._playButtonElement;\r\n  }\r\n\r\n  /**\r\n   * Get/set play button text\r\n   */\r\n  public playButtonText: string = 'Play game';\r\n\r\n  /**\r\n   * Return a html button element for excalibur to use as a play button\r\n   */\r\n  public startButtonFactory = () => {\r\n    let buttonElement: HTMLButtonElement = document.getElementById('excalibur-play') as HTMLButtonElement;\r\n    if (!buttonElement) {\r\n      buttonElement = document.createElement('button');\r\n    }\r\n\r\n    buttonElement.id = 'excalibur-play';\r\n    buttonElement.textContent = this.playButtonText;\r\n    buttonElement.style.display = 'none';\r\n    return buttonElement;\r\n  };\r\n\r\n  /**\r\n   * @param loadables  Optionally provide the list of resources you want to load at constructor time\r\n   */\r\n  constructor(loadables?: Loadable<any>[]) {\r\n    super();\r\n\r\n    if (loadables) {\r\n      this.addResources(loadables);\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    this._engine = engine;\r\n    this.canvas.width = this._engine.canvas.width;\r\n    this.canvas.height = this._engine.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Add a resource to the loader to load\r\n   * @param loadable  Resource to add\r\n   */\r\n  public addResource(loadable: Loadable<any>) {\r\n    const key = this._index++;\r\n    this._resourceList.push(loadable);\r\n    this._progressCounts[key] = 0;\r\n    this._totalCounts[key] = 1;\r\n    this._resourceCount++;\r\n  }\r\n\r\n  /**\r\n   * Add a list of resources to the loader to load\r\n   * @param loadables  The list of resources to load\r\n   */\r\n  public addResources(loadables: Loadable<any>[]) {\r\n    let i = 0;\r\n    const len = loadables.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this.addResource(loadables[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the loader has completely loaded all resources\r\n   */\r\n  public isLoaded() {\r\n    return this._numLoaded === this._resourceCount;\r\n  }\r\n\r\n  /**\r\n   * Shows the play button and returns a promise that resolves when clicked\r\n   */\r\n  public async showPlayButton(): Promise<void> {\r\n    if (this.suppressPlayButton) {\r\n      this.hidePlayButton();\r\n      // Delay is to give the logo a chance to show, otherwise don't delay\r\n      await delay(500, this._engine?.clock);\r\n    } else {\r\n      const resizeHandler = () => {\r\n        this._positionPlayButton();\r\n      };\r\n      if (this._engine?.browser) {\r\n        this._engine.browser.window.on('resize', resizeHandler);\r\n      }\r\n      this._playButtonShown = true;\r\n      this._playButton.style.display = 'block';\r\n      document.body.addEventListener('keyup', (evt: KeyboardEvent) => {\r\n        if (evt.key === 'Enter') {\r\n          this._playButton.click();\r\n        }\r\n      });\r\n      this._positionPlayButton();\r\n      const playButtonClicked = new Promise<void>((resolve) => {\r\n        const startButtonHandler = (e: Event) => {\r\n          // We want to stop propagation to keep bubbling to the engine pointer handlers\r\n          e.stopPropagation();\r\n          // Hide Button after click\r\n          this.hidePlayButton();\r\n          if (this._engine?.browser) {\r\n            this._engine.browser.window.off('resize', resizeHandler);\r\n          }\r\n          resolve();\r\n        };\r\n        this._playButton.addEventListener('click', startButtonHandler);\r\n        this._playButton.addEventListener('touchend', startButtonHandler);\r\n        this._playButton.addEventListener('pointerup', startButtonHandler);\r\n      });\r\n\r\n      return await playButtonClicked;\r\n    }\r\n  }\r\n\r\n  public hidePlayButton() {\r\n    this._playButtonShown = false;\r\n    this._playButton.style.display = 'none';\r\n  }\r\n\r\n  /**\r\n   * Clean up generated elements for the loader\r\n   */\r\n  public dispose() {\r\n    if (this._playButtonRootElement.parentElement) {\r\n      this._playButtonRootElement.removeChild(this._playButtonElement);\r\n      document.body.removeChild(this._playButtonRootElement);\r\n      document.head.removeChild(this._styleBlock);\r\n      this._playButtonRootElement = null;\r\n      this._playButtonElement = null;\r\n      this._styleBlock = null;\r\n    }\r\n  }\r\n\r\n  update(_engine: Engine, _delta: number): void {\r\n    // override me\r\n  }\r\n\r\n  data: Loadable<any>[];\r\n\r\n  private _loadingFuture = new Future<void>();\r\n  public areResourcesLoaded() {\r\n    return this._loadingFuture.promise;\r\n  }\r\n\r\n  /**\r\n   * Begin loading all of the supplied resources, returning a promise\r\n   * that resolves when loading of all is complete AND the user has clicked the \"Play button\"\r\n   */\r\n  public async load(): Promise<Loadable<any>[]> {\r\n    await this._image?.decode(); // decode logo if it exists\r\n    this.canvas.flagDirty();\r\n\r\n    await Promise.all(\r\n      this._resourceList.map(async (r) => {\r\n        await r.load().finally(() => {\r\n          // capture progress\r\n          this._numLoaded++;\r\n          this.canvas.flagDirty();\r\n        });\r\n      })\r\n    );\r\n    // Wire all sound to the engine\r\n    for (const resource of this._resourceList) {\r\n      if (resource instanceof Sound) {\r\n        resource.wireEngine(this._engine);\r\n      }\r\n    }\r\n\r\n    this._loadingFuture.resolve();\r\n\r\n    // short delay in showing the button for aesthetics\r\n    await delay(200, this._engine?.clock);\r\n    this.canvas.flagDirty();\r\n\r\n    await this.showPlayButton();\r\n    // Unlock browser AudioContext in after user gesture\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/262\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/1031\r\n    await WebAudio.unlock();\r\n\r\n    return (this.data = this._resourceList);\r\n  }\r\n\r\n  public markResourceComplete(): void {\r\n    this._numLoaded++;\r\n  }\r\n\r\n  /**\r\n   * Returns the progress of the loader as a number between [0, 1] inclusive.\r\n   */\r\n  public get progress(): number {\r\n    return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;\r\n  }\r\n\r\n  private _positionPlayButton() {\r\n    if (this._engine) {\r\n      const screenHeight = this._engine.screen.viewport.height;\r\n      const screenWidth = this._engine.screen.viewport.width;\r\n      if (this._playButtonRootElement) {\r\n        const left = this._engine.canvas.offsetLeft;\r\n        const top = this._engine.canvas.offsetTop;\r\n        const buttonWidth = this._playButton.clientWidth;\r\n        const buttonHeight = this._playButton.clientHeight;\r\n        if (this.playButtonPosition) {\r\n          this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;\r\n          this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;\r\n        } else {\r\n          this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;\r\n          this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loader draw function. Draws the default Excalibur loading screen.\r\n   * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties\r\n   * to customize the drawing, or just override entire method.\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D) {\r\n    const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;\r\n    const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;\r\n\r\n    this._positionPlayButton();\r\n\r\n    ctx.fillStyle = this.backgroundColor;\r\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    let logoY = canvasHeight / 2;\r\n    const width = Math.min(this.logoWidth, canvasWidth * 0.75);\r\n    let logoX = canvasWidth / 2 - width / 2;\r\n\r\n    if (this.logoPosition) {\r\n      logoX = this.logoPosition.x;\r\n      logoY = this.logoPosition.y;\r\n    }\r\n\r\n    const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor\r\n    const oldAntialias = this._engine.getAntialiasing();\r\n    this._engine.setAntialiasing(true);\r\n    if (!this.logoPosition) {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);\r\n    } else {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);\r\n    }\r\n\r\n    // loading box\r\n    if (!this.suppressPlayButton && this._playButtonShown) {\r\n      this._engine.setAntialiasing(oldAntialias);\r\n      return;\r\n    }\r\n\r\n    let loadingX = logoX;\r\n    let loadingY = logoY;\r\n    if (this.loadingBarPosition) {\r\n      loadingX = this.loadingBarPosition.x;\r\n      loadingY = this.loadingBarPosition.y;\r\n    }\r\n\r\n    ctx.lineWidth = 2;\r\n    DrawUtil.roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);\r\n    const progress = width * this.progress;\r\n    const margin = 5;\r\n    const progressWidth = progress - margin * 2;\r\n    const height = 20 - margin * 2;\r\n    DrawUtil.roundRect(\r\n      ctx,\r\n      loadingX + margin,\r\n      loadingY + margin,\r\n      progressWidth > 10 ? progressWidth : 10,\r\n      height,\r\n      5,\r\n      null,\r\n      this.loadingBarColor\r\n    );\r\n    this._engine.setAntialiasing(oldAntialias);\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n/**\r\n * This is the list of features that will be used to log the supported\r\n * features to the console when Detector.logBrowserFeatures() is called.\r\n */\r\n\r\nconst REPORTED_FEATURES: { [key: string]: string } = {\r\n  webgl: 'WebGL',\r\n  webaudio: 'WebAudio',\r\n  gamepadapi: 'Gamepad API'\r\n};\r\n\r\n/**\r\n * Interface for detected browser features matrix\r\n */\r\nexport interface DetectedFeatures {\r\n  readonly canvas: boolean;\r\n  readonly arraybuffer: boolean;\r\n  readonly dataurl: boolean;\r\n  readonly objecturl: boolean;\r\n  readonly rgba: boolean;\r\n  readonly webaudio: boolean;\r\n  readonly webgl: boolean;\r\n  readonly gamepadapi: boolean;\r\n}\r\n\r\ninterface CriticalTests {\r\n  canvasSupport(): boolean;\r\n  arrayBufferSupport(): boolean;\r\n  dataUrlSupport(): boolean;\r\n  objectUrlSupport(): boolean;\r\n  rgbaSupport(): boolean;\r\n}\r\n\r\ninterface WarningTests {\r\n  webAudioSupport(): boolean;\r\n  webglSupport(): boolean;\r\n}\r\n\r\n/**\r\n * Excalibur internal feature detection helper class\r\n */\r\nexport class Detector {\r\n  private _features: DetectedFeatures = null;\r\n\r\n  public failedTests: string[] = [];\r\n\r\n  public constructor() {\r\n    this._features = this._loadBrowserFeatures();\r\n  }\r\n\r\n  /**\r\n   * Returns a map of currently supported browser features. This method\r\n   * treats the features as a singleton and will only calculate feature\r\n   * support if it has not previously been done.\r\n   */\r\n  public getBrowserFeatures(): DetectedFeatures {\r\n    if (this._features === null) {\r\n      this._features = this._loadBrowserFeatures();\r\n    }\r\n    return this._features;\r\n  }\r\n\r\n  /**\r\n   * Report on non-critical browser support for debugging purposes.\r\n   * Use native browser console colors for visibility.\r\n   */\r\n  public logBrowserFeatures(): void {\r\n    let msg = '%cSUPPORTED BROWSER FEATURES\\n==========================%c\\n';\r\n    const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];\r\n\r\n    const supported: any = this.getBrowserFeatures();\r\n    for (const feature of Object.keys(REPORTED_FEATURES)) {\r\n      if (supported[feature]) {\r\n        msg += '(%c\\u2713%c)'; // ()\r\n        args.push('font-weight: bold; color: green');\r\n        args.push('font-weight: normal; color: inherit');\r\n      } else {\r\n        msg += '(%c\\u2717%c)'; // ()\r\n        args.push('font-weight: bold; color: red');\r\n        args.push('font-weight: normal; color: inherit');\r\n      }\r\n\r\n      msg += ' ' + REPORTED_FEATURES[feature] + '\\n';\r\n    }\r\n\r\n    args.unshift(msg);\r\n    // eslint-disable-next-line no-console\r\n    console.log.apply(console, args);\r\n  }\r\n\r\n  /**\r\n   * Executes several IIFE's to get a constant reference to supported\r\n   * features within the current execution context.\r\n   */\r\n  private _loadBrowserFeatures(): DetectedFeatures {\r\n    return {\r\n      // IIFE to check canvas support\r\n      canvas: (() => {\r\n        return this._criticalTests.canvasSupport();\r\n      })(),\r\n\r\n      // IIFE to check arraybuffer support\r\n      arraybuffer: (() => {\r\n        return this._criticalTests.arrayBufferSupport();\r\n      })(),\r\n\r\n      // IIFE to check dataurl support\r\n      dataurl: (() => {\r\n        return this._criticalTests.dataUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check objecturl support\r\n      objecturl: (() => {\r\n        return this._criticalTests.objectUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check rgba support\r\n      rgba: (() => {\r\n        return this._criticalTests.rgbaSupport();\r\n      })(),\r\n\r\n      // IIFE to check webaudio support\r\n      webaudio: (() => {\r\n        return this._warningTest.webAudioSupport();\r\n      })(),\r\n\r\n      // IIFE to check webgl support\r\n      webgl: (() => {\r\n        return this._warningTest.webglSupport();\r\n      })(),\r\n\r\n      // IIFE to check gamepadapi support\r\n      gamepadapi: (() => {\r\n        return !!(<any>navigator).getGamepads;\r\n      })()\r\n    };\r\n  }\r\n\r\n  // critical browser features required for ex to run\r\n  private _criticalTests: CriticalTests = {\r\n    // Test canvas/2d context support\r\n    canvasSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('2d'));\r\n    },\r\n\r\n    // Test array buffer support ex uses for downloading binary data\r\n    arrayBufferSupport: function() {\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open('GET', '/');\r\n      try {\r\n        xhr.responseType = 'arraybuffer';\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n      return xhr.responseType === 'arraybuffer';\r\n    },\r\n\r\n    // Test data urls ex uses for sprites\r\n    dataUrlSupport: function() {\r\n      const canvas = document.createElement('canvas');\r\n      return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;\r\n    },\r\n\r\n    // Test object url support for loading\r\n    objectUrlSupport: function() {\r\n      return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;\r\n    },\r\n\r\n    // RGBA support for colors\r\n    rgbaSupport: function() {\r\n      const style = document.createElement('a').style;\r\n      style.cssText = 'background-color:rgba(150,255,150,.5)';\r\n      return ('' + style.backgroundColor).indexOf('rgba') > -1;\r\n    }\r\n  };\r\n\r\n  // warnings excalibur performance will be degraded\r\n  private _warningTest: WarningTests = {\r\n    webAudioSupport: function() {\r\n      return !!(\r\n        (<any>window).AudioContext ||\r\n        (<any>window).webkitAudioContext ||\r\n        (<any>window).mozAudioContext ||\r\n        (<any>window).msAudioContext ||\r\n        (<any>window).oAudioContext\r\n      );\r\n    },\r\n    webglSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('webgl'));\r\n    }\r\n  };\r\n\r\n  public test(): boolean {\r\n    // Critical test will for ex not to run\r\n    let failedCritical = false;\r\n    for (const test in this._criticalTests) {\r\n      if (!this._criticalTests[<keyof CriticalTests>test].call(this)) {\r\n        this.failedTests.push(test);\r\n        Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);\r\n        failedCritical = true;\r\n      }\r\n    }\r\n    if (failedCritical) {\r\n      return false;\r\n    }\r\n\r\n    // Warning tests do not for ex to return false to compatibility\r\n    for (const warning in this._warningTest) {\r\n      if (!this._warningTest[<keyof WarningTests>warning]()) {\r\n        Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the types of collisions bodies can participate in\r\n */\r\nexport enum CollisionType {\r\n  /**\r\n   * Bodies with the `PreventCollision` setting do not participate in any\r\n   * collisions and do not raise collision events.\r\n   */\r\n  PreventCollision = 'PreventCollision',\r\n  /**\r\n   * Bodies with the `Passive` setting only raise collision events, but are not\r\n   * influenced or moved by other bodies and do not influence or move other bodies.\r\n   * This is useful for use in trigger type behavior.\r\n   */\r\n  Passive = 'Passive',\r\n  /**\r\n   * Bodies with the `Active` setting raise collision events and participate\r\n   * in collisions with other bodies and will be push or moved by bodies sharing\r\n   * the `Active` or `Fixed` setting.\r\n   */\r\n  Active = 'Active',\r\n  /**\r\n   * Bodies with the `Fixed` setting raise collision events and participate in\r\n   * collisions with other bodies. Actors with the `Fixed` setting will not be\r\n   * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed\r\n   * bodies as \"immovable/unstoppable\" objects. If two `Fixed` bodies meet they will\r\n   * not be pushed or moved by each other, they will not interact except to throw\r\n   * collision events.\r\n   */\r\n  Fixed = 'Fixed'\r\n}\r\n","import { Flags } from '../Flags';\r\nimport { Logger } from './Log';\r\n\r\n/**\r\n * Obsolete decorator options\r\n */\r\nexport interface ObsoleteOptions {\r\n  // Optionally specify a custom message\r\n  message?: string;\r\n  // Optionally indicate that an alternate method to the obsolete one exists\r\n  alternateMethod?: string;\r\n  // Optional show stack trace, by default off\r\n  showStackTrace?: boolean;\r\n}\r\n\r\nexport const maxMessages = 5;\r\nconst obsoleteMessage: { [messageCount: string]: number } = {};\r\nexport const resetObsoleteCounter = () => {\r\n  for (const message in obsoleteMessage) {\r\n    obsoleteMessage[message] = 0;\r\n  }\r\n};\r\n\r\nconst logMessage = (message: string, options: ObsoleteOptions) => {\r\n  const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');\r\n  if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {\r\n    Logger.getInstance().warn(message);\r\n\r\n    // tslint:disable-next-line: no-console\r\n    if (console.trace && options.showStackTrace) {\r\n      // tslint:disable-next-line: no-console\r\n      console.trace();\r\n    }\r\n  }\r\n  obsoleteMessage[message]++;\r\n};\r\n\r\n/**\r\n * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement\r\n * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js\r\n */\r\nexport function obsolete(options?: ObsoleteOptions): any {\r\n  options = {\r\n    message: 'This feature will be removed in future versions of Excalibur.',\r\n    alternateMethod: null,\r\n    showStackTrace: false,\r\n    ...options\r\n  };\r\n\r\n  return function (target: any, property: string, descriptor: PropertyDescriptor): any {\r\n    if (\r\n      descriptor &&\r\n      !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')\r\n    ) {\r\n      throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');\r\n    }\r\n    const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;\r\n\r\n    const message =\r\n      `${methodSignature} is marked obsolete: ${options.message}` +\r\n      (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');\r\n\r\n    if (!obsoleteMessage[message]) {\r\n      obsoleteMessage[message] = 0;\r\n    }\r\n\r\n    // If descriptor is null it is a class\r\n    const method = descriptor ? { ...descriptor } : target;\r\n    if (!descriptor) {\r\n      // with es2015 classes we need to change our decoration tactic\r\n      class DecoratedClass extends method {\r\n        constructor(...args: any) {\r\n          logMessage(message, options);\r\n          super(...args);\r\n        }\r\n      }\r\n      return DecoratedClass;\r\n    }\r\n\r\n    if (descriptor && descriptor.value) {\r\n      method.value = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.value.apply(this, arguments);\r\n      };\r\n      return method;\r\n    }\r\n\r\n    if (descriptor && descriptor.get) {\r\n      method.get = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.get.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    if (descriptor && descriptor.set) {\r\n      method.set = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.set.apply(this, arguments);\r\n      };\r\n    }\r\n    return method;\r\n  };\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n\r\n/**\r\n * Possible collision resolution strategies\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things\r\n * like platformers or top down games.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */\r\nexport enum CollisionResolutionStrategy {\r\n  Arcade = 'arcade',\r\n  Realistic = 'realistic'\r\n}\r\n\r\n/**\r\n * Possible broadphase collision pair identification strategies\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */\r\nexport enum BroadphaseStrategy {\r\n  DynamicAABBTree\r\n}\r\n\r\n/**\r\n * Possible numerical integrators for position and velocity\r\n */\r\nexport enum Integrator {\r\n  Euler\r\n}\r\n\r\n/**\r\n * The [[Physics]] object is the global configuration object for all Excalibur physics.\r\n */\r\n/* istanbul ignore next */\r\nexport class Physics {\r\n  /**\r\n   * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.\r\n   * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.\r\n   *\r\n   * This is a great way to globally simulate effects like gravity.\r\n   */\r\n  public static acc = new Vector(0, 0);\r\n  public static get gravity() {\r\n    return Physics.acc;\r\n  }\r\n  public static set gravity(v: Vector) {\r\n    Physics.acc = v;\r\n  }\r\n\r\n  /**\r\n   * Globally switches all Excalibur physics behavior on or off.\r\n   */\r\n  public static enabled = true;\r\n\r\n  /**\r\n   * Gets or sets the broadphase pair identification strategy.\r\n   *\r\n   * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n   * potential collision pairs which is O(nlog(n)) faster.\r\n   */\r\n  public static broadphaseStrategy: BroadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;\r\n\r\n  /**\r\n   * Gets or sets the global collision resolution strategy (narrowphase).\r\n   *\r\n   * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.\r\n   *\r\n   * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static collisionResolutionStrategy: CollisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  /**\r\n   * The default mass to use if none is specified\r\n   */\r\n  public static defaultMass: number = 10;\r\n  /**\r\n   * Gets or sets the position and velocity positional integrator, currently only Euler is supported.\r\n   */\r\n  public static integrator: Integrator = Integrator.Euler;\r\n\r\n  /**\r\n   * Configures Excalibur to use \"arcade\" physics. Arcade physics which performs simple axis aligned arcade style physics.\r\n   */\r\n  public static useArcadePhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  }\r\n\r\n  /**\r\n   * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static useRealisticPhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;\r\n  }\r\n\r\n  /**\r\n   * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);\r\n   */\r\n  public static dynamicTreeVelocityMultiplier = 2;\r\n\r\n  @obsolete({\r\n    message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',\r\n    alternateMethod: 'dynamicTreeVelocityMultiplier'\r\n  })\r\n  public static get dynamicTreeVelocityMultiplyer() {\r\n    return Physics.dynamicTreeVelocityMultiplier;\r\n  }\r\n\r\n  public static set dynamicTreeVelocityMultiplyer(value: number) {\r\n    Physics.dynamicTreeVelocityMultiplier = value;\r\n  }\r\n\r\n  /**\r\n   * Pad RigidBody BoundingBox by a constant amount\r\n   */\r\n  public static boundsPadding = 5;\r\n\r\n  /**\r\n   * Number of position iterations (overlap) to run in the solver\r\n   */\r\n  public static positionIterations = 3;\r\n\r\n  /**\r\n   * Number of velocity iteration (response) to run in the solver\r\n   */\r\n  public static velocityIterations = 8;\r\n\r\n  /**\r\n   * Amount of overlap to tolerate in pixels\r\n   */\r\n  public static slop = 1;\r\n\r\n  /**\r\n   * Amount of positional overlap correction to apply each position iteration of the solver\r\n   * O - meaning no correction, 1 - meaning correct all overlap\r\n   */\r\n  public static steeringFactor = 0.2;\r\n\r\n  /**\r\n   * Warm start set to true re-uses impulses from previous frames back in the solver\r\n   */\r\n  public static warmStart = true;\r\n\r\n  /**\r\n   * By default bodies do not sleep\r\n   */\r\n  public static bodiesCanSleepByDefault = false;\r\n\r\n  /**\r\n   * Surface epsilon is used to help deal with surface penetration\r\n   */\r\n  public static surfaceEpsilon = 0.1;\r\n\r\n  public static sleepEpsilon = 0.07;\r\n\r\n  public static wakeThreshold = Physics.sleepEpsilon * 3;\r\n\r\n  public static sleepBias = 0.9;\r\n\r\n  /**\r\n   * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent\r\n   * bodies from tunneling through one another.\r\n   */\r\n  public static checkForFastBodies = true;\r\n\r\n  /**\r\n   * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the\r\n   * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,\r\n   * Excalibur will always perform the fast body raycast regardless of speed.\r\n   */\r\n  public static disableMinimumSpeedForFastBody = false;\r\n}\r\n","/**\r\n * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]\r\n */\r\nexport enum CoordPlane {\r\n  /**\r\n   * The world coordinate plane (default) represents world space, any entities drawn with world\r\n   * space move when the camera moves.\r\n   */\r\n  World = 'world',\r\n  /**\r\n   * The screen coordinate plane represents screen space, entities drawn in screen space are pinned\r\n   * to screen coordinates ignoring the camera.\r\n   */\r\n  Screen = 'screen'\r\n}","import { Vector } from './vector';\r\n\r\nexport interface VectorViewOptions {\r\n  getX: () => number;\r\n  getY: () => number;\r\n  setX: (x: number) => void;\r\n  setY: (y: number) => void;\r\n}\r\nexport class VectorView extends Vector {\r\n  private _getX: () => number;\r\n  private _getY: () => number;\r\n  private _setX: (x: number) => void;\r\n  private _setY: (y: number) => void;\r\n  constructor(options: VectorViewOptions) {\r\n    super(0, 0);\r\n    this._getX = options.getX;\r\n    this._getY = options.getY;\r\n    this._setX = options.setX;\r\n    this._setY = options.setY;\r\n  }\r\n  public get x() {\r\n    return (this._x = this._getX());\r\n  }\r\n\r\n  public set x(val) {\r\n    this._setX(val);\r\n    this._x = val;\r\n  }\r\n\r\n  public get y() {\r\n    return (this._y = this._getY());\r\n  }\r\n  public set y(val) {\r\n    this._setY(val);\r\n    this._y = val;\r\n  }\r\n}\r\n","import { Vector } from './vector';\r\n\r\n/**\r\n * Wraps a vector and watches for changes in the x/y, modifies the original vector.\r\n */\r\nexport class WatchVector extends Vector {\r\n  constructor(public original: Vector, public change: (x: number, y: number) => any) {\r\n    super(original.x, original.y);\r\n  }\r\n  public get x() {\r\n    return this._x = this.original.x;\r\n  }\r\n\r\n  public set x(newX: number) {\r\n    this.change(newX, this._y);\r\n    this._x = this.original.x = newX;\r\n  }\r\n\r\n  public get y() {\r\n    return this._y = this.original.y;\r\n  }\r\n\r\n  public set y(newY: number) {\r\n    this.change(this._x, newY);\r\n    this._y = this.original.y = newY;\r\n  }\r\n}","import { AffineMatrix } from './affine-matrix';\r\nimport { canonicalizeAngle } from './util';\r\nimport { vec, Vector } from './vector';\r\nimport { VectorView } from './vector-view';\r\nimport { WatchVector } from './watch-vector';\r\n\r\nexport class Transform {\r\n  private _parent: Transform | null = null;\r\n  get parent() {\r\n    return this._parent;\r\n  }\r\n  set parent(transform: Transform) {\r\n    if (this._parent) {\r\n      const index = this._parent._children.indexOf(this);\r\n      if (index > -1) {\r\n        this._parent._children.splice(index, 1);\r\n      }\r\n    }\r\n    this._parent = transform;\r\n    if (this._parent) {\r\n      this._parent._children.push(this);\r\n    }\r\n    this.flagDirty();\r\n  }\r\n  get children(): readonly Transform[] {\r\n    return this._children;\r\n  }\r\n  private _children: Transform[] = [];\r\n\r\n  private _pos: Vector = vec(0, 0);\r\n  set pos(v: Vector) {\r\n    if (!v.equals(this._pos)) {\r\n      this._pos.x = v.x;\r\n      this._pos.y = v.y;\r\n      this.flagDirty();\r\n    }\r\n  }\r\n  get pos() {\r\n    return new WatchVector(this._pos, (x, y) => {\r\n      if (x !== this._pos.x || y !== this._pos.y) {\r\n        this.flagDirty();\r\n      }\r\n    });\r\n  }\r\n\r\n  set globalPos(v: Vector) {\r\n    let localPos = v.clone();\r\n    if (this.parent) {\r\n      localPos = this.parent.inverse.multiply(v);\r\n    }\r\n    if (!localPos.equals(this._pos)) {\r\n      this._pos = localPos;\r\n      this.flagDirty();\r\n    }\r\n  }\r\n  get globalPos() {\r\n    return new VectorView({\r\n      getX: () => this.matrix.data[4],\r\n      getY: () => this.matrix.data[5],\r\n      setX: (x) => {\r\n        if (this.parent) {\r\n          const { x: newX } = this.parent.inverse.multiply(vec(x, this.pos.y));\r\n          this.pos.x = newX;\r\n        } else {\r\n          this.pos.x = x;\r\n        }\r\n        if (x !== this.matrix.data[4]) {\r\n          this.flagDirty();\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        if (this.parent) {\r\n          const { y: newY } = this.parent.inverse.multiply(vec(this.pos.x, y));\r\n          this.pos.y = newY;\r\n        } else {\r\n          this.pos.y = y;\r\n        }\r\n        if (y !== this.matrix.data[5]) {\r\n          this.flagDirty();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private _rotation: number = 0;\r\n  set rotation(rotation: number) {\r\n    const canonRotation = canonicalizeAngle(rotation);\r\n    if (canonRotation !== this._rotation) {\r\n      this.flagDirty();\r\n    }\r\n    this._rotation = canonRotation;\r\n  }\r\n  get rotation() {\r\n    return this._rotation;\r\n  }\r\n\r\n  set globalRotation(rotation: number) {\r\n    let inverseRotation = 0;\r\n    if (this.parent) {\r\n      inverseRotation = this.parent.globalRotation;\r\n    }\r\n    const canonRotation = canonicalizeAngle(rotation + inverseRotation);\r\n    if (canonRotation !== this._rotation) {\r\n      this.flagDirty();\r\n    }\r\n    this._rotation = canonRotation;\r\n  }\r\n\r\n  get globalRotation() {\r\n    if (this.parent) {\r\n      return this.matrix.getRotation();\r\n    }\r\n    return this.rotation;\r\n  }\r\n\r\n  private _scale: Vector = vec(1, 1);\r\n  set scale(v: Vector) {\r\n    if (!v.equals(this._scale)) {\r\n      this._scale.x = v.x;\r\n      this._scale.y = v.y;\r\n      this.flagDirty();\r\n    }\r\n  }\r\n  get scale() {\r\n    return new WatchVector(this._scale, (x, y) => {\r\n      if (x !== this._scale.x || y !== this._scale.y) {\r\n        this.flagDirty();\r\n      }\r\n    });\r\n  }\r\n\r\n  set globalScale(v: Vector) {\r\n    let inverseScale = vec(1, 1);\r\n    if (this.parent) {\r\n      inverseScale = this.parent.globalScale;\r\n    }\r\n    this.scale = v.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));\r\n  }\r\n\r\n  get globalScale() {\r\n    return new VectorView({\r\n      getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,\r\n      getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,\r\n      setX: (x) => {\r\n        if (this.parent) {\r\n          const globalScaleX = this.parent.globalScale.x;\r\n          this.scale.x = x / globalScaleX;\r\n        } else {\r\n          this.scale.x = x;\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        if (this.parent) {\r\n          const globalScaleY = this.parent.globalScale.y;\r\n          this.scale.y = y / globalScaleY;\r\n        } else {\r\n          this.scale.y = y;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private _isDirty = false;\r\n  private _isInverseDirty = false;\r\n  private _matrix = AffineMatrix.identity();\r\n  private _inverse = AffineMatrix.identity();\r\n\r\n  public get matrix() {\r\n    if (this._isDirty) {\r\n      if (this.parent === null) {\r\n        this._matrix = this._calculateMatrix();\r\n      } else {\r\n        this._matrix = this.parent.matrix.multiply(this._calculateMatrix());\r\n      }\r\n      this._isDirty = false;\r\n    }\r\n    return this._matrix;\r\n  }\r\n\r\n  public get inverse() {\r\n    if (this._isInverseDirty) {\r\n      this._inverse = this.matrix.inverse();\r\n      this._isInverseDirty = false;\r\n    }\r\n    return this._inverse;\r\n  }\r\n\r\n  private _calculateMatrix(): AffineMatrix {\r\n    const matrix = AffineMatrix.identity()\r\n      .translate(this.pos.x, this.pos.y)\r\n      .rotate(this.rotation)\r\n      .scale(this.scale.x, this.scale.y);\r\n    return matrix;\r\n  }\r\n\r\n\r\n  public flagDirty() {\r\n    this._isDirty = true;\r\n    this._isInverseDirty = true;\r\n    for (let i = 0; i < this._children.length; i ++) {\r\n      this._children[i].flagDirty();\r\n    }\r\n  }\r\n\r\n  public apply(point: Vector): Vector {\r\n    return this.matrix.multiply(point);\r\n  }\r\n\r\n  public applyInverse(point: Vector): Vector {\r\n    return this.inverse.multiply(point);\r\n  }\r\n\r\n  public setTransform(pos: Vector, rotation: number, scale: Vector) {\r\n    this._pos.x = pos.x;\r\n    this._pos.y = pos.y;\r\n    this._rotation = canonicalizeAngle(rotation);\r\n    this._scale.x = scale.x;\r\n    this._scale.y = scale.y;\r\n    this.flagDirty();\r\n  }\r\n\r\n  public clone(dest?: Transform) {\r\n    const target = dest ?? new Transform();\r\n    this._pos.clone(target._pos);\r\n    target._rotation = this._rotation;\r\n    this._scale.clone(target._scale);\r\n    target.flagDirty();\r\n  }\r\n}","import { Entity } from './Entity';\r\n\r\n/**\r\n * Component Contructor Types\r\n */\r\nexport declare type ComponentCtor<T extends Component = Component> = new (...args:any[]) => T;\r\n\r\n/**\r\n * Type guard to check if a component implements clone\r\n * @param x\r\n */\r\nfunction hasClone(x: any): x is { clone(): any } {\r\n  return !!x?.clone;\r\n}\r\n\r\nexport type ComponentType<ComponentToParse> = ComponentToParse extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * Plucks the string type out of a component type\r\n */\r\nexport type ComponentStringType<T> = T extends Component<infer R> ? R : string;\r\n\r\n/**\r\n * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses\r\n *\r\n * Implementations of Component must have a zero-arg constructor to support dependencies\r\n *\r\n * ```typescript\r\n * class MyComponent extends ex.Component<'my'> {\r\n *   public readonly type = 'my';\r\n *   // zero arg support required if you want to use component dependencies\r\n *   constructor(public optionalPos?: ex.Vector) {}\r\n * }\r\n * ```\r\n */\r\nexport abstract class Component<TypeName extends string = string> {\r\n  /**\r\n   * Optionally list any component types this component depends on\r\n   * If the owner entity does not have these components, new components will be added to the entity\r\n   *\r\n   * Only components with zero-arg constructors are supported as automatic component dependencies\r\n   */\r\n  readonly dependencies?: ComponentCtor[];\r\n\r\n  // todo implement optional\r\n  readonly optional?: ComponentCtor[];\r\n\r\n  /**\r\n   * Type of this component, must be a unique type among component types in you game.\r\n   */\r\n  abstract readonly type: TypeName;\r\n\r\n  /**\r\n   * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]\r\n   */\r\n  owner?: Entity = null;\r\n\r\n  /**\r\n   * Clones any properties on this component, if that property value has a `clone()` method it will be called\r\n   */\r\n  clone(): this {\r\n    const newComponent = new (this.constructor as any)();\r\n    for (const prop in this) {\r\n      if (this.hasOwnProperty(prop)) {\r\n        const val = this[prop];\r\n        if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {\r\n          newComponent[prop] = val.clone();\r\n        } else {\r\n          newComponent[prop] = val;\r\n        }\r\n      }\r\n    }\r\n    return newComponent;\r\n  }\r\n\r\n  /**\r\n   * Optional callback called when a component is added to an entity\r\n   */\r\n  onAdd?(owner: Entity): void;\r\n\r\n  /**\r\n   * Optional callback called when a component is added to an entity\r\n   */\r\n  onRemove?(previousOwner: Entity): void;\r\n}\r\n\r\n/**\r\n * Tag components are a way of tagging a component with label and a simple value\r\n *\r\n * For example:\r\n *\r\n * ```typescript\r\n * const isOffscreen = new TagComponent('offscreen');\r\n * entity.addComponent(isOffscreen);\r\n * entity.tags.includes\r\n * ```\r\n */\r\nexport class TagComponent<TypeName extends string, MaybeValueType extends string | symbol | number | boolean = never> extends Component<\r\nTypeName\r\n> {\r\n  constructor(public readonly type: TypeName, public readonly value?: MaybeValueType) {\r\n    super();\r\n  }\r\n}\r\n","/**\r\n * Defines a generic message that can contain any data\r\n * @template T is the typescript Type of the data\r\n */\r\nexport interface Message<T> {\r\n  type: string;\r\n  data: T;\r\n}\r\n\r\n/**\r\n * Defines an interface for an observer to receive a message via a notify() method\r\n */\r\nexport interface Observer<T> {\r\n  notify(message: T): void;\r\n}\r\n\r\n/**\r\n * Defines an interface for something that might be an observer if a notify() is present\r\n */\r\nexport type MaybeObserver<T> = Partial<Observer<T>>;\r\n\r\n/**\r\n * Simple Observable implementation\r\n * @template T is the typescript Type that defines the data being observed\r\n */\r\nexport class Observable<T> {\r\n  public observers: Observer<T>[] = [];\r\n  public subscriptions: ((val: T) => any)[] = [];\r\n\r\n  /**\r\n   * Register an observer to listen to this observable\r\n   * @param observer\r\n   */\r\n  register(observer: Observer<T>) {\r\n    this.observers.push(observer);\r\n  }\r\n\r\n  /**\r\n   * Register a callback to listen to this observable\r\n   * @param func\r\n   */\r\n  subscribe(func: (val: T) => any) {\r\n    this.subscriptions.push(func);\r\n  }\r\n\r\n  /**\r\n   * Remove an observer from the observable\r\n   * @param observer\r\n   */\r\n  unregister(observer: Observer<T>) {\r\n    const i = this.observers.indexOf(observer);\r\n    if (i !== -1) {\r\n      this.observers.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a callback that is listening to this observable\r\n   * @param func\r\n   */\r\n  unsubscribe(func: (val: T) => any) {\r\n    const i = this.subscriptions.indexOf(func);\r\n    if (i !== -1) {\r\n      this.subscriptions.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcasts a message to all observers and callbacks\r\n   * @param message\r\n   */\r\n  notifyAll(message: T) {\r\n    const observersLength = this.observers.length;\r\n    for (let i = 0; i < observersLength; i++) {\r\n      this.observers[i].notify(message);\r\n    }\r\n    const subscriptionsLength = this.subscriptions.length;\r\n    for (let i = 0; i < subscriptionsLength; i++) {\r\n      this.subscriptions[i](message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all observers and callbacks\r\n   */\r\n  clear() {\r\n    this.observers.length = 0;\r\n    this.subscriptions.length = 0;\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { CoordPlane } from '../../Math/coord-plane';\r\nimport { Transform } from '../../Math/transform';\r\nimport { Component } from '../Component';\r\nimport { Entity } from '../Entity';\r\nimport { Observable } from '../../Util/Observable';\r\n\r\n\r\nexport class TransformComponent extends Component<'ex.transform'> {\r\n  public readonly type = 'ex.transform';\r\n\r\n  private _transform = new Transform();\r\n  public get() {\r\n    return this._transform;\r\n  }\r\n\r\n  private _addChildTransform = (child: Entity) => {\r\n    const childTxComponent = child.get(TransformComponent);\r\n    if (childTxComponent) {\r\n      childTxComponent._transform.parent = this._transform;\r\n    }\r\n  };\r\n  onAdd(owner: Entity): void {\r\n    for (const child of owner.children) {\r\n      this._addChildTransform(child);\r\n    }\r\n    owner.childrenAdded$.subscribe(child => this._addChildTransform(child));\r\n    owner.childrenRemoved$.subscribe(child => {\r\n      const childTxComponent = child.get(TransformComponent);\r\n      if (childTxComponent) {\r\n        childTxComponent._transform.parent = null;\r\n      }\r\n    });\r\n  }\r\n  onRemove(_previousOwner: Entity): void {\r\n    this._transform.parent = null;\r\n  }\r\n\r\n  /**\r\n   * Observable that emits when the z index changes on this component\r\n   */\r\n  public zIndexChanged$ = new Observable<number>();\r\n  private _z = 0;\r\n\r\n  /**\r\n   * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n   * For example z=99 would be drawn on top of z=0.\r\n   */\r\n  public get z(): number {\r\n    return this._z;\r\n  }\r\n\r\n  public set z(val: number) {\r\n    const oldz = this._z;\r\n    this._z = val;\r\n    if (oldz !== val) {\r\n      this.zIndexChanged$.notifyAll(val);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The [[CoordPlane|coordinate plane|]] for this transform for the entity.\r\n   */\r\n  public coordPlane = CoordPlane.World;\r\n\r\n  get pos() {\r\n    return this._transform.pos;\r\n  }\r\n  set pos(v: Vector) {\r\n    this._transform.pos = v;\r\n  }\r\n\r\n  get globalPos() {\r\n    return this._transform.globalPos;\r\n  }\r\n  set globalPos(v: Vector) {\r\n    this._transform.globalPos = v;\r\n  }\r\n\r\n  get rotation() {\r\n    return this._transform.rotation;\r\n  }\r\n  set rotation(rotation) {\r\n    this._transform.rotation = rotation;\r\n  }\r\n\r\n  get globalRotation() {\r\n    return this._transform.globalRotation;\r\n  }\r\n  set globalRotation(rotation) {\r\n    this._transform.globalRotation = rotation;\r\n  }\r\n\r\n  get scale() {\r\n    return this._transform.scale;\r\n  }\r\n  set scale(v: Vector) {\r\n    this._transform.scale = v;\r\n  }\r\n\r\n  get globalScale() {\r\n    return this._transform.globalScale;\r\n  }\r\n  set globalScale(v: Vector) {\r\n    this._transform.globalScale = v;\r\n  }\r\n\r\n  applyInverse(v: Vector) {\r\n    return this._transform.applyInverse(v);\r\n  }\r\n\r\n  apply(v: Vector) {\r\n    return this._transform.apply(v);\r\n  }\r\n}","import { Vector } from '../../Math/vector';\r\nimport { Component } from '../Component';\r\n\r\nexport interface Motion {\r\n  /**\r\n   * The velocity of an entity in pixels per second\r\n   */\r\n  vel: Vector;\r\n\r\n  /**\r\n   * The acceleration of entity in pixels per second^2\r\n   */\r\n  acc: Vector;\r\n\r\n  /**\r\n   * The scale rate of change in scale units per second\r\n   */\r\n  scaleFactor: Vector;\r\n\r\n  /**\r\n   * The angular velocity which is how quickly the entity is rotating in radians per second\r\n   */\r\n  angularVelocity: number;\r\n\r\n  /**\r\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n   */\r\n  torque: number;\r\n\r\n  /**\r\n   * Inertia can be thought of as the resistance to motion\r\n   */\r\n  inertia: number;\r\n}\r\n\r\nexport class MotionComponent extends Component<'ex.motion'> {\r\n  public readonly type = 'ex.motion';\r\n\r\n  /**\r\n   * The velocity of an entity in pixels per second\r\n   */\r\n  public vel: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The acceleration of entity in pixels per second^2\r\n   */\r\n  public acc: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The scale rate of change in scale units per second\r\n   */\r\n  public scaleFactor: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The angular velocity which is how quickly the entity is rotating in radians per second\r\n   */\r\n  public angularVelocity = 0;\r\n\r\n  /**\r\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n   */\r\n  public torque: number = 0;\r\n\r\n  /**\r\n   * Inertia can be thought of as the resistance to motion\r\n   */\r\n  public inertia: number = 1;\r\n}\r\n","/**\r\n * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s\r\n *\r\n * For example:\r\n *\r\n * Players have collision group \"player\"\r\n *\r\n * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)\r\n *\r\n * Enemies have collision group \"enemy\"\r\n *\r\n * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)\r\n *\r\n * Blocks have collision group \"ground\"\r\n *\r\n * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)\r\n *\r\n * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide\r\n * with players and blocks.\r\n *\r\n * This is done with bitmasking, see the following pseudo-code\r\n *\r\n * PlayerGroup = `0b001`\r\n * PlayerGroupMask = `0b110`\r\n *\r\n * EnemyGroup = `0b010`\r\n * EnemyGroupMask = `0b101`\r\n *\r\n * BlockGroup = `0b100`\r\n * BlockGroupMask = `0b011`\r\n *\r\n * Should Players collide? No because the bitwise mask evaluates to 0\r\n * `(player1.group & player2.mask) === 0`\r\n * `(0b001 & 0b110) === 0`\r\n *\r\n * Should Players and Enemies collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & enemy1.mask) === 1`\r\n * `(0b001 & 0b101) === 1`\r\n *\r\n * Should Players and Blocks collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & blocks1.mask) === 1`\r\n * `(0b001 & 0b011) === 1`\r\n */\r\nexport class CollisionGroup {\r\n  /**\r\n   * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,\r\n   * it is the default collision group on colliders.\r\n   */\r\n  public static All = new CollisionGroup('Collide with all groups', -1, -1);\r\n\r\n  private _name: string;\r\n  private _category: number;\r\n  private _mask: number;\r\n\r\n  /**\r\n   * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups\r\n   *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.\r\n   * @param name Name of the collision group\r\n   * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`\r\n   * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`\r\n   */\r\n  constructor(name: string, category: number, mask: number) {\r\n    this._name = name;\r\n    this._category = category;\r\n    this._mask = mask;\r\n  }\r\n\r\n  /**\r\n   * Get the name of the collision group\r\n   */\r\n  public get name() {\r\n    return this._name;\r\n  }\r\n\r\n  /**\r\n   * Get the category of the collision group, a 32 bit number which should be a unique power of 2\r\n   */\r\n  public get category() {\r\n    return this._category;\r\n  }\r\n\r\n  /**\r\n   * Get the mask for this collision group\r\n   */\r\n  public get mask() {\r\n    return this._mask;\r\n  }\r\n\r\n  /**\r\n   * Evaluates whether 2 collision groups can collide\r\n   * @param other  CollisionGroup\r\n   */\r\n  public canCollide(other: CollisionGroup): boolean {\r\n    return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;\r\n  }\r\n\r\n  /**\r\n   * Inverts the collision group. For example, if before the group specified \"players\",\r\n   * inverting would specify all groups except players\r\n   * @returns CollisionGroup\r\n   */\r\n  public invert(): CollisionGroup {\r\n    return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);\r\n  }\r\n\r\n  /**\r\n   * Combine collision groups with each other. The new group includes all of the previous groups.\r\n   *\r\n   * @param collisionGroups\r\n   */\r\n  public static combine(collisionGroups: CollisionGroup[]) {\r\n    const combinedName = collisionGroups.map((c) => c.name).join('+');\r\n    const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);\r\n    const combinedMask = ~combinedCategory;\r\n\r\n    return new CollisionGroup(combinedName, combinedCategory, combinedMask);\r\n  }\r\n\r\n  /**\r\n   * Creates a collision group that collides with the listed groups\r\n   * @param collisionGroups\r\n   */\r\n  public static collidesWith(collisionGroups: CollisionGroup[]) {\r\n    return CollisionGroup.combine(collisionGroups).invert();\r\n  }\r\n}\r\n","import { CollisionContact } from './CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Id } from '../../Id';\r\nimport { Collider } from '../Colliders/Collider';\r\n\r\n/**\r\n * Models a potential collision between 2 colliders\r\n */\r\nexport class Pair {\r\n  public id: string = null;\r\n  constructor(public colliderA: Collider, public colliderB: Collider) {\r\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n  }\r\n\r\n  /**\r\n   * Returns whether a it is allowed for 2 colliders in a Pair to collide\r\n   * @param colliderA\r\n   * @param colliderB\r\n   */\r\n  public static canCollide(colliderA: Collider, colliderB: Collider) {\r\n    const bodyA = colliderA?.owner?.get(BodyComponent);\r\n    const bodyB = colliderB?.owner?.get(BodyComponent);\r\n\r\n    // Prevent self collision\r\n    if (colliderA.id === colliderB.id) {\r\n      return false;\r\n    }\r\n\r\n    // Colliders with the same owner do not collide (composite colliders)\r\n    if (colliderA.owner &&\r\n        colliderB.owner &&\r\n        colliderA.owner.id === colliderB.owner.id) {\r\n      return false;\r\n    }\r\n\r\n    // if the pair has a member with zero dimension don't collide\r\n    if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {\r\n      return false;\r\n    }\r\n\r\n    // Body's needed for collision in the current state\r\n    // TODO can we collide without a body?\r\n    if (!bodyA || !bodyB) {\r\n      return false;\r\n    }\r\n\r\n    // If both are in the same collision group short circuit\r\n    if (!bodyA.group.canCollide(bodyB.group)) {\r\n      return false;\r\n    }\r\n\r\n    // if both are fixed short circuit\r\n    if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {\r\n      return false;\r\n    }\r\n\r\n    // if the either is prevent collision short circuit\r\n    if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {\r\n      return false;\r\n    }\r\n\r\n    // if either is dead short circuit\r\n    if (!bodyA.active || !bodyB.active) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not it is possible for the pairs to collide\r\n   */\r\n  public get canCollide(): boolean {\r\n    const colliderA = this.colliderA;\r\n    const colliderB = this.colliderB;\r\n    return Pair.canCollide(colliderA, colliderB);\r\n  }\r\n\r\n  /**\r\n   * Runs the collision intersection logic on the members of this pair\r\n   */\r\n  public collide(): CollisionContact[] {\r\n    return this.colliderA.collide(this.colliderB);\r\n  }\r\n\r\n  /**\r\n   * Check if the collider is part of the pair\r\n   * @param collider\r\n   */\r\n  public hasCollider(collider: Collider) {\r\n    return collider === this.colliderA || collider === this.colliderB;\r\n  }\r\n\r\n  /**\r\n   * Calculates the unique pair hash id for this collision pair (owning id)\r\n   */\r\n  public static calculatePairHash(idA: Id<'collider'>, idB: Id<'collider'>): string {\r\n    if (idA.value < idB.value) {\r\n      return `#${idA.value}+${idB.value}`;\r\n    } else {\r\n      return `#${idB.value}+${idA.value}`;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * A 1 dimensional projection on an axis, used to test overlaps\r\n */\r\n\r\nexport class Projection {\r\n  constructor(public min: number, public max: number) {}\r\n  public overlaps(projection: Projection): boolean {\r\n    return this.max > projection.min && projection.max > this.min;\r\n  }\r\n\r\n  public getOverlap(projection: Projection): number {\r\n    if (this.overlaps(projection)) {\r\n      if (this.max > projection.max) {\r\n        return projection.max - this.min;\r\n      } else {\r\n        return this.max - projection.min;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n","import { Physics } from '../Physics';\r\nimport { BoundingBox } from '../BoundingBox';\r\n\r\nimport { Ray } from '../../Math/ray';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Id } from '../../Id';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Color, ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Dynamic Tree Node used for tracking bounds within the tree\r\n */\r\nexport class TreeNode<T> {\r\n  public left: TreeNode<T>;\r\n  public right: TreeNode<T>;\r\n  public bounds: BoundingBox;\r\n  public height: number;\r\n  public data: T;\r\n  constructor(public parent?: TreeNode<T>) {\r\n    this.parent = parent || null;\r\n    this.data = null;\r\n    this.bounds = new BoundingBox();\r\n    this.left = null;\r\n    this.right = null;\r\n    this.height = 0;\r\n  }\r\n\r\n  public isLeaf(): boolean {\r\n    return !this.left && !this.right;\r\n  }\r\n}\r\n\r\nexport interface ColliderProxy<T> {\r\n  id: Id<'collider'>;\r\n  owner: T;\r\n  bounds: BoundingBox;\r\n}\r\n\r\n/**\r\n * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for\r\n * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.\r\n *\r\n * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.\r\n * Every non-leaf node is a bounding box that contains child bounding boxes.\r\n */\r\nexport class DynamicTree<T extends ColliderProxy<Entity>> {\r\n  public root: TreeNode<T>;\r\n  public nodes: { [key: number]: TreeNode<T> };\r\n  constructor(public worldBounds: BoundingBox = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {\r\n    this.root = null;\r\n    this.nodes = {};\r\n  }\r\n\r\n  /**\r\n   * Inserts a node into the dynamic tree\r\n   */\r\n  private _insert(leaf: TreeNode<T>): void {\r\n    // If there are no nodes in the tree, make this the root leaf\r\n    if (this.root === null) {\r\n      this.root = leaf;\r\n      this.root.parent = null;\r\n      return;\r\n    }\r\n\r\n    // Search the tree for a node that is not a leaf and find the best place to insert\r\n    const leafAABB = leaf.bounds;\r\n    let currentRoot = this.root;\r\n    while (!currentRoot.isLeaf()) {\r\n      const left = currentRoot.left;\r\n      const right = currentRoot.right;\r\n\r\n      const area = currentRoot.bounds.getPerimeter();\r\n      const combinedAABB = currentRoot.bounds.combine(leafAABB);\r\n      const combinedArea = combinedAABB.getPerimeter();\r\n\r\n      // Calculate cost heuristic for creating a new parent and leaf\r\n      const cost = 2 * combinedArea;\r\n\r\n      // Minimum cost of pushing the leaf down the tree\r\n      const inheritanceCost = 2 * (combinedArea - area);\r\n\r\n      // Cost of descending\r\n      let leftCost = 0;\r\n      const leftCombined = leafAABB.combine(left.bounds);\r\n      let newArea;\r\n      let oldArea;\r\n      if (left.isLeaf()) {\r\n        leftCost = leftCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = left.bounds.getPerimeter();\r\n        newArea = leftCombined.getPerimeter();\r\n        leftCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      let rightCost = 0;\r\n      const rightCombined = leafAABB.combine(right.bounds);\r\n      if (right.isLeaf()) {\r\n        rightCost = rightCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = right.bounds.getPerimeter();\r\n        newArea = rightCombined.getPerimeter();\r\n        rightCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      // cost is acceptable\r\n      if (cost < leftCost && cost < rightCost) {\r\n        break;\r\n      }\r\n\r\n      // Descend to the depths\r\n      if (leftCost < rightCost) {\r\n        currentRoot = left;\r\n      } else {\r\n        currentRoot = right;\r\n      }\r\n    }\r\n\r\n    // Create the new parent node and insert into the tree\r\n    const oldParent = currentRoot.parent;\r\n    const newParent = new TreeNode(oldParent);\r\n    newParent.bounds = leafAABB.combine(currentRoot.bounds);\r\n    newParent.height = currentRoot.height + 1;\r\n\r\n    if (oldParent !== null) {\r\n      // The sibling node was not the root\r\n      if (oldParent.left === currentRoot) {\r\n        oldParent.left = newParent;\r\n      } else {\r\n        oldParent.right = newParent;\r\n      }\r\n\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n    } else {\r\n      // The sibling node was the root\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n      this.root = newParent;\r\n    }\r\n\r\n    // Walk up the tree fixing heights and AABBs\r\n    let currentNode = leaf.parent;\r\n    while (currentNode) {\r\n      currentNode = this._balance(currentNode);\r\n\r\n      if (!currentNode.left) {\r\n        throw new Error('Parent of current leaf cannot have a null left child' + currentNode);\r\n      }\r\n      if (!currentNode.right) {\r\n        throw new Error('Parent of current leaf cannot have a null right child' + currentNode);\r\n      }\r\n\r\n      currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n      currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n\r\n      currentNode = currentNode.parent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a node from the dynamic tree\r\n   */\r\n  private _remove(leaf: TreeNode<T>) {\r\n    if (leaf === this.root) {\r\n      this.root = null;\r\n      return;\r\n    }\r\n\r\n    const parent = leaf.parent;\r\n    const grandParent = parent.parent;\r\n    let sibling: TreeNode<T>;\r\n    if (parent.left === leaf) {\r\n      sibling = parent.right;\r\n    } else {\r\n      sibling = parent.left;\r\n    }\r\n\r\n    if (grandParent) {\r\n      if (grandParent.left === parent) {\r\n        grandParent.left = sibling;\r\n      } else {\r\n        grandParent.right = sibling;\r\n      }\r\n      sibling.parent = grandParent;\r\n\r\n      let currentNode = grandParent;\r\n      while (currentNode) {\r\n        currentNode = this._balance(currentNode);\r\n        currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n        currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n\r\n        currentNode = currentNode.parent;\r\n      }\r\n    } else {\r\n      this.root = sibling;\r\n      sibling.parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tracks a body in the dynamic tree\r\n   */\r\n  public trackCollider(collider: T) {\r\n    const node = new TreeNode<T>();\r\n    node.data = collider;\r\n    node.bounds = collider.bounds;\r\n    node.bounds.left -= 2;\r\n    node.bounds.top -= 2;\r\n    node.bounds.right += 2;\r\n    node.bounds.bottom += 2;\r\n    this.nodes[collider.id.value] = node;\r\n    this._insert(node);\r\n  }\r\n\r\n  /**\r\n   * Updates the dynamic tree given the current bounds of each body being tracked\r\n   */\r\n  public updateCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return false;\r\n    }\r\n    const b = collider.bounds;\r\n\r\n    // if the body is outside the world no longer update it\r\n    if (!this.worldBounds.contains(b)) {\r\n      Logger.getInstance().warn(\r\n        'Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics'\r\n      );\r\n      this.untrackCollider(collider);\r\n      return false;\r\n    }\r\n\r\n    if (node.bounds.contains(b)) {\r\n      return false;\r\n    }\r\n\r\n    this._remove(node);\r\n    b.left -= Physics.boundsPadding;\r\n    b.top -= Physics.boundsPadding;\r\n    b.right += Physics.boundsPadding;\r\n    b.bottom += Physics.boundsPadding;\r\n\r\n    // THIS IS CAUSING UNECESSARY CHECKS\r\n    if (collider.owner) {\r\n      const body = collider.owner?.get(BodyComponent);\r\n      if (body) {\r\n        const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n        const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n\r\n        if (multdx < 0) {\r\n          b.left += multdx;\r\n        } else {\r\n          b.right += multdx;\r\n        }\r\n\r\n        if (multdy < 0) {\r\n          b.top += multdy;\r\n        } else {\r\n          b.bottom += multdy;\r\n        }\r\n      }\r\n    }\r\n\r\n    node.bounds = b;\r\n    this._insert(node);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Untracks a body from the dynamic tree\r\n   */\r\n  public untrackCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return;\r\n    }\r\n    this._remove(node);\r\n    this.nodes[collider.id.value] = null;\r\n    delete this.nodes[collider.id.value];\r\n  }\r\n\r\n  /**\r\n   * Balances the tree about a node\r\n   */\r\n  private _balance(node: TreeNode<T>) {\r\n    if (node === null) {\r\n      throw new Error('Cannot balance at null node');\r\n    }\r\n\r\n    if (node.isLeaf() || node.height < 2) {\r\n      return node;\r\n    }\r\n\r\n    const left = node.left;\r\n    const right = node.right;\r\n\r\n    const a = node;\r\n    const b = left;\r\n    const c = right;\r\n    const d = left.left;\r\n    const e = left.right;\r\n    const f = right.left;\r\n    const g = right.right;\r\n\r\n    const balance = c.height - b.height;\r\n    // Rotate c node up\r\n    if (balance > 1) {\r\n      // Swap the right node with it's parent\r\n      c.left = a;\r\n      c.parent = a.parent;\r\n      a.parent = c;\r\n\r\n      // The original node's old parent should point to the right node\r\n      // this is mega confusing\r\n      if (c.parent) {\r\n        if (c.parent.left === a) {\r\n          c.parent.left = c;\r\n        } else {\r\n          c.parent.right = c;\r\n        }\r\n      } else {\r\n        this.root = c;\r\n      }\r\n\r\n      // Rotate\r\n      if (f.height > g.height) {\r\n        c.right = f;\r\n        a.right = g;\r\n        g.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(g.bounds);\r\n        c.bounds = a.bounds.combine(f.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, g.height);\r\n        c.height = 1 + Math.max(a.height, f.height);\r\n      } else {\r\n        c.right = g;\r\n        a.right = f;\r\n        f.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(f.bounds);\r\n        c.bounds = a.bounds.combine(g.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, f.height);\r\n        c.height = 1 + Math.max(a.height, g.height);\r\n      }\r\n\r\n      return c;\r\n    }\r\n    // Rotate left node up\r\n    if (balance < -1) {\r\n      // swap\r\n      b.left = a;\r\n      b.parent = a.parent;\r\n      a.parent = b;\r\n\r\n      // node's old parent should point to b\r\n      if (b.parent) {\r\n        if (b.parent.left === a) {\r\n          b.parent.left = b;\r\n        } else {\r\n          if (b.parent.right !== a) {\r\n            throw 'Error rotating Dynamic Tree';\r\n          }\r\n          b.parent.right = b;\r\n        }\r\n      } else {\r\n        this.root = b;\r\n      }\r\n\r\n      // rotate\r\n      if (d.height > e.height) {\r\n        b.right = d;\r\n        a.left = e;\r\n        e.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(e.bounds);\r\n        b.bounds = a.bounds.combine(d.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, e.height);\r\n        b.height = 1 + Math.max(a.height, d.height);\r\n      } else {\r\n        b.right = e;\r\n        a.left = d;\r\n        d.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(d.bounds);\r\n        b.bounds = a.bounds.combine(e.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, d.height);\r\n        b.height = 1 + Math.max(a.height, e.height);\r\n      }\r\n      return b;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows\r\n   */\r\n  public getHeight(): number {\r\n    if (this.root === null) {\r\n      return 0;\r\n    }\r\n    return this.root.height;\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.\r\n   *\r\n   * In the query callback, it will be passed a potential collider. Returning true from this callback indicates\r\n   * that you are complete with your query and you do not want to continue. Returning false will continue searching\r\n   * the tree until all possible colliders have been returned.\r\n   */\r\n  public query(collider: T, callback: (other: T) => boolean): void {\r\n    const bounds = collider.bounds;\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.overlaps(bounds)) {\r\n        if (currentNode.isLeaf() && currentNode.data !== collider) {\r\n          if (callback.call(collider, currentNode.data)) {\r\n            return true;\r\n          }\r\n        } else {\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely\r\n   * long ray to test the tree specified by `max`.\r\n   *\r\n   * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this\r\n   * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching\r\n   * the tree until all possible bodies that would intersect with the ray have been returned.\r\n   */\r\n  public rayCastQuery(ray: Ray, max: number = Infinity, callback: (other: T) => boolean): void {\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.rayCast(ray, max)) {\r\n        if (currentNode.isLeaf()) {\r\n          if (callback.call(ray, currentNode.data)) {\r\n            // ray hit a leaf! return the body\r\n            return true;\r\n          }\r\n        } else {\r\n          // ray hit but not at a leaf, recurse deeper\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false; // ray missed\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  public getNodes(): TreeNode<T>[] {\r\n    const helper = (currentNode: TreeNode<T>): TreeNode<T>[] => {\r\n      if (currentNode) {\r\n        return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    return helper(this.root);\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    // draw all the nodes in the Dynamic Tree\r\n    const helper = (currentNode: TreeNode<T>) => {\r\n      if (currentNode) {\r\n        if (currentNode.isLeaf()) {\r\n          currentNode.bounds.draw(ex, Color.Green);\r\n        } else {\r\n          currentNode.bounds.draw(ex, Color.White);\r\n        }\r\n\r\n        if (currentNode.left) {\r\n          helper(currentNode.left);\r\n        }\r\n        if (currentNode.right) {\r\n          helper(currentNode.right);\r\n        }\r\n      }\r\n    };\r\n\r\n    helper(this.root);\r\n  }\r\n}\r\n","import { LineSegment } from './line-segment';\r\nimport { Vector } from './vector';\r\n\r\n/**\r\n * A 2D ray that can be cast into the scene to do collision detection\r\n */\r\n\r\nexport class Ray {\r\n  public pos: Vector;\r\n  public dir: Vector;\r\n\r\n  /**\r\n   * @param pos The starting position for the ray\r\n   * @param dir The vector indicating the direction of the ray\r\n   */\r\n  constructor(pos: Vector, dir: Vector) {\r\n    this.pos = pos;\r\n    this.dir = dir.normalize();\r\n  }\r\n\r\n  /**\r\n   * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.\r\n   * This number indicates the mathematical intersection time.\r\n   * @param line  The line to test\r\n   */\r\n  public intersect(line: LineSegment): number {\r\n    const numerator = line.begin.sub(this.pos);\r\n\r\n    // Test is line and ray are parallel and non intersecting\r\n    if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {\r\n      return -1;\r\n    }\r\n\r\n    // Lines are parallel\r\n    const divisor = this.dir.cross(line.getSlope());\r\n    if (divisor === 0) {\r\n      return -1;\r\n    }\r\n\r\n    const t = numerator.cross(line.getSlope()) / divisor;\r\n\r\n    if (t >= 0) {\r\n      const u = numerator.cross(this.dir) / divisor / line.getLength();\r\n      if (u >= 0 && u <= 1) {\r\n        return t;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  public intersectPoint(line: LineSegment): Vector {\r\n    const time = this.intersect(line);\r\n    if (time < 0) {\r\n      return null;\r\n    }\r\n    return this.getPoint(time);\r\n  }\r\n\r\n  /**\r\n   * Returns the point of intersection given the intersection time\r\n   */\r\n  public getPoint(time: number): Vector {\r\n    return this.pos.add(this.dir.scale(time));\r\n  }\r\n}\r\n","import { Physics } from '../Physics';\r\nimport { CollisionProcessor } from './CollisionProcessor';\r\nimport { DynamicTree } from './DynamicTree';\r\nimport { Pair } from './Pair';\r\n\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { FrameStats } from '../../Debug';\r\nimport { Logger } from '../../Util/Log';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Collider } from '../Colliders/Collider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CompositeCollider } from '../Colliders/CompositeCollider';\r\nimport { ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Responsible for performing the collision broadphase (locating potential collisions) and\r\n * the narrowphase (actual collision contacts)\r\n */\r\nexport class DynamicTreeCollisionProcessor implements CollisionProcessor {\r\n  private _dynamicCollisionTree = new DynamicTree<Collider>();\r\n  private _pairs = new Set<string>();\r\n\r\n  private _collisionPairCache: Pair[] = [];\r\n  private _colliders: Collider[] = [];\r\n\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Tracks a physics body for collisions\r\n   */\r\n  public track(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot track null collider');\r\n      return;\r\n    }\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        c.owner = target.owner;\r\n        this._colliders.push(c);\r\n        this._dynamicCollisionTree.trackCollider(c);\r\n      }\r\n    } else {\r\n      this._colliders.push(target);\r\n      this._dynamicCollisionTree.trackCollider(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Untracks a physics body\r\n   */\r\n  public untrack(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot untrack a null collider');\r\n      return;\r\n    }\r\n\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        const index = this._colliders.indexOf(c);\r\n        if (index !== -1) {\r\n          this._colliders.splice(index, 1);\r\n        }\r\n        this._dynamicCollisionTree.untrackCollider(c);\r\n      }\r\n    } else {\r\n      const index = this._colliders.indexOf(target);\r\n      if (index !== -1) {\r\n        this._colliders.splice(index, 1);\r\n      }\r\n      this._dynamicCollisionTree.untrackCollider(target);\r\n    }\r\n  }\r\n\r\n  private _pairExists(colliderA: Collider, colliderB: Collider) {\r\n    // if the collision pair has been calculated already short circuit\r\n    const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    return this._pairs.has(hash);\r\n  }\r\n\r\n  /**\r\n   * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy\r\n   */\r\n  public broadphase(targets: Collider[], delta: number, stats?: FrameStats): Pair[] {\r\n    const seconds = delta / 1000;\r\n\r\n    // Retrieve the list of potential colliders, exclude killed, prevented, and self\r\n    const potentialColliders = targets.filter((other) => {\r\n      const body = other.owner?.get(BodyComponent);\r\n      return other.owner?.active && body.collisionType !== CollisionType.PreventCollision;\r\n    });\r\n\r\n    // clear old list of collision pairs\r\n    this._collisionPairCache = [];\r\n    this._pairs.clear();\r\n\r\n    // check for normal collision pairs\r\n    let collider: Collider;\r\n    for (let j = 0, l = potentialColliders.length; j < l; j++) {\r\n      collider = potentialColliders[j];\r\n      // Query the collision tree for potential colliders\r\n      this._dynamicCollisionTree.query(collider, (other: Collider) => {\r\n        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n          const pair = new Pair(collider, other);\r\n          this._pairs.add(pair.id);\r\n          this._collisionPairCache.push(pair);\r\n        }\r\n        // Always return false, to query whole tree. Returning true in the query method stops searching\r\n        return false;\r\n      });\r\n    }\r\n    if (stats) {\r\n      stats.physics.pairs = this._collisionPairCache.length;\r\n    }\r\n\r\n    // Check dynamic tree for fast moving objects\r\n    // Fast moving objects are those moving at least there smallest bound per frame\r\n    if (Physics.checkForFastBodies) {\r\n      for (const collider of potentialColliders) {\r\n        const body = collider.owner.get(BodyComponent);\r\n        // Skip non-active objects. Does not make sense on other collision types\r\n        if (body.collisionType !== CollisionType.Active) {\r\n          continue;\r\n        }\r\n\r\n        // Maximum travel distance next frame\r\n        const updateDistance =\r\n          body.vel.size * seconds + // velocity term\r\n          body.acc.size * 0.5 * seconds * seconds; // acc term\r\n\r\n        // Find the minimum dimension\r\n        const minDimension = Math.min(collider.bounds.height, collider.bounds.width);\r\n        if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {\r\n          if (stats) {\r\n            stats.physics.fastBodies++;\r\n          }\r\n\r\n          // start with the oldPos because the integration for actors has already happened\r\n          // objects resting on a surface may be slightly penetrating in the current position\r\n          const updateVec = body.globalPos.sub(body.oldPos);\r\n          const centerPoint = collider.center;\r\n          const furthestPoint = collider.getFurthestPoint(body.vel);\r\n          const origin: Vector = furthestPoint.sub(updateVec);\r\n\r\n          const ray: Ray = new Ray(origin, body.vel);\r\n\r\n          // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface\r\n          ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));\r\n          let minCollider: Collider;\r\n          let minTranslate: Vector = new Vector(Infinity, Infinity);\r\n          this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other: Collider) => {\r\n            if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n              const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);\r\n              if (hitPoint) {\r\n                const translate = hitPoint.sub(origin);\r\n                if (translate.size < minTranslate.size) {\r\n                  minTranslate = translate;\r\n                  minCollider = other;\r\n                }\r\n              }\r\n            }\r\n            return false;\r\n          });\r\n\r\n          if (minCollider && Vector.isValid(minTranslate)) {\r\n            const pair = new Pair(collider, minCollider);\r\n            if (!this._pairs.has(pair.id)) {\r\n              this._pairs.add(pair.id);\r\n              this._collisionPairCache.push(pair);\r\n            }\r\n            // move the fast moving object to the other body\r\n            // need to push into the surface by ex.Physics.surfaceEpsilon\r\n            const shift = centerPoint.sub(furthestPoint);\r\n            body.globalPos = origin\r\n              .add(shift)\r\n              .add(minTranslate)\r\n              .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact\r\n            collider.update(body.transform.get());\r\n\r\n            if (stats) {\r\n              stats.physics.fastBodyCollisions++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // return cache\r\n    return this._collisionPairCache;\r\n  }\r\n\r\n  /**\r\n   * Applies narrow phase on collision pairs to find actual area intersections\r\n   * Adds actual colliding pairs to stats' Frame data\r\n   */\r\n  public narrowphase(pairs: Pair[], stats?: FrameStats): CollisionContact[] {\r\n    let contacts: CollisionContact[] = [];\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const newContacts = pairs[i].collide();\r\n      contacts = contacts.concat(newContacts);\r\n      if (stats && newContacts.length > 0) {\r\n        for (const c of newContacts) {\r\n          stats.physics.contacts.set(c.id, c);\r\n        }\r\n      }\r\n    }\r\n    if (stats) {\r\n      stats.physics.collisions += contacts.length;\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  /**\r\n   * Update the dynamic tree positions\r\n   */\r\n  public update(targets: Collider[]): number {\r\n    let updated = 0;\r\n    const len = targets.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (this._dynamicCollisionTree.updateCollider(targets[i])) {\r\n        updated++;\r\n      }\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    this._dynamicCollisionTree.debug(ex);\r\n  }\r\n}\r\n","import { Util } from '../..';\r\nimport { Pair } from '../Detection/Pair';\r\nimport { Color } from '../../Color';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Projection } from '../../Math/projection';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Vector } from '../../Math/vector';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { DynamicTree } from '../Detection/DynamicTree';\r\nimport { DynamicTreeCollisionProcessor } from '../Detection/DynamicTreeCollisionProcessor';\r\nimport { Collider } from './Collider';\r\nimport { Transform } from '../../Math/transform';\r\n\r\nexport class CompositeCollider extends Collider {\r\n  private _transform: Transform;\r\n  private _collisionProcessor = new DynamicTreeCollisionProcessor();\r\n  private _dynamicAABBTree = new DynamicTree();\r\n  private _colliders: Collider[] = [];\r\n\r\n  constructor(colliders: Collider[]) {\r\n    super();\r\n    for (const c of colliders) {\r\n      this.addCollider(c);\r\n    }\r\n  }\r\n\r\n  clearColliders() {\r\n    this._colliders = [];\r\n  }\r\n\r\n  addCollider(collider: Collider) {\r\n    this.events.wire(collider.events);\r\n    collider.__compositeColliderId = this.id;\r\n    this._colliders.push(collider);\r\n    this._collisionProcessor.track(collider);\r\n    this._dynamicAABBTree.trackCollider(collider);\r\n  }\r\n\r\n  removeCollider(collider: Collider) {\r\n    this.events.unwire(collider.events);\r\n    collider.__compositeColliderId = null;\r\n    Util.removeItemFromArray(collider, this._colliders);\r\n    this._collisionProcessor.untrack(collider);\r\n    this._dynamicAABBTree.untrackCollider(collider);\r\n  }\r\n\r\n  getColliders(): Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  get worldPos(): Vector {\r\n    // TODO transform component world pos\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get center(): Vector {\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get bounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce(\r\n      (acc, collider) => acc.combine(collider.bounds),\r\n      colliders[0]?.bounds ?? new BoundingBox().translate(this.worldPos)\r\n    );\r\n\r\n    return results;\r\n  }\r\n\r\n  get localBounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), colliders[0]?.localBounds ?? new BoundingBox());\r\n\r\n    return results;\r\n  }\r\n\r\n  get axes(): Vector[] {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    let axes: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      axes = axes.concat(collider.axes);\r\n    }\r\n    return axes;\r\n  }\r\n\r\n  getFurthestPoint(direction: Vector): Vector {\r\n    const colliders = this.getColliders();\r\n    const furthestPoints: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      furthestPoints.push(collider.getFurthestPoint(direction));\r\n    }\r\n    // Pick best point from all colliders\r\n    let bestPoint = furthestPoints[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (const point of furthestPoints) {\r\n      const distance = point.dot(direction);\r\n      if (distance > maxDistance) {\r\n        bestPoint = point;\r\n        maxDistance = distance;\r\n      }\r\n    }\r\n    return bestPoint;\r\n  }\r\n\r\n  getInertia(mass: number): number {\r\n    const colliders = this.getColliders();\r\n    let totalInertia = 0;\r\n    for (const collider of colliders) {\r\n      totalInertia += collider.getInertia(mass);\r\n    }\r\n    return totalInertia;\r\n  }\r\n\r\n  collide(other: Collider): CollisionContact[] {\r\n    let otherColliders = [other];\r\n    if (other instanceof CompositeCollider) {\r\n      otherColliders = other.getColliders();\r\n    }\r\n\r\n    const pairs: Pair[] = [];\r\n    for (const c of otherColliders) {\r\n      this._dynamicAABBTree.query(c, (potentialCollider: Collider) => {\r\n        pairs.push(new Pair(c, potentialCollider));\r\n        return false;\r\n      });\r\n    }\r\n\r\n    let contacts: CollisionContact[] = [];\r\n    for (const p of pairs) {\r\n      contacts = contacts.concat(p.collide());\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  getClosestLineBetween(other: Collider): LineSegment {\r\n    const colliders = this.getColliders();\r\n    const lines: LineSegment[] = [];\r\n    if (other instanceof CompositeCollider) {\r\n      const otherColliders = other.getColliders();\r\n      for (const colliderA of colliders) {\r\n        for (const colliderB of otherColliders) {\r\n          const maybeLine = colliderA.getClosestLineBetween(colliderB);\r\n          if (maybeLine) {\r\n            lines.push(maybeLine);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      for (const collider of colliders) {\r\n        const maybeLine = other.getClosestLineBetween(collider);\r\n        if (maybeLine) {\r\n          lines.push(maybeLine);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lines.length) {\r\n      let minLength = lines[0].getLength();\r\n      let minLine = lines[0];\r\n      for (const line of lines) {\r\n        const length = line.getLength();\r\n        if (length < minLength) {\r\n          minLength = length;\r\n          minLine = line;\r\n        }\r\n      }\r\n      return minLine;\r\n    }\r\n    return null;\r\n  }\r\n  contains(point: Vector): boolean {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      if (collider.contains(point)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  rayCast(ray: Ray, max?: number): Vector {\r\n    const colliders = this.getColliders();\r\n    const points: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      const vec = collider.rayCast(ray, max);\r\n      if (vec) {\r\n        points.push(vec);\r\n      }\r\n    }\r\n    if (points.length) {\r\n      let minPoint = points[0];\r\n      let minDistance = minPoint.dot(ray.dir);\r\n      for (const point of points) {\r\n        const distance = ray.dir.dot(point);\r\n        if (distance < minDistance) {\r\n          minPoint = point;\r\n          minDistance = distance;\r\n        }\r\n      }\r\n      return minPoint;\r\n    }\r\n    return null;\r\n  }\r\n  project(axis: Vector): Projection {\r\n    const colliders = this.getColliders();\r\n    const projs: Projection[] = [];\r\n    for (const collider of colliders) {\r\n      const proj = collider.project(axis);\r\n      if (proj) {\r\n        projs.push(proj);\r\n      }\r\n    }\r\n    // Merge all proj's on the same axis\r\n    if (projs.length) {\r\n      const newProjection = new Projection(projs[0].min, projs[0].max);\r\n      for (const proj of projs) {\r\n        newProjection.min = Math.min(proj.min, newProjection.min);\r\n        newProjection.max = Math.max(proj.max, newProjection.max);\r\n      }\r\n      return newProjection;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  update(transform: Transform): void {\r\n    if (transform) {\r\n      const colliders = this.getColliders();\r\n      for (const collider of colliders) {\r\n        collider.owner = this.owner;\r\n        collider.update(transform);\r\n      }\r\n    }\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      collider.debug(ex, color);\r\n    }\r\n  }\r\n\r\n  clone(): Collider {\r\n    return new CompositeCollider(this._colliders.map((c) => c.clone()));\r\n  }\r\n}\r\n","import { Vector } from './vector';\r\n\r\n/**\r\n * A 2D line segment\r\n */\r\n\r\nexport class LineSegment {\r\n\r\n  /**\r\n   * @param begin  The starting point of the line segment\r\n   * @param end  The ending point of the line segment\r\n   */\r\n  constructor(public readonly begin: Vector, public readonly end: Vector) {}\r\n\r\n  /**\r\n   * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.\r\n   */\r\n  public get slope() {\r\n    return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);\r\n  }\r\n\r\n  /**\r\n   * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.\r\n   */\r\n  public get intercept() {\r\n    return this.begin.y - this.slope * this.begin.x;\r\n  }\r\n\r\n  private _normal: Vector;\r\n  /**\r\n   * Gets the normal of the line\r\n   */\r\n  public normal(): Vector {\r\n    if (this._normal) {\r\n      return this._normal;\r\n    }\r\n    return this._normal = this.end.sub(this.begin).normal();\r\n  }\r\n\r\n  private _dir: Vector;\r\n  public dir(): Vector {\r\n    if (this._dir) {\r\n      return this._dir;\r\n    }\r\n    return this._dir = this.end.sub(this.begin);\r\n  }\r\n\r\n  public getPoints(): Vector[] {\r\n    return [this.begin, this.end];\r\n  }\r\n\r\n  private _slope: Vector;\r\n  /**\r\n   * Returns the slope of the line in the form of a vector of length 1\r\n   */\r\n  public getSlope(): Vector {\r\n    if (this._slope) {\r\n      return this._slope;\r\n    }\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    const distance = begin.distance(end);\r\n    return this._slope = end.sub(begin).scale(1 / distance);\r\n  }\r\n\r\n  /**\r\n   * Returns the edge of the line as vector, the length of the vector is the length of the edge\r\n   */\r\n  public getEdge(): Vector {\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    return end.sub(begin);\r\n  }\r\n\r\n  private _length: number;\r\n  /**\r\n   * Returns the length of the line segment in pixels\r\n   */\r\n  public getLength(): number {\r\n    if (this._length) {\r\n      return this._length;\r\n    }\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    const distance = begin.distance(end);\r\n    return this._length = distance;\r\n  }\r\n\r\n  /**\r\n   * Returns the midpoint of the edge\r\n   */\r\n  public get midpoint(): Vector {\r\n    return this.begin.add(this.end).scale(0.5);\r\n  }\r\n\r\n  /**\r\n   * Flips the direction of the line segment\r\n   */\r\n  public flip(): LineSegment {\r\n    return new LineSegment(this.end, this.begin);\r\n  }\r\n\r\n  /**\r\n   * Tests if a given point is below the line, points in the normal direction above the line are considered above.\r\n   * @param point\r\n   */\r\n  public below(point: Vector): boolean {\r\n    const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);\r\n    return above2 >= 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the clip point\r\n   * @param sideVector Vector that traces the line\r\n   * @param length Length to clip along side\r\n   */\r\n  public clip(sideVector: Vector, length: number): LineSegment {\r\n    let dir = sideVector;\r\n    dir = dir.normalize();\r\n\r\n    const near = dir.dot(this.begin) - length;\r\n    const far = dir.dot(this.end) - length;\r\n\r\n    const results = [];\r\n    if (near <= 0) {\r\n      results.push(this.begin);\r\n    }\r\n    if (far <= 0) {\r\n      results.push(this.end);\r\n    }\r\n\r\n    if (near * far < 0) {\r\n      const clipTime = near / (near - far);\r\n      results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));\r\n    }\r\n    if (results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    return new LineSegment(results[0], results[1]);\r\n  }\r\n\r\n  /**\r\n   * Find the perpendicular distance from the line to a point\r\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n   * @param point\r\n   */\r\n  public distanceToPoint(point: Vector, signed: boolean = false) {\r\n    const x0 = point.x;\r\n    const y0 = point.y;\r\n\r\n    const l = this.getLength();\r\n\r\n    const dy = this.end.y - this.begin.y;\r\n    const dx = this.end.x - this.begin.x;\r\n    const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;\r\n    return signed ? distance : Math.abs(distance);\r\n  }\r\n\r\n  /**\r\n   * Find the perpendicular line from the line to a point\r\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n   * (a - p) - ((a - p) * n)n\r\n   * a is a point on the line\r\n   * p is the arbitrary point above the line\r\n   * n is a unit vector in direction of the line\r\n   * @param point\r\n   */\r\n  public findVectorToPoint(point: Vector): Vector {\r\n    const aMinusP = this.begin.sub(point);\r\n    const n = this.getSlope();\r\n\r\n    return aMinusP.sub(n.scale(aMinusP.dot(n)));\r\n  }\r\n\r\n  /**\r\n   * Finds a point on the line given only an X or a Y value. Given an X value, the function returns\r\n   * a new point with the calculated Y value and vice-versa.\r\n   *\r\n   * @param x The known X value of the target point\r\n   * @param y The known Y value of the target point\r\n   * @returns A new point with the other calculated axis value\r\n   */\r\n  public findPoint(x: number = null, y: number = null): Vector {\r\n    const m = this.slope;\r\n    const b = this.intercept;\r\n\r\n    if (x !== null) {\r\n      return new Vector(x, m * x + b);\r\n    } else if (y !== null) {\r\n      return new Vector((y - b) / m, y);\r\n    } else {\r\n      throw new Error('You must provide an X or a Y value');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether or not the given point lies on this line. This method is precise by default\r\n   * meaning the point must lie exactly on the line. Adjust threshold to\r\n   * loosen the strictness of the check for floating-point calculations.\r\n   */\r\n  public hasPoint(x: number, y: number, threshold?: number): boolean;\r\n\r\n  /**\r\n   * Whether or not the given point lies on this line. This method is precise by default\r\n   * meaning the point must lie exactly on the line. Adjust threshold to\r\n   * loosen the strictness of the check for floating-point calculations.\r\n   */\r\n  public hasPoint(v: Vector, threshold?: number): boolean;\r\n\r\n  /**\r\n   * @see http://stackoverflow.com/a/11908158/109458\r\n   */\r\n  public hasPoint(): boolean {\r\n    let currPoint: Vector;\r\n    let threshold = 0;\r\n\r\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\r\n      currPoint = new Vector(arguments[0], arguments[1]);\r\n      threshold = arguments[2] || 0;\r\n    } else if (arguments[0] instanceof Vector) {\r\n      currPoint = arguments[0];\r\n      threshold = arguments[1] || 0;\r\n    } else {\r\n      throw 'Could not determine the arguments for Vector.hasPoint';\r\n    }\r\n\r\n    const dxc = currPoint.x - this.begin.x;\r\n    const dyc = currPoint.y - this.begin.y;\r\n\r\n    const dx1 = this.end.x - this.begin.x;\r\n    const dy1 = this.end.y - this.begin.y;\r\n\r\n    const cross = dxc * dy1 - dyc * dx1;\r\n\r\n    // check whether point lines on the line\r\n    if (Math.abs(cross) > threshold) {\r\n      return false;\r\n    }\r\n\r\n    // check whether point lies in-between start and end\r\n    if (Math.abs(dx1) >= Math.abs(dy1)) {\r\n      return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;\r\n    } else {\r\n      return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;\r\n    }\r\n  }\r\n}\r\n","import { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { CircleCollider } from './CircleCollider';\r\n\r\n/**\r\n * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment\r\n * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n * @param p0 Point where L1 begins\r\n * @param u Direction and length of L1\r\n * @param q0 Point were L2 begins\r\n * @param v Direction and length of L2\r\n */\r\nexport function ClosestLine(p0: Vector, u: Vector, q0: Vector, v: Vector) {\r\n  // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html\r\n\r\n  // w(s, t) = P(s) - Q(t)\r\n  // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest\r\n  //\r\n  // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.\r\n  // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0\r\n  //\r\n  // The closest point between 2 lines then satisfies this pair of equations\r\n  // 1: u * wClosest = 0\r\n  // 2: v * wClosest = 0\r\n  //\r\n  // Substituting wClosest into the equations we get\r\n  //\r\n  // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0\r\n  // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0\r\n\r\n  // simplify w0\r\n  const w0 = p0.sub(q0);\r\n\r\n  // simplify (u * u);\r\n  const a = u.dot(u);\r\n  // simplify (u * v);\r\n  const b = u.dot(v);\r\n  // simplify (v * v)\r\n  const c = v.dot(v);\r\n  // simplify (u * w0)\r\n  const d = u.dot(w0);\r\n  // simplify (v * w0)\r\n  const e = v.dot(w0);\r\n\r\n  // denominator ac - b^2\r\n  const denom = a * c - b * b;\r\n  let sDenom = denom;\r\n  let tDenom = denom;\r\n  // if denom is 0 they are parallel, use any point from either as the start in this case p0\r\n  if (denom === 0 || denom <= 0.01) {\r\n    const tClosestParallel = d / b;\r\n    return new LineSegment(p0, q0.add(v.scale(tClosestParallel)));\r\n  }\r\n\r\n  // Solve for sClosest for infinite line\r\n  let sClosest = b * e - c * d; // / denom;\r\n\r\n  // Solve for tClosest for infinite line\r\n  let tClosest = a * e - b * d; // / denom;\r\n\r\n  // Solve for segments candidate edges, if sClosest and tClosest are outside their segments\r\n  if (sClosest < 0) {\r\n    sClosest = 0;\r\n    tClosest = e;\r\n    tDenom = c;\r\n  } else if (sClosest > sDenom) {\r\n    sClosest = sDenom;\r\n    tClosest = e + b;\r\n    tDenom = c;\r\n  }\r\n\r\n  if (tClosest < 0) {\r\n    tClosest = 0;\r\n    if (-d < 0) {\r\n      sClosest = 0;\r\n    } else if (-d > a) {\r\n      sClosest = sDenom;\r\n    } else {\r\n      sClosest = -d;\r\n      sDenom = a;\r\n    }\r\n  } else if (tClosest > tDenom) {\r\n    tClosest = tDenom;\r\n    if (-d + b < 0) {\r\n      sClosest = 0;\r\n    } else if (-d + b > a) {\r\n      sClosest = sDenom;\r\n    } else {\r\n      sClosest = -d + b;\r\n      sDenom = a;\r\n    }\r\n  }\r\n  sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;\r\n  tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;\r\n\r\n  return new LineSegment(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));\r\n}\r\n\r\nexport const ClosestLineJumpTable = {\r\n  PolygonPolygonClosestLine(polygonA: PolygonCollider, polygonB: PolygonCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = polygonB.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygonA.worldPos);\r\n    const thisDirection = otherDirection.negate();\r\n\r\n    const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);\r\n    const rayTowardsThis = new Ray(otherWorldPos, thisDirection);\r\n\r\n    const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n    const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));\r\n\r\n    const thisFace = polygonA.getClosestFace(thisPoint);\r\n    const otherFace = polygonB.getClosestFace(otherPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const q0 = otherFace.face.begin;\r\n    const v = otherFace.face.getEdge();\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  },\r\n\r\n  PolygonEdgeClosestLine(polygon: PolygonCollider, edge: EdgeCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = edge.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);\r\n\r\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n\r\n    const thisFace = polygon.getClosestFace(thisPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const edgeLine = edge.asLine();\r\n    const edgeStart = edgeLine.begin;\r\n    const edgeVector = edgeLine.getEdge();\r\n    const q0 = edgeStart;\r\n    const v = edgeVector;\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  },\r\n\r\n  PolygonCircleClosestLine(polygon: PolygonCollider, circle: CircleCollider) {\r\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = circle.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());\r\n\r\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n\r\n    const thisFace = polygon.getClosestFace(thisPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // Time of minimum distance\r\n    let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n\r\n    // If time of minimum is past the edge clamp\r\n    if (t > 1) {\r\n      t = 1;\r\n    } else if (t < 0) {\r\n      t = 0;\r\n    }\r\n\r\n    // Minimum distance\r\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;\r\n\r\n    const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);\r\n    const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);\r\n    return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));\r\n  },\r\n\r\n  CircleCircleClosestLine(circleA: CircleCollider, circleB: CircleCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = circleB.worldPos;\r\n    const otherDirection = otherWorldPos.sub(circleA.worldPos);\r\n\r\n    const thisWorldPos = circleA.worldPos;\r\n    const thisDirection = thisWorldPos.sub(circleB.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);\r\n    const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);\r\n\r\n    const thisPoint = circleA.rayCast(rayTowardsOther);\r\n    const otherPoint = circleB.rayCast(rayTowardsThis);\r\n\r\n    return new LineSegment(thisPoint, otherPoint);\r\n  },\r\n\r\n  CircleEdgeClosestLine(circle: CircleCollider, edge: EdgeCollider) {\r\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n    const circleWorlPos = circle.worldPos;\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const edgeLine = edge.asLine();\r\n    const edgeStart = edgeLine.begin;\r\n    const edgeVector = edgeLine.getEdge();\r\n    const p0 = edgeStart;\r\n    const u = edgeVector;\r\n\r\n    // Time of minimum distance\r\n    let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n\r\n    // If time of minimum is past the edge clamp to edge\r\n    if (t > 1) {\r\n      t = 1;\r\n    } else if (t < 0) {\r\n      t = 0;\r\n    }\r\n\r\n    // Minimum distance\r\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;\r\n\r\n    const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);\r\n    const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);\r\n    return new LineSegment(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));\r\n  },\r\n\r\n  EdgeEdgeClosestLine(edgeA: EdgeCollider, edgeB: EdgeCollider) {\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const edgeLineA = edgeA.asLine();\r\n    const edgeStartA = edgeLineA.begin;\r\n    const edgeVectorA = edgeLineA.getEdge();\r\n    const p0 = edgeStartA;\r\n    const u = edgeVectorA;\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const edgeLineB = edgeB.asLine();\r\n    const edgeStartB = edgeLineB.begin;\r\n    const edgeVectorB = edgeLineB.getEdge();\r\n    const q0 = edgeStartB;\r\n    const v = edgeVectorB;\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  }\r\n};\r\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\n\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { Transform } from '../../Math/transform';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport interface CircleColliderOptions {\r\n  /**\r\n   * Optional pixel offset to shift the circle relative to the collider, by default (0, 0).\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Required radius of the circle\r\n   */\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * This is a circle collider for the excalibur rigid body physics simulation\r\n */\r\nexport class CircleCollider extends Collider {\r\n  /**\r\n   * Position of the circle relative to the collider, by default (0, 0).\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  private _globalMatrix: AffineMatrix = AffineMatrix.identity();\r\n\r\n  public get worldPos(): Vector {\r\n    return this._globalMatrix.getPosition();\r\n  }\r\n\r\n  private _naturalRadius: number;\r\n  /**\r\n   * Get the radius of the circle\r\n   */\r\n  public get radius(): number {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n    return this._naturalRadius * Math.min(scale.x, scale.y);\r\n  }\r\n\r\n  /**\r\n   * Set the radius of the circle\r\n   */\r\n  public set radius(val: number) {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n    this._naturalRadius = val / Math.min(scale.x, scale.y);\r\n  }\r\n\r\n  private _transform: Transform;\r\n\r\n  constructor(options: CircleColliderOptions) {\r\n    super();\r\n    this.offset = options.offset || Vector.Zero;\r\n    this.radius = options.radius || 0;\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this shape, not associated with any collider\r\n   */\r\n  public clone(): CircleCollider {\r\n    return new CircleCollider({\r\n      offset: this.offset.clone(),\r\n      radius: this.radius\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    return this._globalMatrix.getPosition();\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    const pos = this._transform?.pos ?? this.offset;\r\n    const distance = pos.distance(point);\r\n    if (distance <= this.radius) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Casts a ray at the Circle collider and returns the nearest point of collision\r\n   * @param ray\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\r\n    const c = this.center;\r\n    const dir = ray.dir;\r\n    const orig = ray.pos;\r\n\r\n    const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));\r\n\r\n    if (discriminant < 0) {\r\n      // no intersection\r\n      return null;\r\n    } else {\r\n      let toi = 0;\r\n      if (discriminant === 0) {\r\n        toi = -dir.dot(orig.sub(c));\r\n        if (toi > 0 && toi < max) {\r\n          return ray.getPoint(toi);\r\n        }\r\n        return null;\r\n      } else {\r\n        const toi1 = -dir.dot(orig.sub(c)) + discriminant;\r\n        const toi2 = -dir.dot(orig.sub(c)) - discriminant;\r\n\r\n        const positiveToi: number[] = [];\r\n        if (toi1 >= 0) {\r\n          positiveToi.push(toi1);\r\n        }\r\n\r\n        if (toi2 >= 0) {\r\n          positiveToi.push(toi2);\r\n        }\r\n\r\n        const mintoi = Math.min(...positiveToi);\r\n        if (mintoi <= max) {\r\n          return ray.getPoint(mintoi);\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n\r\n  public getClosestLineBetween(shape: Collider): LineSegment {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleCircle(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    return this.center.add(direction.normalize().scale(this.radius));\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the shape in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const dir = direction.normalize();\r\n    return dir.scale(this.radius);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n    return new BoundingBox(\r\n      this.offset.x - this._naturalRadius,\r\n      this.offset.y - this._naturalRadius,\r\n      this.offset.x + this._naturalRadius,\r\n      this.offset.y + this._naturalRadius\r\n    ).rotate(rotation).scale(scale).translate(pos);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return new BoundingBox(\r\n      this.offset.x - this._naturalRadius,\r\n      this.offset.y - this._naturalRadius,\r\n      this.offset.x + this._naturalRadius,\r\n      this.offset.y + this._naturalRadius\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get axis not implemented on circles, since there are infinite axis in a circle\r\n   */\r\n  public get axes(): Vector[] {\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Returns the moment of inertia of a circle given it's mass\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    return (mass * this.radius * this.radius) / 2;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    const globalMat = transform.matrix ?? this._globalMatrix;\r\n    globalMat.clone(this._globalMatrix);\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Project the circle along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n    const point = this.center;\r\n    const dotProduct = point.dot(axis);\r\n    scalars.push(dotProduct);\r\n    scalars.push(dotProduct + this.radius);\r\n    scalars.push(dotProduct - this.radius);\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n    ex.save();\r\n    ex.translate(pos.x, pos.y);\r\n    ex.rotate(rotation);\r\n    ex.scale(scale.x, scale.y);\r\n    ex.drawCircle((this.offset ?? Vector.Zero), this._naturalRadius, Color.Transparent, color, 2);\r\n    ex.restore();\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Physics } from '../Physics';\r\nimport { Collider } from '../Colliders/Collider';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Pair } from './Pair';\r\nimport { SeparationInfo } from '../Colliders/SeparatingAxis';\r\nimport { BodyComponent } from '../BodyComponent';\r\n\r\n/**\r\n * Collision contacts are used internally by Excalibur to resolve collision between colliders. This\r\n * Pair prevents collisions from being evaluated more than one time\r\n */\r\nexport class CollisionContact {\r\n  private _canceled = false;\r\n\r\n  /**\r\n   * Currently the ids between colliders\r\n   */\r\n  readonly id: string;\r\n\r\n  /**\r\n   * The first collider in the collision\r\n   */\r\n  colliderA: Collider;\r\n\r\n  /**\r\n   * The second collider in the collision\r\n   */\r\n  colliderB: Collider;\r\n\r\n  /**\r\n   * The minimum translation vector to resolve overlap, pointing away from colliderA\r\n   */\r\n  mtv: Vector;\r\n\r\n  /**\r\n   * World space contact points between colliderA and colliderB\r\n   */\r\n  points: Vector[];\r\n\r\n  /**\r\n   * Local space contact points between colliderA and colliderB\r\n   */\r\n  localPoints: Vector[];\r\n\r\n  /**\r\n   * The collision normal, pointing away from colliderA\r\n   */\r\n  normal: Vector;\r\n\r\n  /**\r\n   * The collision tangent\r\n   */\r\n  tangent: Vector;\r\n\r\n  /**\r\n   * Information about the specifics of the collision contact separation\r\n   */\r\n  info: SeparationInfo;\r\n\r\n  constructor(\r\n    colliderA: Collider,\r\n    colliderB: Collider,\r\n    mtv: Vector,\r\n    normal: Vector,\r\n    tangent: Vector,\r\n    points: Vector[],\r\n    localPoints: Vector[],\r\n    info: SeparationInfo\r\n  ) {\r\n    this.colliderA = colliderA;\r\n    this.colliderB = colliderB;\r\n    this.mtv = mtv;\r\n    this.normal = normal;\r\n    this.tangent = tangent;\r\n    this.points = points;\r\n    this.localPoints = localPoints;\r\n    this.info = info;\r\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) {\r\n      // Add on the parent composite pair for start/end contact\r\n      this.id += '|' + Pair.calculatePairHash(\r\n        colliderA.__compositeColliderId ?? colliderA.id,\r\n        colliderB.__compositeColliderId ?? colliderB.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Match contact awake state, except if body's are Fixed\r\n   */\r\n  public matchAwake(): void {\r\n    const bodyA = this.colliderA.owner.get(BodyComponent);\r\n    const bodyB = this.colliderB.owner.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      if (bodyA.sleeping !== bodyB.sleeping) {\r\n        if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {\r\n          bodyA.setSleeping(false);\r\n        }\r\n        if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {\r\n          bodyB.setSleeping(false);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public isCanceled() {\r\n    return this._canceled;\r\n  }\r\n\r\n  public cancel(): void {\r\n    this._canceled = true;\r\n  }\r\n}\r\n","import { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Collider } from './Collider';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { PolygonCollider } from './PolygonCollider';\r\n\r\n/**\r\n * Specific information about a contact and it's separation\r\n */\r\nexport interface SeparationInfo {\r\n  /**\r\n   * Collider A\r\n   */\r\n  collider: Collider;\r\n\r\n  /**\r\n   * Signed value (negative means overlap, positive no overlap)\r\n   */\r\n  separation: number;\r\n\r\n  /**\r\n   * Axis of separation from the collider's perspective\r\n   */\r\n  axis: Vector;\r\n\r\n  /**\r\n   * Side of separation (reference) from the collider's perspective\r\n   */\r\n\r\n  side?: LineSegment;\r\n\r\n  /**\r\n   * Local side of separation (reference) from the collider's perspective\r\n   */\r\n  localSide?: LineSegment;\r\n\r\n  /**\r\n   * Index of the separation side (reference) from the collider's perspective\r\n   */\r\n  sideId?: number;\r\n\r\n  /**\r\n   * Point on collider B (incident point)\r\n   */\r\n  point: Vector;\r\n\r\n  /**\r\n   * Local point on collider B (incident point)\r\n   */\r\n  localPoint?: Vector;\r\n}\r\n\r\nexport class SeparatingAxis {\r\n  static findPolygonPolygonSeparation(polyA: PolygonCollider, polyB: PolygonCollider): SeparationInfo {\r\n    let bestSeparation = -Number.MAX_VALUE;\r\n    let bestSide: LineSegment | null = null;\r\n    let bestAxis: Vector | null = null;\r\n    let bestSideIndex: number = -1;\r\n    let bestOtherPoint: Vector | null = null;\r\n    const sides = polyA.getSides();\r\n    const localSides = polyA.getLocalSides();\r\n    for (let i = 0; i < sides.length; i++) {\r\n      const side = sides[i];\r\n      const axis = side.normal();\r\n      const vertB = polyB.getFurthestPoint(axis.negate());\r\n      // Separation on side i's axis\r\n      // We are looking for the largest separation between poly A's sides\r\n      const vertSeparation = side.distanceToPoint(vertB, true);\r\n      if (vertSeparation > bestSeparation) {\r\n        bestSeparation = vertSeparation;\r\n        bestSide = side;\r\n        bestAxis = axis;\r\n        bestSideIndex = i;\r\n        bestOtherPoint = vertB;\r\n      }\r\n    }\r\n\r\n    return {\r\n      collider: polyA,\r\n      separation: bestAxis ? bestSeparation : 99,\r\n      axis: bestAxis as Vector,\r\n      side: bestSide,\r\n      localSide: localSides[bestSideIndex],\r\n      sideId: bestSideIndex,\r\n      point: bestOtherPoint as Vector,\r\n      localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis!.negate()) : null\r\n    };\r\n  }\r\n\r\n  static findCirclePolygonSeparation(circle: CircleCollider, polygon: PolygonCollider): Vector | null {\r\n    const axes = polygon.axes;\r\n    const pc = polygon.center;\r\n    // Special SAT with circles\r\n    const polyDir = pc.sub(circle.worldPos);\r\n    const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());\r\n    axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());\r\n\r\n    let minOverlap = Number.MAX_VALUE;\r\n    let minAxis = null;\r\n    let minIndex = -1;\r\n    for (let i = 0; i < axes.length; i++) {\r\n      const proj1 = polygon.project(axes[i]);\r\n      const proj2 = circle.project(axes[i]);\r\n      const overlap = proj1.getOverlap(proj2);\r\n      if (overlap <= 0) {\r\n        return null;\r\n      } else {\r\n        if (overlap < minOverlap) {\r\n          minOverlap = overlap;\r\n          minAxis = axes[i];\r\n          minIndex = i;\r\n        }\r\n      }\r\n    }\r\n    if (minIndex < 0) {\r\n      return null;\r\n    }\r\n    return minAxis.normalize().scale(minOverlap);\r\n  }\r\n}\r\n","import { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { SeparatingAxis, SeparationInfo } from './SeparatingAxis';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { TransformComponent } from '../../EntityComponentSystem';\r\nimport { Pair } from '../Detection/Pair';\r\n\r\nexport const CollisionJumpTable = {\r\n  CollideCircleCircle(circleA: CircleCollider, circleB: CircleCollider): CollisionContact[] {\r\n    const circleAPos = circleA.worldPos;\r\n    const circleBPos = circleB.worldPos;\r\n    const combinedRadius = circleA.radius + circleB.radius;\r\n    const distance = circleAPos.distance(circleBPos);\r\n\r\n    if (distance > combinedRadius) {\r\n      return [];\r\n    }\r\n\r\n    // negative means overlap\r\n    const separation = combinedRadius - distance;\r\n\r\n    // Normal points from A -> B\r\n    const normal = circleBPos.sub(circleAPos).normalize();\r\n    const tangent = normal.perpendicular();\r\n    const mvt = normal.scale(separation);\r\n\r\n    const point = circleA.getFurthestPoint(normal);\r\n    const local = circleA.getFurthestLocalPoint(normal);\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circleA,\r\n      separation,\r\n      axis: normal,\r\n      point: point\r\n    };\r\n\r\n    return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];\r\n  },\r\n\r\n  CollideCirclePolygon(circle: CircleCollider, polygon: PolygonCollider): CollisionContact[] {\r\n    let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);\r\n    if (!minAxis) {\r\n      return [];\r\n    }\r\n\r\n    // make sure that the minAxis is pointing away from circle\r\n    const samedir = minAxis.dot(polygon.center.sub(circle.center));\r\n    minAxis = samedir < 0 ? minAxis.negate() : minAxis;\r\n\r\n    const point = circle.getFurthestPoint(minAxis);\r\n    const xf = circle.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const local = xf.applyInverse(point);\r\n    const normal = minAxis.normalize();\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: -minAxis.size,\r\n      axis: normal,\r\n      point: point,\r\n      localPoint: local,\r\n      side: polygon.findSide(normal.negate()),\r\n      localSide: polygon.findLocalSide(normal.negate())\r\n    };\r\n\r\n    return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];\r\n  },\r\n\r\n  CollideCircleEdge(circle: CircleCollider, edge: EdgeCollider): CollisionContact[] {\r\n    // TODO not sure this actually abides by local/world collisions\r\n    // Are edge.begin and edge.end local space or world space? I think they should be local\r\n\r\n    // center of the circle in world pos\r\n    const cc = circle.center;\r\n    // vector in the direction of the edge\r\n    const edgeWorld = edge.asLine();\r\n    const e = edgeWorld.end.sub(edgeWorld.begin);\r\n\r\n    // amount of overlap with the circle's center along the edge direction\r\n    const u = e.dot(edgeWorld.end.sub(cc));\r\n    const v = e.dot(cc.sub(edgeWorld.begin));\r\n    const side = edge.asLine();\r\n    const localSide = edge.asLocalLine();\r\n\r\n    // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n    if (v <= 0) {\r\n      const da = edgeWorld.begin.sub(cc);\r\n      const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\r\n      // save some sqrts\r\n      if (dda > circle.radius * circle.radius) {\r\n        return []; // no collision\r\n      }\r\n\r\n      const normal = da.normalize();\r\n      const separation = circle.radius - Math.sqrt(dda);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.begin,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)\r\n      ];\r\n    }\r\n\r\n    // Potential region B collision (circle is on the right side of the edge, after the end)\r\n    if (u <= 0) {\r\n      const db = edgeWorld.end.sub(cc);\r\n      const ddb = db.dot(db);\r\n      if (ddb > circle.radius * circle.radius) {\r\n        return [];\r\n      }\r\n\r\n      const normal = db.normalize();\r\n      const separation = circle.radius - Math.sqrt(ddb);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.end,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)\r\n      ];\r\n    }\r\n\r\n    // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n    const den = e.dot(e);\r\n    const pointOnEdge = edgeWorld.begin\r\n      .scale(u)\r\n      .add(edgeWorld.end.scale(v))\r\n      .scale(1 / den);\r\n    const d = cc.sub(pointOnEdge);\r\n\r\n    const dd = d.dot(d);\r\n    if (dd > circle.radius * circle.radius) {\r\n      return []; // no collision\r\n    }\r\n\r\n    let normal = e.perpendicular();\r\n    // flip correct direction\r\n    if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {\r\n      normal.x = -normal.x;\r\n      normal.y = -normal.y;\r\n    }\r\n\r\n    normal = normal.normalize();\r\n    const separation = circle.radius - Math.sqrt(dd);\r\n\r\n    const mvt = normal.scale(separation);\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: separation,\r\n      axis: normal,\r\n      point: pointOnEdge,\r\n      side: side,\r\n      localSide: localSide\r\n    };\r\n\r\n    return [\r\n      new CollisionContact(\r\n        circle,\r\n        edge,\r\n        mvt,\r\n        normal.negate(),\r\n        normal.negate().perpendicular(),\r\n        [pointOnEdge],\r\n        [pointOnEdge.sub(edge.worldPos)],\r\n        info\r\n      )\r\n    ];\r\n  },\r\n\r\n  CollideEdgeEdge(): CollisionContact[] {\r\n    // Edge-edge collision doesn't make sense\r\n    return [];\r\n  },\r\n\r\n  CollidePolygonEdge(polygon: PolygonCollider, edge: EdgeCollider): CollisionContact[] {\r\n    const pc = polygon.center;\r\n    const ec = edge.center;\r\n    const dir = ec.sub(pc).normalize();\r\n\r\n    // build a temporary polygon from the edge to use SAT\r\n    const linePoly = new PolygonCollider({\r\n      points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],\r\n      offset: edge.offset\r\n    });\r\n    linePoly.owner = edge.owner;\r\n    const tx = edge.owner?.get(TransformComponent);\r\n    if (tx) {\r\n      linePoly.update(edge.owner.get(TransformComponent).get());\r\n    }\r\n    // Gross hack but poly-poly works well\r\n    const contact = this.CollidePolygonPolygon(polygon, linePoly);\r\n    if (contact.length) {\r\n      // Fudge the contact back to edge\r\n      contact[0].colliderB = edge;\r\n      (contact[0].id as any) = Pair.calculatePairHash(polygon.id, edge.id);\r\n    }\r\n    return contact;\r\n  },\r\n\r\n  CollidePolygonPolygon(polyA: PolygonCollider, polyB: PolygonCollider): CollisionContact[] {\r\n    // Multi contact from SAT\r\n    // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection\r\n    // do a SAT test to find a min axis if it exists\r\n    const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);\r\n    // If there is no overlap from boxA's perspective we can end early\r\n    if (separationA.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);\r\n    // If there is no overlap from boxB's perspective exit now\r\n    if (separationB.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    // Separations are both negative, we want to pick the least negative (minimal movement)\r\n    const separation = separationA.separation > separationB.separation ? separationA : separationB;\r\n\r\n    // The incident side is the most opposite from the axes of collision on the other collider\r\n    const other = separation.collider === polyA ? polyB : polyA;\r\n    const incident = other.findSide(separation.axis.negate()) as LineSegment;\r\n\r\n    // Clip incident side by the perpendicular lines at each end of the reference side\r\n    // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\r\n    const reference = separation.side;\r\n    const refDir = reference.dir().normalize();\r\n\r\n    // Find our contact points by clipping the incident by the collision side\r\n    const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));\r\n    let clipLeft: LineSegment | null = null;\r\n    if (clipRight) {\r\n      clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));\r\n    }\r\n\r\n    // If there is no left there is no collision\r\n    if (clipLeft) {\r\n      // We only want clip points below the reference edge, discard the others\r\n      const points = clipLeft.getPoints().filter((p) => {\r\n        return reference.below(p);\r\n      });\r\n\r\n      let normal = separation.axis;\r\n      let tangent = normal.perpendicular();\r\n      // Point Contact A -> B\r\n      if (polyB.center.sub(polyA.center).dot(normal) < 0) {\r\n        normal = normal.negate();\r\n        tangent = normal.perpendicular();\r\n      }\r\n      // Points are clipped from incident which is the other collider\r\n      // Store those as locals\r\n      let localPoints: Vector[] = [];\r\n      if (separation.collider === polyA) {\r\n        const xf = polyB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      } else {\r\n        const xf = polyA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      }\r\n      return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];\r\n    }\r\n    return [];\r\n  },\r\n\r\n  FindContactSeparation(contact: CollisionContact, localPoint: Vector) {\r\n    const shapeA = contact.colliderA;\r\n    const txA = contact.colliderA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const shapeB = contact.colliderB;\r\n    const txB = contact.colliderB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n\r\n    // both are circles\r\n    if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {\r\n      const combinedRadius = shapeA.radius + shapeB.radius;\r\n      const distance = txA.pos.distance(txB.pos);\r\n      const separation = combinedRadius - distance;\r\n      return -separation;\r\n    }\r\n\r\n    // both are polygons\r\n    if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {\r\n      if (contact.info.localSide) {\r\n        let side: LineSegment;\r\n        let worldPoint: Vector;\r\n        if (contact.info.collider === shapeA) {\r\n          side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));\r\n          worldPoint = txB.apply(localPoint);\r\n        } else {\r\n          side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));\r\n          worldPoint = txA.apply(localPoint);\r\n        }\r\n\r\n        return side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v circle\r\n    if (\r\n      (shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||\r\n      (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)\r\n    ) {\r\n      const worldPoint = txA.apply(localPoint);\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v edge\r\n    if (\r\n      (shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||\r\n      (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)\r\n    ) {\r\n      let worldPoint: Vector;\r\n      if (contact.info.collider === shapeA) {\r\n        worldPoint = txB.apply(localPoint);\r\n      } else {\r\n        worldPoint = txA.apply(localPoint);\r\n      }\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // circle v edge\r\n    if (\r\n      (shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||\r\n      (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)\r\n    ) {\r\n      // Local point is always on the edge which is always shapeB\r\n      const worldPoint = txB.apply(localPoint);\r\n\r\n      let circlePoint: Vector;\r\n      if (shapeA instanceof CircleCollider) {\r\n        circlePoint = shapeA.getFurthestPoint(contact.normal);\r\n      }\r\n\r\n      const dist = worldPoint.distance(circlePoint);\r\n\r\n      if (contact.info.side) {\r\n        return dist > 0 ? -dist : 0;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n};\r\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { PolygonCollider } from './PolygonCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { Transform } from '../../Math/transform';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport interface EdgeColliderOptions {\r\n  /**\r\n   * The beginning of the edge defined in local coordinates to the collider\r\n   */\r\n  begin: Vector;\r\n  /**\r\n   * The ending of the edge defined in local coordinates to the collider\r\n   */\r\n  end: Vector;\r\n  /**\r\n   * Optionally specify an offset\r\n   */\r\n  offset?: Vector;\r\n}\r\n\r\n/**\r\n * Edge is a single line collider to create collisions with a single line.\r\n */\r\nexport class EdgeCollider extends Collider {\r\n  offset: Vector;\r\n  begin: Vector;\r\n  end: Vector;\r\n\r\n  private _transform: Transform;\r\n  private _globalMatrix: AffineMatrix = AffineMatrix.identity();\r\n\r\n  constructor(options: EdgeColliderOptions) {\r\n    super();\r\n    this.begin = options.begin || Vector.Zero;\r\n    this.end = options.end || Vector.Zero;\r\n    this.offset = options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this Edge, not associated with any collider\r\n   */\r\n  public clone(): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: this.begin.clone(),\r\n      end: this.end.clone()\r\n    });\r\n  }\r\n\r\n  public get worldPos(): Vector {\r\n    const tx = this._transform;\r\n    return tx?.globalPos.add(this.offset) ?? this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collision area in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const pos = begin.average(end);\r\n    return pos;\r\n  }\r\n\r\n  private _getTransformedBegin(): Vector {\r\n    return this._globalMatrix.multiply(this.begin);\r\n  }\r\n\r\n  private _getTransformedEnd(): Vector {\r\n    return this._globalMatrix.multiply(this.end);\r\n  }\r\n\r\n  /**\r\n   * Returns the slope of the line in the form of a vector\r\n   */\r\n  public getSlope(): Vector {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return end.sub(begin).scale(1 / distance);\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the line segment in pixels\r\n   */\r\n  public getLength(): number {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return distance;\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collision area\r\n   */\r\n  public contains(): boolean {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    const numerator = this._getTransformedBegin().sub(ray.pos);\r\n\r\n    // Test is line and ray are parallel and non intersecting\r\n    if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {\r\n      return null;\r\n    }\r\n\r\n    // Lines are parallel\r\n    const divisor = ray.dir.cross(this.getSlope());\r\n    if (divisor === 0) {\r\n      return null;\r\n    }\r\n\r\n    const t = numerator.cross(this.getSlope()) / divisor;\r\n\r\n    if (t >= 0 && t <= max) {\r\n      const u = numerator.cross(ray.dir) / divisor / this.getLength();\r\n      if (u >= 0 && u <= 1) {\r\n        return ray.getPoint(t);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the closes line between this and another collider, from this -> collider\r\n   * @param shape\r\n   */\r\n  public getClosestLineBetween(shape: Collider): LineSegment {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(shape: Collider): CollisionContact[] {\r\n    if (shape instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(shape, this);\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideEdgeEdge();\r\n    } else {\r\n      throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    if (direction.dot(transformedBegin) > 0) {\r\n      return transformedBegin;\r\n    } else {\r\n      return transformedEnd;\r\n    }\r\n  }\r\n\r\n  private _boundsFromBeginEnd(begin: Vector, end: Vector, padding = 10) {\r\n    // A perfectly vertical or horizontal edge would have a bounds 0 width or height\r\n    // this causes problems for the collision system so we give them some padding\r\n    return new BoundingBox(\r\n      Math.min(begin.x, end.x) - padding,\r\n      Math.min(begin.y, end.y) - padding,\r\n      Math.max(begin.x, end.x) + padding,\r\n      Math.max(begin.y, end.y) + padding\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in world space\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    return this._boundsFromBeginEnd(transformedBegin, transformedEnd);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in local space\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return this._boundsFromBeginEnd(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Returns this edge represented as a line in world coordinates\r\n   */\r\n  public asLine(): LineSegment {\r\n    return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());\r\n  }\r\n\r\n  /**\r\n   * Return this edge as a line in local line coordinates (relative to the position)\r\n   */\r\n  public asLocalLine(): LineSegment {\r\n    return new LineSegment(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the edge\r\n   */\r\n  public get axes(): Vector[] {\r\n    const e = this._getTransformedEnd().sub(this._getTransformedBegin());\r\n    const edgeNormal = e.normal();\r\n\r\n    const axes = [];\r\n    axes.push(edgeNormal);\r\n    axes.push(edgeNormal.negate());\r\n    axes.push(edgeNormal.normal());\r\n    axes.push(edgeNormal.normal().negate());\r\n    return axes;\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia for an edge\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    const length = this.end.sub(this.begin).distance() / 2;\r\n    return mass * length * length;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    const globalMat = transform.matrix ?? this._globalMatrix;\r\n    globalMat.clone(this._globalMatrix);\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Project the edge along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n\r\n    const points = [this._getTransformedBegin(), this._getTransformedEnd()];\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      scalars.push(points[i].dot(axis));\r\n    }\r\n\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    ex.drawLine(begin, end, color, 2);\r\n    ex.drawCircle(begin, 2, color);\r\n    ex.drawCircle(end, 2, color);\r\n  }\r\n\r\n}\r\n","import { Color } from '../../Color';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\nimport { Ray } from '../../Math/ray';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Collider } from './Collider';\r\nimport { ExcaliburGraphicsContext, Logger, range } from '../..';\r\nimport { CompositeCollider } from './CompositeCollider';\r\nimport { Shape } from './Shape';\r\nimport { Transform } from '../../Math/transform';\r\n\r\nexport interface PolygonColliderOptions {\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   */\r\n  points: Vector[];\r\n}\r\n\r\n/**\r\n * Polygon collider for detecting collisions\r\n */\r\nexport class PolygonCollider extends Collider {\r\n  private _logger = Logger.getInstance();\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  public offset: Vector;\r\n\r\n  private _points: Vector[];\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   * Excalibur stores these in counter-clockwise order\r\n   */\r\n  public set points(points: Vector[]) {\r\n    this._localBoundsDirty = true;\r\n    this._localSidesDirty = true;\r\n    this._sidesDirty = true;\r\n    this._points = points;\r\n  }\r\n\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   * Excalibur stores these in counter-clockwise order\r\n   */\r\n  public get points(): Vector[] {\r\n    return this._points;\r\n  }\r\n\r\n  private _transform: Transform;\r\n\r\n  private _transformedPoints: Vector[] = [];\r\n  private _sides: LineSegment[] = [];\r\n  private _localSides: LineSegment[] = [];\r\n\r\n  constructor(options: PolygonColliderOptions) {\r\n    super();\r\n    this.offset = options.offset ?? Vector.Zero;\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    this.points = options.points ?? [];\r\n    const counterClockwise = this._isCounterClockwiseWinding(this.points);\r\n    if (!counterClockwise) {\r\n      this.points.reverse();\r\n    }\r\n    if (!this.isConvex()) {\r\n      this._logger.warn(\r\n        'Excalibur only supports convex polygon colliders and will not behave properly.'+\r\n        'Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles');\r\n    }\r\n\r\n    // calculate initial transformation\r\n    this._calculateTransformation();\r\n  }\r\n\r\n  private _isCounterClockwiseWinding(points: Vector[]): boolean {\r\n    // https://stackoverflow.com/a/1165943\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length; i++) {\r\n      sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);\r\n    }\r\n    return sum < 0;\r\n  }\r\n\r\n  /**\r\n   * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.\r\n   * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape\r\n   */\r\n  public isConvex(): boolean {\r\n    // From SO: https://stackoverflow.com/a/45372025\r\n    if (this.points.length < 3) {\r\n      return false;\r\n    }\r\n    let oldPoint = this.points[this.points.length - 2];\r\n    let newPoint = this.points[this.points.length - 1];\r\n    let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n    let oldDirection = 0;\r\n    let orientation = 0;\r\n    let angleSum = 0;\r\n    for (const [i, point] of this.points.entries()) {\r\n      oldPoint = newPoint;\r\n      oldDirection = direction;\r\n      newPoint =  point;\r\n      direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n      if (oldPoint.equals(newPoint)) {\r\n        return false; // repeat point\r\n      }\r\n      let angle = direction - oldDirection;\r\n      if (angle <= -Math.PI){\r\n        angle += Math.PI * 2;\r\n      } else if (angle > Math.PI) {\r\n        angle -= Math.PI * 2;\r\n      }\r\n      if (i === 0) {\r\n        if (angle === 0.0) {\r\n          return false;\r\n        }\r\n        orientation = angle  > 0 ? 1 : -1;\r\n      } else {\r\n        if (orientation * angle <= 0) {\r\n          return false;\r\n        }\r\n      }\r\n      angleSum += angle;\r\n    }\r\n    return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;\r\n  }\r\n\r\n  /**\r\n   * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons\r\n   */\r\n  public tessellate(): CompositeCollider {\r\n    const polygons: Vector[][] = [];\r\n    for (let i = 1; i < this.points.length - 2; i++) {\r\n      polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);\r\n    }\r\n    polygons.push([this.points[0], this.points[1], this.points[2]]);\r\n\r\n    return new CompositeCollider(polygons.map(points => Shape.Polygon(points)));\r\n  }\r\n\r\n  /**\r\n   * Triangulate the polygon collider using the \"Ear Clipping\" algorithm.\r\n   * Returns a new [[CompositeCollider]] made up of smaller triangles.\r\n   */\r\n  public triangulate(): CompositeCollider {\r\n    // https://www.youtube.com/watch?v=hTJFcHutls8\r\n    if (this.points.length < 3) {\r\n      throw Error('Invalid polygon');\r\n    }\r\n\r\n    /**\r\n     * Helper to get a vertex in the list\r\n     */\r\n    function getItem<T>(index: number, list: T[]) {\r\n      if (index >= list.length) {\r\n        return list[index % list.length];\r\n      } else if (index < 0) {\r\n        return list[index % list.length + list.length];\r\n      } else {\r\n        return list[index];\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Quick test for point in triangle\r\n     */\r\n    function isPointInTriangle(point: Vector, a: Vector, b: Vector, c: Vector) {\r\n      const ab = b.sub(a);\r\n      const bc = c.sub(b);\r\n      const ca = a.sub(c);\r\n\r\n      const ap = point.sub(a);\r\n      const bp = point.sub(b);\r\n      const cp = point.sub(c);\r\n\r\n      const cross1 = ab.cross(ap);\r\n      const cross2 = bc.cross(bp);\r\n      const cross3 = ca.cross(cp);\r\n\r\n      if (cross1 > 0 || cross2 > 0 || cross3 > 0) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    const triangles: Vector[][] = [];\r\n    const vertices = [...this.points];\r\n    const indices = range(0, this.points.length - 1);\r\n\r\n    // 1. Loop through vertices clockwise\r\n    //    if the vertex is convex (interior angle is < 180) (cross product positive)\r\n    //    if the polygon formed by it's edges doesn't contain the points\r\n    //         it's an ear add it to our list of triangles, and restart\r\n\r\n    while (indices.length > 3) {\r\n      for (let i = 0; i < indices.length; i++) {\r\n        const a = indices[i];\r\n        const b = getItem(i - 1, indices);\r\n        const c = getItem(i + 1, indices);\r\n\r\n        const va = vertices[a];\r\n        const vb = vertices[b];\r\n        const vc = vertices[c];\r\n\r\n        // Check convexity\r\n        const leftArm = vb.sub(va);\r\n        const rightArm = vc.sub(va);\r\n        const isConvex = rightArm.cross(leftArm) > 0; // positive cross means convex\r\n        if (!isConvex) {\r\n          continue;\r\n        }\r\n\r\n        let isEar = true;\r\n        // Check that if any vertices are in the triangle a, b, c\r\n        for (let j = 0; j < indices.length; j++) {\r\n          const vertIndex = indices[j];\r\n          // We can skip these\r\n          if (vertIndex === a || vertIndex === b || vertIndex === c) {\r\n            continue;\r\n          }\r\n\r\n          const point = vertices[vertIndex];\r\n          if (isPointInTriangle(point, vb, va, vc)) {\r\n            isEar = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Add ear to polygon list and remove from list\r\n        if (isEar) {\r\n          triangles.push([vb, va, vc]);\r\n          indices.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    triangles.push([vertices[indices[0]], vertices[indices[1]], vertices[indices[2]]]);\r\n\r\n    return new CompositeCollider(triangles.map(points => Shape.Polygon(points)));\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this ConvexPolygon, not associated with any collider\r\n   */\r\n  public clone(): PolygonCollider {\r\n    return new PolygonCollider({\r\n      offset: this.offset.clone(),\r\n      points: this.points.map((p) => p.clone())\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the world position of the collider, which is the current body transform plus any defined offset\r\n   */\r\n  public get worldPos(): Vector {\r\n    if (this._transform) {\r\n      return this._transform.pos.add(this.offset);\r\n    }\r\n    return this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    return this.bounds.center;\r\n  }\r\n\r\n  private _globalMatrix: AffineMatrix = AffineMatrix.identity();\r\n\r\n  private _transformedPointsDirty = true;\r\n  /**\r\n   * Calculates the underlying transformation from the body relative space to world space\r\n   */\r\n  private _calculateTransformation() {\r\n    const points = this.points;\r\n    const len = points.length;\r\n    this._transformedPoints.length = 0; // clear out old transform\r\n    for (let i = 0; i < len; i++) {\r\n      this._transformedPoints[i] = this._globalMatrix.multiply(points[i].clone());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the points that make up the polygon in world space, from actor relative space (if specified)\r\n   */\r\n  public getTransformedPoints(): Vector[] {\r\n    if (this._transformedPointsDirty) {\r\n      this._calculateTransformation();\r\n      this._transformedPointsDirty = false;\r\n    }\r\n    return this._transformedPoints;\r\n  }\r\n\r\n  private _sidesDirty = true;\r\n  /**\r\n   * Gets the sides of the polygon in world space\r\n   */\r\n  public getSides(): LineSegment[] {\r\n    if (this._sidesDirty) {\r\n      const lines = [];\r\n      const points = this.getTransformedPoints();\r\n      const len = points.length;\r\n      for (let i = 0; i < len; i++) {\r\n        // This winding is important\r\n        lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n      }\r\n      this._sides = lines;\r\n      this._sidesDirty = false;\r\n    }\r\n    return this._sides;\r\n  }\r\n\r\n  private _localSidesDirty = true;\r\n  /**\r\n   * Returns the local coordinate space sides\r\n   */\r\n  public getLocalSides(): LineSegment[] {\r\n    if (this._localSidesDirty) {\r\n      const lines = [];\r\n      const points = this.points;\r\n      const len = points.length;\r\n      for (let i = 0; i < len; i++) {\r\n        // This winding is important\r\n        lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n      }\r\n      this._localSides = lines;\r\n      this._localSidesDirty = false;\r\n    }\r\n\r\n    return this._localSides;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the world space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findSide(direction: Vector): LineSegment {\r\n    const sides = this.getSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the local space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findLocalSide(direction: Vector): LineSegment {\r\n    const sides = this.getLocalSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the convex polygon\r\n   */\r\n  public get axes(): Vector[] {\r\n    const axes: Vector[] = [];\r\n    const sides = this.getSides();\r\n    for (let i = 0; i < sides.length; i++) {\r\n      axes.push(sides[i].normal());\r\n    }\r\n    return axes;\r\n  }\r\n\r\n  /**\r\n   * Updates the transform for the collision geometry\r\n   *\r\n   * Collision geometry (points/bounds) will not change until this is called.\r\n   * @param transform\r\n   */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    this._transformedPointsDirty = true;\r\n    this._sidesDirty = true;\r\n    // This change means an update must be performed in order for geometry to update\r\n    const globalMat = transform.matrix ?? this._globalMatrix;\r\n    globalMat.clone(this._globalMatrix);\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider in world space\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    // Always cast to the right, as long as we cast in a consistent fixed direction we\r\n    // will be fine\r\n    const testRay = new Ray(point, new Vector(1, 0));\r\n    const intersectCount = this.getSides().reduce(function (accum, side) {\r\n      if (testRay.intersect(side) >= 0) {\r\n        return accum + 1;\r\n      }\r\n      return accum;\r\n    }, 0);\r\n\r\n    if (intersectCount % 2 === 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public getClosestLineBetween(collider: Collider): LineSegment {\r\n    if (collider instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a collision contact if the 2 colliders collide, otherwise collide will\r\n   * return null.\r\n   * @param collider\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(collider, this);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonPolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const pts = this.getTransformedPoints();\r\n    let furthestPoint = null;\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the collider furthest in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const pts = this.points;\r\n    let furthestPoint = pts[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Finds the closes face to the point using perpendicular distance\r\n   * @param point point to test against polygon\r\n   */\r\n  public getClosestFace(point: Vector): { distance: Vector; face: LineSegment } {\r\n    const sides = this.getSides();\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let faceIndex = -1;\r\n    let distance = -1;\r\n    for (let i = 0; i < sides.length; i++) {\r\n      const dist = sides[i].distanceToPoint(point);\r\n      if (dist < min) {\r\n        min = dist;\r\n        faceIndex = i;\r\n        distance = dist;\r\n      }\r\n    }\r\n\r\n    if (faceIndex !== -1) {\r\n      return {\r\n        distance: sides[faceIndex].normal().scale(distance),\r\n        face: sides[faceIndex]\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    return this.localBounds.transform(this._globalMatrix);\r\n  }\r\n\r\n  private _localBoundsDirty = true;\r\n  private _localBounds: BoundingBox;\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    if (this._localBoundsDirty) {\r\n      this._localBounds = BoundingBox.fromPoints(this.points);\r\n      this._localBoundsDirty = false;\r\n    }\r\n\r\n    return this._localBounds;\r\n  }\r\n\r\n  private _cachedMass: number;\r\n  private _cachedInertia: number;\r\n  /**\r\n   * Get the moment of inertia for an arbitrary polygon\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    if (this._cachedMass === mass && this._cachedInertia) {\r\n      return this._cachedInertia;\r\n    }\r\n    let numerator = 0;\r\n    let denominator = 0;\r\n    const points = this.points;\r\n    for (let i = 0; i < points.length; i++) {\r\n      const iplusone = (i + 1) % points.length;\r\n      const crossTerm = points[iplusone].cross(points[i]);\r\n      numerator +=\r\n        crossTerm *\r\n        (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));\r\n      denominator += crossTerm;\r\n    }\r\n    this._cachedMass = mass;\r\n    return this._cachedInertia = (mass / 6) * (numerator / denominator);\r\n  }\r\n\r\n  /**\r\n   * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity) {\r\n    // find the minimum contact time greater than 0\r\n    // contact times less than 0 are behind the ray and we don't want those\r\n    const sides = this.getSides();\r\n    const len = sides.length;\r\n    let minContactTime = Number.MAX_VALUE;\r\n    let contactIndex = -1;\r\n    for (let i = 0; i < len; i++) {\r\n      const contactTime = ray.intersect(sides[i]);\r\n      if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {\r\n        minContactTime = contactTime;\r\n        contactIndex = i;\r\n      }\r\n    }\r\n\r\n    // contact was found\r\n    if (contactIndex >= 0) {\r\n      return ray.getPoint(minContactTime);\r\n    }\r\n\r\n    // no contact found\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Project the edges of the polygon along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const points = this.getTransformedPoints();\r\n    const len = points.length;\r\n    let min = Number.MAX_VALUE;\r\n    let max = -Number.MAX_VALUE;\r\n    for (let i = 0; i < len; i++) {\r\n      const scalar = points[i].dot(axis);\r\n      min = Math.min(min, scalar);\r\n      max = Math.max(max, scalar);\r\n    }\r\n\r\n    return new Projection(min, max);\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const firstPoint = this.getTransformedPoints()[0];\r\n    const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n      ex.drawLine(points[i], points[i + 1], color, 2);\r\n      ex.drawCircle(points[i], 2, color);\r\n      ex.drawCircle(points[i + 1], 2, color);\r\n    }\r\n  }\r\n}\r\n","import { PolygonCollider } from './PolygonCollider';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { CompositeCollider } from './CompositeCollider';\r\nimport { Logger } from '../..';\r\n\r\n/**\r\n * Excalibur helper for defining colliders quickly\r\n */\r\nexport class Shape {\r\n  /**\r\n   * Creates a box collider, under the hood defines a [[PolygonCollider]] collider\r\n   * @param width Width of the box\r\n   * @param height Height of the box\r\n   * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Box(width: number, height: number, anchor: Vector = Vector.Half, offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[PolygonCollider|arbitrary polygon]] collider\r\n   *\r\n   * PolygonColliders are useful for creating convex polygon shapes\r\n   * @param points Points specified in counter clockwise\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Polygon(points: Vector[], offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: points,\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[CircleCollider|circle]] collider\r\n   *\r\n   * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges\r\n   * @param radius Radius of the circle collider\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Circle(radius: number, offset: Vector = Vector.Zero): CircleCollider {\r\n    return new CircleCollider({\r\n      radius: radius,\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[EdgeCollider|edge]] collider\r\n   *\r\n   * Edge colliders are useful for  floors, walls, and other barriers\r\n   * @param begin Beginning of the edge in local coordinates to the collider\r\n   * @param end Ending of the edge in local coordinates to the collider\r\n   */\r\n  static Edge(begin: Vector, end: Vector): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: begin,\r\n      end: end\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box\r\n   *\r\n   * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth\r\n   * player experience.\r\n   *\r\n   * @param width\r\n   * @param height\r\n   * @param offset Optional offset\r\n   */\r\n  static Capsule(width: number, height: number, offset = Vector.Zero): CompositeCollider {\r\n    const logger = Logger.getInstance();\r\n    if (width === height) {\r\n      logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');\r\n    }\r\n\r\n    const vertical = height >= width;\r\n\r\n    if (vertical) {\r\n      // height > width, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),\r\n        Shape.Box(width, height - width, Vector.Half, offset),\r\n        Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))\r\n      ]);\r\n      return capsule;\r\n    } else {\r\n      // width > height, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),\r\n        Shape.Box(width - height, height, Vector.Half, offset),\r\n        Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))\r\n      ]);\r\n      return capsule;\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { CollisionEndEvent, CollisionStartEvent, PostCollisionEvent, PreCollisionEvent } from '../Events';\r\nimport { Observable } from '../Util/Observable';\r\nimport { BoundingBox } from './BoundingBox';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { CircleCollider } from './Colliders/CircleCollider';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { PolygonCollider } from './Colliders/PolygonCollider';\r\nimport { EdgeCollider } from './Colliders/EdgeCollider';\r\nimport { Shape } from './Colliders/Shape';\r\n\r\nexport class ColliderComponent extends Component<'ex.collider'> {\r\n  public readonly type = 'ex.collider';\r\n\r\n  public events = new EventDispatcher();\r\n  /**\r\n   * Observable that notifies when a collider is added to the body\r\n   */\r\n  public $colliderAdded = new Observable<Collider>();\r\n\r\n  /**\r\n   * Observable that notifies when a collider is removed from the body\r\n   */\r\n  public $colliderRemoved = new Observable<Collider>();\r\n\r\n  constructor(collider?: Collider) {\r\n    super();\r\n    this.set(collider);\r\n  }\r\n\r\n  private _collider: Collider;\r\n  /**\r\n   * Get the current collider geometry\r\n   */\r\n  public get() {\r\n    return this._collider;\r\n  }\r\n\r\n  /**\r\n   * Set the collider geometry\r\n   * @param collider\r\n   * @returns the collider you set\r\n   */\r\n  public set<T extends Collider>(collider: T): T {\r\n    this.clear();\r\n    if (collider) {\r\n      this._collider = collider;\r\n      this._collider.owner = this.owner;\r\n      this.events.wire(collider.events);\r\n      this.$colliderAdded.notifyAll(collider);\r\n      this.update();\r\n    }\r\n    return collider;\r\n  }\r\n\r\n  /**\r\n   * Remove collider geometry from collider component\r\n   */\r\n  public clear() {\r\n    if (this._collider) {\r\n      this.events.unwire(this._collider.events);\r\n      this.$colliderRemoved.notifyAll(this._collider);\r\n      this._collider.owner = null;\r\n      this._collider = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return world space bounds\r\n   */\r\n  public get bounds() {\r\n    return this._collider?.bounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Return local space bounds\r\n   */\r\n  public get localBounds() {\r\n    return this._collider?.localBounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Update the collider's transformed geometry\r\n   */\r\n  public update() {\r\n    const tx = this.owner?.get(TransformComponent);\r\n    if (this._collider) {\r\n      this._collider.owner = this.owner;\r\n      if (tx) {\r\n        this._collider.update(tx.get());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collide component with another\r\n   * @param other\r\n   */\r\n  collide(other: ColliderComponent): CollisionContact[] {\r\n    let colliderA = this._collider;\r\n    let colliderB = other._collider;\r\n    if (!colliderA || !colliderB) {\r\n      return [];\r\n    }\r\n\r\n    // If we have a composite lefthand side :(\r\n    // Might bite us, but to avoid updating all the handlers make composite always left side\r\n    let flipped = false;\r\n    if (colliderB instanceof CompositeCollider) {\r\n      colliderA = colliderB;\r\n      colliderB = this._collider;\r\n      flipped = true;\r\n    }\r\n\r\n    if (this._collider) {\r\n      const contacts = colliderA.collide(colliderB);\r\n      if (contacts) {\r\n        if (flipped) {\r\n          contacts.forEach((contact) => {\r\n            contact.mtv = contact.mtv.negate();\r\n            contact.normal = contact.normal.negate();\r\n            contact.tangent = contact.normal.perpendicular();\r\n            contact.colliderA = this._collider;\r\n            contact.colliderB = other._collider;\r\n          });\r\n        }\r\n        return contacts;\r\n      }\r\n      return [];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  onAdd(entity: Entity) {\r\n    if (this._collider) {\r\n      this.update();\r\n    }\r\n    // Wire up the collider events to the owning entity\r\n    this.events.on('precollision', (evt: any) => {\r\n      const precollision = evt as PreCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('postcollision', (evt: any) => {\r\n      const postcollision = evt as PostCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('collisionstart', (evt: any) => {\r\n      const start = evt as CollisionStartEvent<Collider>;\r\n      entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));\r\n    });\r\n    this.events.on('collisionend', (evt: any) => {\r\n      const end = evt as CollisionEndEvent<Collider>;\r\n      entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));\r\n    });\r\n  }\r\n\r\n  onRemove() {\r\n    this.events.clear();\r\n    this.$colliderRemoved.notifyAll(this._collider);\r\n  }\r\n\r\n  /**\r\n   * Sets up a box geometry based on the current bounds of the associated actor of this physics body.\r\n   *\r\n   * If no width/height are specified the body will attempt to use the associated actor's width/height.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useBoxCollider(width: number, height: number, anchor: Vector = Vector.Half, center: Vector = Vector.Zero): PolygonCollider {\r\n    const collider = Shape.Box(width, height, anchor, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative\r\n   *  to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  usePolygonCollider(points: Vector[], center: Vector = Vector.Zero): PolygonCollider {\r\n    const poly = Shape.Polygon(points, center);\r\n    return (this.set(poly));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useCircleCollider(radius: number, center: Vector = Vector.Zero): CircleCollider {\r\n    const collider = Shape.Circle(radius, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useEdgeCollider(begin: Vector, end: Vector): EdgeCollider {\r\n    const collider = Shape.Edge(begin, end);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders\r\n   * @param colliders\r\n   */\r\n  useCompositeCollider(colliders: Collider[]): CompositeCollider {\r\n    return (this.set(new CompositeCollider(colliders)));\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { CollisionType } from './CollisionType';\r\nimport { Physics } from './Physics';\r\nimport { Clonable } from '../Interfaces/Clonable';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { CollisionGroup } from './Group/CollisionGroup';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { createId, Id } from '../Id';\r\nimport { clamp } from '../Math/util';\r\nimport { ColliderComponent } from './ColliderComponent';\r\nimport { Transform } from '../Math/transform';\r\n\r\nexport interface BodyComponentOptions {\r\n  type?: CollisionType;\r\n  group?: CollisionGroup;\r\n  useGravity?: boolean;\r\n}\r\n\r\nexport enum DegreeOfFreedom {\r\n  Rotation = 'rotation',\r\n  X = 'x',\r\n  Y = 'y'\r\n}\r\n\r\n/**\r\n * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of\r\n * of physics simulation.\r\n */\r\nexport class BodyComponent extends Component<'ex.body'> implements Clonable<BodyComponent> {\r\n  public readonly type = 'ex.body';\r\n  public dependencies = [TransformComponent, MotionComponent];\r\n  public static _ID = 0;\r\n  public readonly id: Id<'body'> = createId('body', BodyComponent._ID++);\r\n  public events = new EventDispatcher();\r\n\r\n  private _oldTransform = new Transform();\r\n\r\n  /**\r\n   * Indicates whether the old transform has been captured at least once for interpolation\r\n   * @internal\r\n   */\r\n  public __oldTransformCaptured: boolean = false;\r\n\r\n  /**\r\n   * Enable or disabled the fixed update interpolation, by default interpolation is on.\r\n   */\r\n  public enableFixedUpdateInterpolate = true;\r\n\r\n  constructor(options?: BodyComponentOptions) {\r\n    super();\r\n    if (options) {\r\n      this.collisionType = options.type ?? this.collisionType;\r\n      this.group = options.group ?? this.group;\r\n      this.useGravity = options.useGravity ?? this.useGravity;\r\n    }\r\n  }\r\n\r\n  public get matrix() {\r\n    return this.transform.get().matrix;\r\n  }\r\n\r\n  /**\r\n   * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]\r\n   */\r\n  public collisionType: CollisionType = CollisionType.PreventCollision;\r\n\r\n  /**\r\n   * The collision group for the body's colliders, by default body colliders collide with everything\r\n   */\r\n  public group: CollisionGroup = CollisionGroup.All;\r\n\r\n  /**\r\n   * The amount of mass the body has\r\n   */\r\n  private _mass: number = Physics.defaultMass;\r\n  public get mass(): number {\r\n    return this._mass;\r\n  }\r\n\r\n  public set mass(newMass: number) {\r\n    this._mass = newMass;\r\n    this._cachedInertia = undefined;\r\n    this._cachedInverseInertia = undefined;\r\n  }\r\n\r\n  /**\r\n   * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseMass(): number {\r\n    return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;\r\n  }\r\n\r\n  /**\r\n   * Amount of \"motion\" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to \"sleep\"\r\n   */\r\n  public sleepMotion: number = Physics.sleepEpsilon * 5;\r\n\r\n  /**\r\n   * Can this body sleep, by default bodies do not sleep\r\n   */\r\n  public canSleep: boolean = Physics.bodiesCanSleepByDefault;\r\n\r\n  private _sleeping = false;\r\n  /**\r\n   * Whether this body is sleeping or not\r\n   */\r\n  public get sleeping(): boolean {\r\n    return this._sleeping;\r\n  }\r\n\r\n  /**\r\n   * Set the sleep state of the body\r\n   * @param sleeping\r\n   */\r\n  public setSleeping(sleeping: boolean) {\r\n    this._sleeping = sleeping;\r\n    if (!sleeping) {\r\n      // Give it a kick to keep it from falling asleep immediately\r\n      this.sleepMotion = Physics.sleepEpsilon * 5;\r\n    } else {\r\n      this.vel = Vector.Zero;\r\n      this.acc = Vector.Zero;\r\n      this.angularVelocity = 0;\r\n      this.sleepMotion = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping\r\n   */\r\n  public updateMotion() {\r\n    if (this._sleeping) {\r\n      this.setSleeping(true);\r\n    }\r\n    const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);\r\n    const bias = Physics.sleepBias;\r\n    this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;\r\n    this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);\r\n    if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {\r\n      this.setSleeping(true);\r\n    }\r\n  }\r\n\r\n  private _cachedInertia: number;\r\n  /**\r\n   * Get the moment of inertia from the [[ColliderComponent]]\r\n   */\r\n  public get inertia() {\r\n    if (this._cachedInertia) {\r\n      return this._cachedInertia;\r\n    }\r\n\r\n    // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?\r\n    const collider = this.owner.get(ColliderComponent);\r\n    if (collider) {\r\n      collider.$colliderAdded.subscribe(() => {\r\n        this._cachedInertia = null;\r\n      });\r\n      collider.$colliderRemoved.subscribe(() => {\r\n        this._cachedInertia = null;\r\n      });\r\n      const maybeCollider = collider.get();\r\n      if (maybeCollider) {\r\n        return this._cachedInertia = maybeCollider.getInertia(this.mass);\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private _cachedInverseInertia: number;\r\n  /**\r\n   * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseInertia() {\r\n    if (this._cachedInverseInertia) {\r\n      return this._cachedInverseInertia;\r\n    }\r\n    return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;\r\n  }\r\n\r\n  /**\r\n   * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the\r\n   * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.\r\n   */\r\n  public bounciness: number = 0.2;\r\n\r\n  /**\r\n   * The coefficient of friction on this actor\r\n   */\r\n  public friction: number = 0.99;\r\n\r\n  /**\r\n   * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true\r\n   */\r\n  public useGravity: boolean = true;\r\n\r\n  /**\r\n   * Degrees of freedom to limit\r\n   *\r\n   * Note: this only limits responses in the realistic solver, if velocity/angularVelocity is set the actor will still respond\r\n   */\r\n  public limitDegreeOfFreedom: DegreeOfFreedom[] = [];\r\n\r\n  /**\r\n   * Returns if the owner is active\r\n   */\r\n  public get active() {\r\n    return !!this.owner?.active;\r\n  }\r\n\r\n  /**\r\n   * @deprecated Use globalP0s\r\n   */\r\n  public get center() {\r\n    return this.globalPos;\r\n  }\r\n\r\n  public get transform(): TransformComponent {\r\n    return this.owner?.get(TransformComponent);\r\n  }\r\n\r\n  public get motion(): MotionComponent {\r\n    return  this.owner?.get(MotionComponent);\r\n  }\r\n\r\n  public get pos(): Vector {\r\n    return this.transform.pos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this.transform.pos = val;\r\n  }\r\n\r\n  /**\r\n   * The (x, y) position of the actor this will be in the middle of the actor if the\r\n   * [[Actor.anchor]] is set to (0.5, 0.5) which is default.\r\n   * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).\r\n   */\r\n  public get globalPos(): Vector {\r\n    return this.transform.globalPos;\r\n  }\r\n\r\n  public set globalPos(val: Vector) {\r\n    this.transform.globalPos = val;\r\n  }\r\n\r\n  /**\r\n   * The position of the actor last frame (x, y) in pixels\r\n   */\r\n  public get oldPos(): Vector {\r\n    return this._oldTransform.pos;\r\n  }\r\n\r\n  /**\r\n   * The current velocity vector (vx, vy) of the actor in pixels/second\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this.motion.vel = val;\r\n  }\r\n\r\n  /**\r\n   * The velocity of the actor last frame (vx, vy) in pixels/second\r\n   */\r\n  public oldVel: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may\r\n   * be useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  public set acc(val: Vector) {\r\n    this.motion.acc = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public oldAcc: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The current torque applied to the actor\r\n   */\r\n  public get torque(): number {\r\n    return this.motion.torque;\r\n  }\r\n\r\n  public set torque(val: number) {\r\n    this.motion.torque = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the rotation of the body from the last frame.\r\n   */\r\n  public get oldRotation(): number {\r\n    return this._oldTransform.rotation;\r\n  }\r\n\r\n  /**\r\n   * The rotation of the body in radians\r\n   */\r\n  public get rotation() {\r\n    return this.transform.globalRotation;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    this.transform.globalRotation = val;\r\n  }\r\n\r\n  /**\r\n   * The scale vector of the actor\r\n   */\r\n  public get scale(): Vector {\r\n    return this.transform.globalScale;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    this.transform.globalScale = val;\r\n  }\r\n\r\n  /**\r\n   * The scale of the actor last frame\r\n   */\r\n  public get oldScale(): Vector {\r\n    return this._oldTransform.scale;\r\n  }\r\n\r\n  /**\r\n   * The scale rate of change of the actor in scale/second\r\n   */\r\n  public get scaleFactor(): Vector {\r\n    return this.motion.scaleFactor;\r\n  }\r\n\r\n  public set scaleFactor(scaleFactor: Vector) {\r\n    this.motion.scaleFactor = scaleFactor;\r\n  }\r\n\r\n  /**\r\n   * Get the angular velocity in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Set the angular velocity in radians/second\r\n   */\r\n  public set angularVelocity(value: number) {\r\n    this.motion.angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Apply a specific impulse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel.addEqual(finalImpulse);\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.globalPos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply only linear impulse to the body\r\n   * @param impulse\r\n   */\r\n  public applyLinearImpulse(impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel = this.vel.add(finalImpulse);\r\n  }\r\n\r\n  /**\r\n   * Apply only angular impulse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyAngularImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.globalPos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the old versions of pos, vel, acc, and scale.\r\n   */\r\n  public captureOldTransform() {\r\n    // Capture old values before integration step updates them\r\n    this.__oldTransformCaptured = true;\r\n    this.transform.get().clone(this._oldTransform);\r\n    this.oldVel.setTo(this.vel.x, this.vel.y);\r\n    this.oldAcc.setTo(this.acc.x, this.acc.y);\r\n  }\r\n}\r\n","import { Component, ComponentCtor, TagComponent } from './Component';\r\n\r\nimport { Observable, Message } from '../Util/Observable';\r\nimport { Class } from '../Class';\r\nimport { OnInitialize, OnPreUpdate, OnPostUpdate } from '../Interfaces/LifecycleEvents';\r\nimport { Engine } from '../Engine';\r\nimport { InitializeEvent, PreUpdateEvent, PostUpdateEvent } from '../Events';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { Util } from '..';\r\n\r\n/**\r\n * Interface holding an entity component pair\r\n */\r\nexport interface EntityComponent {\r\n  component: Component;\r\n  entity: Entity;\r\n}\r\n\r\n/**\r\n * AddedComponent message\r\n */\r\nexport class AddedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Added' = 'Component Added';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is f an Added Component\r\n */\r\nexport function isAddedComponent(x: Message<EntityComponent>): x is AddedComponent {\r\n  return !!x && x.type === 'Component Added';\r\n}\r\n\r\n/**\r\n * RemovedComponent message\r\n */\r\nexport class RemovedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Removed' = 'Component Removed';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is for a Removed Component\r\n */\r\nexport function isRemovedComponent(x: Message<EntityComponent>): x is RemovedComponent {\r\n  return !!x && x.type === 'Component Removed';\r\n}\r\n\r\n/**\r\n * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system\r\n *\r\n * Entities can be strongly typed with the components they contain\r\n *\r\n * ```typescript\r\n * const entity = new Entity<ComponentA | ComponentB>();\r\n * entity.components.a; // Type ComponentA\r\n * entity.components.b; // Type ComponentB\r\n * ```\r\n */\r\nexport class Entity extends Class implements OnInitialize, OnPreUpdate, OnPostUpdate {\r\n  private static _ID = 0;\r\n\r\n  constructor(components?: Component[], name?: string) {\r\n    super();\r\n    this._setName(name);\r\n    if (components) {\r\n      for (const component of components) {\r\n        this.addComponent(component);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The unique identifier for the entity\r\n   */\r\n  public id: number = Entity._ID++;\r\n\r\n  private _name: string = 'anonymous';\r\n  protected _setName(name: string) {\r\n    if (name) {\r\n      this._name = name;\r\n    }\r\n  }\r\n  public get name(): string {\r\n    return this._name;\r\n  }\r\n\r\n  public get events(): EventDispatcher {\r\n    return this.eventDispatcher;\r\n  }\r\n\r\n  /**\r\n   * Whether this entity is active, if set to false it will be reclaimed\r\n   */\r\n  public active: boolean = true;\r\n\r\n  /**\r\n   * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.\r\n   */\r\n  public kill() {\r\n    this.active = false;\r\n  }\r\n\r\n  public isKilled() {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Specifically get the tags on the entity from [[TagComponent]]\r\n   */\r\n  public get tags(): readonly string[] {\r\n    return this._tagsMemo;\r\n  }\r\n\r\n  /**\r\n   * Check if a tag exists on the entity\r\n   * @param tag name to check for\r\n   */\r\n  public hasTag(tag: string): boolean {\r\n    return this.tags.includes(tag);\r\n  }\r\n\r\n  /**\r\n   * Adds a tag to an entity\r\n   * @param tag\r\n   * @returns Entity\r\n   */\r\n  public addTag(tag: string) {\r\n    return this.addComponent(new TagComponent(tag));\r\n  }\r\n\r\n  /**\r\n   * Removes a tag on the entity\r\n   *\r\n   * Removals are deferred until the end of update\r\n   * @param tag\r\n   * @param force Remove component immediately, no deferred\r\n   */\r\n  public removeTag(tag: string, force = false) {\r\n    return this.removeComponent(tag, force);\r\n  }\r\n\r\n  /**\r\n   * The types of the components on the Entity\r\n   */\r\n  public get types(): string[] {\r\n    return this._typesMemo;\r\n  }\r\n\r\n  /**\r\n   * Bucket to hold on to deferred removals\r\n   */\r\n  private _componentsToRemove: (Component | string)[] = [];\r\n  private _componentTypeToInstance = new Map<ComponentCtor, Component>();\r\n  private _componentStringToInstance = new Map<string, Component>();\r\n\r\n  private _tagsMemo: string[] = [];\r\n  private _typesMemo: string[] = [];\r\n  private _rebuildMemos() {\r\n    this._tagsMemo = Array.from(this._componentStringToInstance.values())\r\n      .filter((c) => c instanceof TagComponent)\r\n      .map((c) => c.type);\r\n    this._typesMemo = Array.from(this._componentStringToInstance.keys());\r\n  }\r\n\r\n  public getComponents(): Component[] {\r\n    return Array.from(this._componentStringToInstance.values());\r\n  }\r\n\r\n  /**\r\n   * Observable that keeps track of component add or remove changes on the entity\r\n   */\r\n  public componentAdded$ = new Observable<AddedComponent>();\r\n  private _notifyAddComponent(component: Component) {\r\n    this._rebuildMemos();\r\n    const added = new AddedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentAdded$.notifyAll(added);\r\n  }\r\n\r\n  public componentRemoved$ = new Observable<RemovedComponent>();\r\n  private _notifyRemoveComponent(component: Component) {\r\n    const removed = new RemovedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentRemoved$.notifyAll(removed);\r\n    this._rebuildMemos();\r\n  }\r\n\r\n  private _parent: Entity = null;\r\n  public get parent(): Entity {\r\n    return this._parent;\r\n  }\r\n\r\n  public childrenAdded$ = new Observable<Entity>();\r\n  public childrenRemoved$ = new Observable<Entity>();\r\n\r\n  private _children: Entity[] = [];\r\n  /**\r\n   * Get the direct children of this entity\r\n   */\r\n  public get children(): readonly Entity[] {\r\n    return this._children;\r\n  }\r\n\r\n  /**\r\n   * Unparents this entity, if there is a parent. Otherwise it does nothing.\r\n   */\r\n  public unparent() {\r\n    if (this._parent) {\r\n      this._parent.removeChild(this);\r\n      this._parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be a child of this entity\r\n   * @param entity\r\n   */\r\n  public addChild(entity: Entity): Entity {\r\n    if (entity.parent === null) {\r\n      if (this.getAncestors().includes(entity)) {\r\n        throw new Error('Cycle detected, cannot add entity');\r\n      }\r\n      this._children.push(entity);\r\n      entity._parent = this;\r\n      this.childrenAdded$.notifyAll(entity);\r\n    } else {\r\n      throw new Error('Entity already has a parent, cannot add without unparenting');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from children if it exists\r\n   * @param entity\r\n   */\r\n  public removeChild(entity: Entity): Entity {\r\n    if (entity.parent === this) {\r\n      Util.removeItemFromArray(entity, this._children);\r\n      entity._parent = null;\r\n      this.childrenRemoved$.notifyAll(entity);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all children from this entity\r\n   */\r\n  public removeAllChildren(): Entity {\r\n    this.children.forEach((c) => {\r\n      this.removeChild(c);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of parent entities starting with the topmost parent. Includes the current entity.\r\n   */\r\n  public getAncestors(): Entity[] {\r\n    const result: Entity[] = [this];\r\n    let current = this.parent;\r\n    while (current) {\r\n      result.push(current);\r\n      current = current.parent;\r\n    }\r\n    return result.reverse();\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all the entities that descend from this entity. Includes the current entity.\r\n   */\r\n  public getDescendants(): Entity[] {\r\n    let result: Entity[] = [this];\r\n    let queue: Entity[] = [this];\r\n    while (queue.length > 0) {\r\n      const curr = queue.pop();\r\n      queue = queue.concat(curr.children);\r\n      result = result.concat(curr.children);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a deep copy of the entity and a copy of all its components\r\n   */\r\n  public clone(): Entity {\r\n    const newEntity = new Entity();\r\n    for (const c of this.types) {\r\n      newEntity.addComponent(this.get(c).clone());\r\n    }\r\n    for (const child of this.children) {\r\n      newEntity.addChild(child.clone());\r\n    }\r\n    return newEntity;\r\n  }\r\n\r\n  /**\r\n   * Adds a copy of all the components from another template entity as a \"prefab\"\r\n   * @param templateEntity Entity to use as a template\r\n   * @param force Force component replacement if it already exists on the target entity\r\n   */\r\n  public addTemplate(templateEntity: Entity, force: boolean = false): Entity {\r\n    for (const c of templateEntity.getComponents()) {\r\n      this.addComponent(c.clone(), force);\r\n    }\r\n    for (const child of templateEntity.children) {\r\n      this.addChild(child.clone().addTemplate(child));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a component to the entity\r\n   * @param component Component or Entity to add copy of components from\r\n   * @param force Optionally overwrite any existing components of the same type\r\n   */\r\n  public addComponent<T extends Component>(component: T, force: boolean = false): Entity {\r\n    // if component already exists, skip if not forced\r\n    if (this.has(component.type)) {\r\n      if (force) {\r\n        // Remove existing component type if exists when forced\r\n        this.removeComponent(component);\r\n      } else {\r\n        // early exit component exits\r\n        return this;\r\n      }\r\n    }\r\n\r\n    // TODO circular dependencies will be a problem\r\n    if (component.dependencies && component.dependencies.length) {\r\n      for (const ctor of component.dependencies) {\r\n        this.addComponent(new ctor());\r\n      }\r\n    }\r\n\r\n    component.owner = this;\r\n    const constuctorType = component.constructor as ComponentCtor<T>;\r\n    this._componentTypeToInstance.set(constuctorType, component);\r\n    this._componentStringToInstance.set(component.type, component);\r\n    if (component.onAdd) {\r\n      component.onAdd(this);\r\n    }\r\n    this._notifyAddComponent(component);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues\r\n   *\r\n   * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately\r\n   * @param componentOrType\r\n   * @param force\r\n   */\r\n  public removeComponent<ComponentOrType extends string | Component>(componentOrType: ComponentOrType, force = false): Entity {\r\n    if (force) {\r\n      if (typeof componentOrType === 'string') {\r\n        this._removeComponentByType(componentOrType);\r\n      } else if (componentOrType instanceof Component) {\r\n        this._removeComponentByType(componentOrType.type);\r\n      }\r\n    } else {\r\n      this._componentsToRemove.push(componentOrType);\r\n    }\r\n\r\n    return this as any;\r\n  }\r\n\r\n  private _removeComponentByType(type: string) {\r\n    if (this.has(type)) {\r\n      const component = this.get(type);\r\n      component.owner = null;\r\n      if (component.onRemove) {\r\n        component.onRemove(this);\r\n      }\r\n      const ctor = component.constructor as ComponentCtor;\r\n      this._componentTypeToInstance.delete(ctor);\r\n      this._componentStringToInstance.delete(component.type);\r\n      this._notifyRemoveComponent(component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @internal\r\n   */\r\n  public processComponentRemoval() {\r\n    for (const componentOrType of this._componentsToRemove) {\r\n      const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;\r\n      this._removeComponentByType(type);\r\n    }\r\n    this._componentsToRemove.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Check if a component type exists\r\n   * @param type\r\n   */\r\n  public has<T extends Component>(type: ComponentCtor<T>): boolean;\r\n  public has(type: string): boolean;\r\n  public has<T extends Component>(type: ComponentCtor<T> | string): boolean {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.has(type);\r\n    } else {\r\n      return this._componentTypeToInstance.has(type);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a component by type with typecheck\r\n   *\r\n   * (Does not work on tag components, use .hasTag(\"mytag\") instead)\r\n   * @param type\r\n   */\r\n  public get<T extends Component>(type: ComponentCtor<T>): T | null;\r\n  public get<T extends Component>(type: string): T | null;\r\n  public get<T extends Component>(type: ComponentCtor<T> | string): T | null {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.get(type) as T;\r\n    } else {\r\n      return this._componentTypeToInstance.get(type) as T;\r\n    }\r\n  }\r\n\r\n  private _isInitialized = false;\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the entity. This method is meant to be\r\n   * overridden.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an entity is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an entity is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Entity update lifecycle, called internally\r\n   *\r\n   * @internal\r\n   * @param engine\r\n   * @param delta\r\n   */\r\n  public update(engine: Engine, delta: number): void {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n    for (const child of this.children) {\r\n      child.update(engine, delta);\r\n    }\r\n    this._postupdate(engine, delta);\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\r\nimport { Graphic } from './Graphic';\r\nimport { HasTick } from './Animation';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Logger } from '../Util/Log';\r\nimport { BoundingBox } from '../Collision/Index';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\n\r\n/**\r\n * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)\r\n * @param graphic\r\n */\r\nexport function hasGraphicsTick(graphic: Graphic): graphic is Graphic & HasTick {\r\n  return !!(graphic as unknown as HasTick).tick;\r\n}\r\nexport interface GraphicsShowOptions {\r\n  offset?: Vector;\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsComponentOptions {\r\n  onPostDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n  onPreDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n\r\n  /**\r\n   * Name of current graphic to use\r\n   */\r\n  current?: string;\r\n\r\n  /**\r\n   * Optionally copy instances of graphics by calling .clone(), you may set this to false to avoid sharing graphics when added to the\r\n   * component for performance reasons. By default graphics are not copied and are shared when added to the component.\r\n   */\r\n  copyGraphics?: boolean;\r\n\r\n  /**\r\n   * Optional visible flag, if the graphics component is not visible it will not be displayed\r\n   */\r\n  visible?: boolean;\r\n\r\n  /**\r\n   * Optional opacity\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * List of graphics\r\n   */\r\n  graphics?: { [graphicName: string]: Graphic };\r\n\r\n  /**\r\n   * Optional offset in absolute pixels to shift all graphics in this component from each graphic's anchor (default is top left corner)\r\n   */\r\n  offset?: Vector;\r\n\r\n  /**\r\n   * Optional anchor\r\n   */\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsLayerOptions {\r\n  /**\r\n   * Name of the layer required, for example 'background'\r\n   */\r\n  name: string;\r\n  /**\r\n   * Order of the layer, a layer with order -1 will be below a layer with order of 1\r\n   */\r\n  order: number;\r\n  /**\r\n   * Offset to shift the entire layer\r\n   */\r\n  offset?: Vector;\r\n}\r\nexport class GraphicsLayer {\r\n  public graphics: { graphic: Graphic; options: GraphicsShowOptions }[] = [];\r\n  constructor(private _options: GraphicsLayerOptions, private _graphics: GraphicsComponent) {}\r\n  public get name(): string {\r\n    return this._options.name;\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in this layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in this layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    if (!nameOrGraphic) {\r\n      this.graphics.length = 0;\r\n    } else {\r\n      let gfx: Graphic = null;\r\n      if (nameOrGraphic instanceof Graphic) {\r\n        gfx = nameOrGraphic;\r\n      } else {\r\n        gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      }\r\n      this.graphics = this.graphics.filter((g) => g.graphic !== gfx);\r\n      this._graphics.recalculateBounds();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.\r\n   *\r\n   * If `show()` is called multiple times for the same graphic it will be shown multiple times.\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    let gfx: Graphic;\r\n    if (nameOrGraphic instanceof Graphic) {\r\n      gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;\r\n    } else {\r\n      gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      if (!gfx) {\r\n        Logger.getInstance().error(\r\n          `No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `,\r\n          this._graphics.getNames()\r\n        );\r\n      }\r\n    }\r\n    if (gfx) {\r\n      this.graphics.push({ graphic: gfx, options });\r\n      this._graphics.recalculateBounds();\r\n      return gfx as T;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use a specific graphic, swap out any current graphics being shown\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    this.hide();\r\n    return this.show<T>(nameOrGraphic, options);\r\n  }\r\n\r\n  /**\r\n   * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public get order(): number {\r\n    return this._options.order;\r\n  }\r\n\r\n  /**\r\n   * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public set order(order: number) {\r\n    this._options.order = order;\r\n  }\r\n\r\n  /**\r\n   * Get or set the pixel offset from the layer anchor for all graphics in the layer\r\n   */\r\n  public get offset(): Vector {\r\n    return this._options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  public set offset(value: Vector) {\r\n    this._options.offset = value;\r\n  }\r\n\r\n  public get currentKeys(): string {\r\n    return this.name ?? 'anonymous';\r\n  }\r\n}\r\n\r\nexport class GraphicsLayers {\r\n  private _layers: GraphicsLayer[] = [];\r\n  private _layerMap: { [layerName: string]: GraphicsLayer } = {};\r\n  public default: GraphicsLayer;\r\n  constructor(private _component: GraphicsComponent) {\r\n    this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);\r\n    this._maybeAddLayer(this.default);\r\n  }\r\n  public create(options: GraphicsLayerOptions): GraphicsLayer {\r\n    const layer = new GraphicsLayer(options, this._component);\r\n    return this._maybeAddLayer(layer);\r\n  }\r\n\r\n  /**\r\n   * Retrieve a single layer by name\r\n   * @param name\r\n   */\r\n  public get(name: string): GraphicsLayer;\r\n  /**\r\n   * Retrieve all layers\r\n   */\r\n  public get(): readonly GraphicsLayer[];\r\n  public get(name?: string): GraphicsLayer | readonly GraphicsLayer[] {\r\n    if (name) {\r\n      return this._getLayer(name);\r\n    }\r\n    return this._layers;\r\n  }\r\n\r\n  public currentKeys() {\r\n    const graphicsLayerKeys = [];\r\n    for (const layer of this._layers) {\r\n      graphicsLayerKeys.push(layer.currentKeys);\r\n    }\r\n    return graphicsLayerKeys;\r\n  }\r\n\r\n  public has(name: string): boolean {\r\n    return name in this._layerMap;\r\n  }\r\n\r\n  private _maybeAddLayer(layer: GraphicsLayer) {\r\n    if (this._layerMap[layer.name]) {\r\n      // todo log warning\r\n      return this._layerMap[layer.name];\r\n    }\r\n    this._layerMap[layer.name] = layer;\r\n    this._layers.push(layer);\r\n    this._layers.sort((a, b) => a.order - b.order);\r\n    return layer;\r\n  }\r\n\r\n  private _getLayer(name: string): GraphicsLayer | undefined {\r\n    return this._layerMap[name];\r\n  }\r\n}\r\n\r\n/**\r\n * Component to manage drawings, using with the position component\r\n */\r\nexport class GraphicsComponent extends Component<'ex.graphics'> {\r\n  readonly type = 'ex.graphics';\r\n\r\n  private _graphics: { [graphicName: string]: Graphic } = {};\r\n\r\n  public layers: GraphicsLayers;\r\n\r\n  public getGraphic(name: string): Graphic | undefined {\r\n    return this._graphics[name];\r\n  }\r\n\r\n  /**\r\n   * Get registered graphics names\r\n   */\r\n  public getNames(): string[] {\r\n    return Object.keys(this._graphics);\r\n  }\r\n\r\n  /**\r\n   * Draws after the entity transform has bene applied, but before graphics component graphics have been drawn\r\n   */\r\n  public onPreDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Draws after the entity transform has been applied, and after graphics component graphics has been drawn\r\n   */\r\n  public onPostDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Sets or gets wether any drawing should be visible in this component\r\n   */\r\n  public visible: boolean = true;\r\n\r\n  /**\r\n   * Sets or gets wither all drawings should have an opacity applied\r\n   */\r\n  public opacity: number = 1;\r\n\r\n  /**\r\n   * Offset to apply to graphics by default\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * Anchor to apply to graphics by default\r\n   */\r\n  public anchor: Vector = Vector.Half;\r\n\r\n  /**\r\n   * If set to true graphics added to the component will be copied. This can affect performance\r\n   */\r\n  public copyGraphics: boolean = false;\r\n\r\n  constructor(options?: GraphicsComponentOptions) {\r\n    super();\r\n    // Defaults\r\n    options = {\r\n      visible: this.visible,\r\n      ...options\r\n    };\r\n\r\n    const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;\r\n\r\n    this._graphics = graphics || {};\r\n    this.offset = offset ?? this.offset;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.anchor = anchor ?? this.anchor;\r\n    this.copyGraphics = copyGraphics ?? this.copyGraphics;\r\n    this.onPreDraw = onPreDraw ?? this.onPreDraw;\r\n    this.onPostDraw = onPostDraw ?? this.onPostDraw;\r\n    this.visible = !!visible;\r\n\r\n    this.layers = new GraphicsLayers(this);\r\n    if (current && this._graphics[current]) {\r\n      this.show(this._graphics[current]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the currently displayed graphics and their offsets, empty array if hidden\r\n   */\r\n  public get current(): { graphic: Graphic; options: GraphicsShowOptions }[] {\r\n    return this.layers.default.graphics;\r\n  }\r\n\r\n  /**\r\n   * Returns all graphics associated with this component\r\n   */\r\n  public get graphics(): { [graphicName: string]: Graphic } {\r\n    return this._graphics;\r\n  }\r\n\r\n  /**\r\n   * Adds a named graphic to this component, if the name is \"default\" or not specified, it will be shown by default without needing to call\r\n   * `show(\"default\")`\r\n   * @param graphic\r\n   */\r\n  public add(graphic: Graphic): Graphic;\r\n  public add(name: string, graphic: Graphic): Graphic;\r\n  public add(nameOrGraphic: string | Graphic, graphic?: Graphic): Graphic {\r\n    let name = 'default';\r\n    let graphicToSet: Graphic = null;\r\n    if (typeof nameOrGraphic === 'string') {\r\n      name = nameOrGraphic;\r\n      graphicToSet = graphic;\r\n    } else {\r\n      graphicToSet = nameOrGraphic;\r\n    }\r\n\r\n    this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;\r\n    if (name === 'default') {\r\n      this.show('default');\r\n    }\r\n    return graphicToSet;\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name on the **default** layer, returns the new [[Graphic]]\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    const result = this.layers.default.show<T>(nameOrGraphic, options);\r\n    this.recalculateBounds();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    const result = this.layers.default.use<T>(nameOrGraphic, options);\r\n    this.recalculateBounds();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in the **default** layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in the **default** layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    this.layers.default.hide(nameOrGraphic);\r\n  }\r\n\r\n  private _localBounds: BoundingBox = null;\r\n  public set localBounds(bounds: BoundingBox) {\r\n    this._localBounds = bounds;\r\n  }\r\n\r\n  public recalculateBounds() {\r\n    let bb = new BoundingBox();\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic, options } of layer.graphics) {\r\n        let anchor = this.anchor;\r\n        let offset = this.offset;\r\n        if (options?.anchor) {\r\n          anchor = options.anchor;\r\n        }\r\n        if (options?.offset) {\r\n          offset = options.offset;\r\n        }\r\n        const bounds = graphic.localBounds;\r\n        const offsetX = -bounds.width *  anchor.x + offset.x;\r\n        const offsetY = -bounds.height *  anchor.y + offset.y;\r\n        bb = graphic?.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);\r\n      }\r\n    }\r\n    this._localBounds = bb;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    if (!this._localBounds || this._localBounds.hasZeroDimensions()) {\r\n      this.recalculateBounds();\r\n    }\r\n    return this._localBounds;\r\n  }\r\n\r\n  /**\r\n   * Update underlying graphics if necesary, called internally\r\n   * @param elapsed\r\n   * @internal\r\n   */\r\n  public update(elapsed: number, idempotencyToken: number = 0) {\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic } of layer.graphics) {\r\n        if (hasGraphicsTick(graphic)) {\r\n          graphic?.tick(elapsed, idempotencyToken);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface RectangleOptions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\n/**\r\n * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]\r\n */\r\nexport class Rectangle extends Raster {\r\n  constructor(options: RasterOptions & RectangleOptions) {\r\n    super(options);\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Rectangle {\r\n    return new Rectangle({\r\n      width: this.width,\r\n      height: this.height,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.color) {\r\n      ctx.fillRect(0, 0, this.width, this.height);\r\n    }\r\n    if (this.strokeColor) {\r\n      ctx.strokeRect(0, 0, this.width, this.height);\r\n    }\r\n  }\r\n}\r\n","import { ImageFiltering } from '.';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CircleOptions {\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Circles default to [[ImageFiltering.Blended]]\r\n */\r\nexport class Circle extends Raster {\r\n  private _radius: number = 0;\r\n  public get radius() {\r\n    return this._radius;\r\n  }\r\n  public set radius(value: number) {\r\n    this._radius = value;\r\n    this.width = this._radius * 2;\r\n    this.height = this._radius * 2;\r\n    this.flagDirty();\r\n  }\r\n  constructor(options: RasterOptions & CircleOptions) {\r\n    super(options);\r\n    this.padding = options.padding ?? 2; // default 2 padding for circles looks nice\r\n    this.radius = options.radius;\r\n    this.filtering = options.filtering ?? ImageFiltering.Blended;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Circle {\r\n    return new Circle({\r\n      radius: this.radius,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.radius > 0) {\r\n      ctx.beginPath();\r\n      ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);\r\n\r\n      if (this.color) {\r\n        ctx.fill();\r\n      }\r\n\r\n      if (this.strokeColor) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Component } from '../EntityComponentSystem/Component';\r\n\r\n/**\r\n * Add this component to optionally configure how the pointer\r\n * system detects pointer events.\r\n *\r\n * By default the collider shape is used and graphics bounds is not.\r\n *\r\n * If both collider shape and graphics bounds are enabled it will fire events if either or\r\n * are intersecting the pointer.\r\n */\r\nexport class PointerComponent extends Component<'ex.pointer'> {\r\n  public readonly type = 'ex.pointer';\r\n  /**\r\n   * Use any existing Collider component geometry for pointer events. This is useful if you want\r\n   * user pointer events only to trigger on the same collision geometry used in the collider component\r\n   * for collision resolution. Default is `true`.\r\n   */\r\n  public useColliderShape = true;\r\n  /**\r\n   * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned\r\n   * bounds around the graphic to trigger pointer events. Default is `false`.\r\n   */\r\n  public useGraphicsBounds = false;\r\n}","import { Vector } from '../Math/vector';\r\n\r\n/**\r\n * A definition of an EasingFunction. See [[EasingFunctions]].\r\n */\r\n// tslint:disable-next-line\r\nexport interface EasingFunction {\r\n  (currentTime: number, startValue: number, endValue: number, duration: number): number;\r\n}\r\n\r\n/**\r\n * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]\r\n * Given a time, the function will return a value from positive startValue to positive endValue.\r\n *\r\n * ```js\r\n * function Linear (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInQuad (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutQuad (t) {\r\n *    return t * (2 - t);\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutQuad (t) {\r\n *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInCubic (t) {\r\n *    return t * t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutCubic (t) {\r\n *    return (--t) * t * t + 1;\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutCubic (t) {\r\n *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n * }\r\n * ```\r\n */\r\nexport class EasingFunctions {\r\n  public static CreateReversibleEasingFunction(easing: EasingFunction) {\r\n    return (time: number, start: number, end: number, duration: number) => {\r\n      if (end < start) {\r\n        return start - (easing(time, end, start, duration) - end);\r\n      } else {\r\n        return easing(time, start, end, duration);\r\n      }\r\n    };\r\n  }\r\n\r\n  public static CreateVectorEasingFunction(easing: EasingFunction) {\r\n    return (time: number, start: Vector, end: Vector, duration: number) => {\r\n      return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));\r\n    };\r\n  }\r\n\r\n  public static Linear: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      return (endValue * currentTime) / duration + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInQuad = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n\r\n      return endValue * currentTime * currentTime + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      return -endValue * currentTime * (currentTime - 2) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration / 2;\r\n\r\n      if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime + startValue;\r\n      }\r\n      currentTime--;\r\n\r\n      return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      return endValue * currentTime * currentTime * currentTime + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      currentTime--;\r\n      return endValue * (currentTime * currentTime * currentTime + 1) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration / 2;\r\n      if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;\r\n      }\r\n      currentTime -= 2;\r\n      return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;\r\n    }\r\n  );\r\n}\r\n","import { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Action } from './Action';\r\n\r\n/**\r\n * Action Queues represent an ordered sequence of actions\r\n *\r\n * Action queues are part of the [[ActionContext|Action API]] and\r\n * store the list of actions to be executed for an [[Actor]].\r\n *\r\n * Actors implement [[Actor.actions]] which can be manipulated by\r\n * advanced users to adjust the actions currently being executed in the\r\n * queue.\r\n */\r\nexport class ActionQueue {\r\n  private _entity: Entity;\r\n  private _actions: Action[] = [];\r\n  private _currentAction: Action;\r\n  private _completedActions: Action[] = [];\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  /**\r\n   * Add an action to the sequence\r\n   * @param action\r\n   */\r\n  public add(action: Action) {\r\n    this._actions.push(action);\r\n  }\r\n\r\n  /**\r\n   * Remove an action by reference from the sequence\r\n   * @param action\r\n   */\r\n  public remove(action: Action) {\r\n    const index = this._actions.indexOf(action);\r\n    this._actions.splice(index, 1);\r\n  }\r\n\r\n  /**\r\n   * Removes all actions from this sequence\r\n   */\r\n  public clearActions(): void {\r\n    this._actions.length = 0;\r\n    this._completedActions.length = 0;\r\n    if (this._currentAction) {\r\n      this._currentAction.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns The total list of actions in this sequence complete or not\r\n   */\r\n  public getActions(): Action[] {\r\n    return this._actions.concat(this._completedActions);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns `true` if there are more actions to process in the sequence\r\n   */\r\n  public hasNext(): boolean {\r\n    return this._actions.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @returns `true` if the current sequence of actions is done\r\n   */\r\n  public isComplete(): boolean {\r\n    return this._actions.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Resets the sequence of actions, this is used to restart a sequence from the beginning\r\n   */\r\n  public reset(): void {\r\n    this._actions = this.getActions();\r\n\r\n    const len = this._actions.length;\r\n    for (let i = 0; i < len; i++) {\r\n      this._actions[i].reset();\r\n    }\r\n    this._completedActions = [];\r\n  }\r\n\r\n  /**\r\n   * Update the queue which updates actions and handles completing actions\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number) {\r\n    if (this._actions.length > 0) {\r\n      this._currentAction = this._actions[0];\r\n      this._currentAction.update(elapsedMs);\r\n\r\n      if (this._currentAction.isComplete(this._entity)) {\r\n        this._completedActions.push(this._actions.shift());\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\nexport class Repeat implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _repeat: number;\r\n  private _originalRepeat: number;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any, repeat: number) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeat = repeat;\r\n    this._originalRepeat = repeat;\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n    this._repeat--; // current execution is the first repeat\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n      this._repeat--;\r\n    }\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._repeat = this._originalRepeat;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\n/**\r\n * RepeatForever Action implementation, it is recommended you use the fluent action\r\n * context API.\r\n *\r\n *\r\n */\r\nexport class RepeatForever implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._stopped) {\r\n      return;\r\n    }\r\n\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n    }\r\n\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n    this._actionQueue.clearActions();\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _entity: Entity;\r\n  public x: number;\r\n  public y: number;\r\n  private _distance: number;\r\n  private _speed: number;\r\n\r\n  private _start: Vector;\r\n  private _offset: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, offsetX: number, offsetY: number, speed: number) {\r\n    this._entity = entity;\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = new Vector(offsetX, offsetY);\r\n    if (speed <= 0) {\r\n      Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);\r\n      throw new Error('Speed must be greater than 0 pixels per second');\r\n    }\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._end = this._start.add(this._offset);\r\n      this._distance = this._offset.size;\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n\r\n    if (this.isComplete(this._entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    } else {\r\n      this._motion.vel = this._dir.scale(this._speed);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || tx.pos.distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distance: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(public entity: Entity, destx: number, desty: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = new Vector(destx, desty);\r\n    this._speed = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._distance = this._start.distance(this._end);\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete(this.entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the strategies that rotation actions can use\r\n */\r\nexport enum RotationType {\r\n  /**\r\n   * Rotation via `ShortestPath` will use the smallest angle\r\n   * between the starting and ending points. This strategy is the default behavior.\r\n   */\r\n  ShortestPath = 0,\r\n  /**\r\n   * Rotation via `LongestPath` will use the largest angle\r\n   * between the starting and ending points.\r\n   */\r\n  LongestPath = 1,\r\n  /**\r\n   * Rotation via `Clockwise` will travel in a clockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  Clockwise = 2,\r\n  /**\r\n   * Rotation via `CounterClockwise` will travel in a counterclockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  CounterClockwise = 3\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { TwoPI } from '../../Math/util';\r\n\r\nexport class RotateTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadians: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = angleRadians;\r\n    this._speed = speed;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (!this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTraveled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { TwoPI } from '../../Math/util';\r\n\r\nexport class RotateBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _offset: number;\r\n\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadiansOffset: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = angleRadiansOffset;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      this._end = this._start + this._offset;\r\n\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortDistance >= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (this._shortDistance <= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTraveled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n    this._start = undefined;\r\n    this._currentNonCannonAngle = undefined;\r\n    this._distance = undefined;\r\n  }\r\n}\r\n","import { vec } from '../../Math/vector';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\n\r\nexport class ScaleTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startX: number;\r\n  private _startY: number;\r\n  private _endX: number;\r\n  private _endY: number;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, scaleX: number, scaleY: number, speedX: number, speedY: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._endX = scaleX;\r\n    this._endY = scaleY;\r\n    this._speedX = speedX;\r\n    this._speedY = speedY;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startX = this._tx.scale.x;\r\n      this._startY = this._tx.scale.y;\r\n      this._distanceX = Math.abs(this._endX - this._startX);\r\n      this._distanceY = Math.abs(this._endY - this._startY);\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {\r\n      const directionX = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.x = this._speedX * directionX;\r\n    } else {\r\n      this._motion.scaleFactor.x = 0;\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {\r\n      const directionY = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.y = this._speedY * directionY;\r\n    } else {\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = vec(this._endX, this._endY);\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.y - this._startX) >= (this._distanceX - 0.01) &&\r\n        Math.abs(this._tx.scale.y - this._startY) >= (this._distanceY - 0.01))\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\n\r\nexport class ScaleBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startScale: Vector;\r\n  private _endScale: Vector;\r\n  private _offset: Vector;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _directionX: number;\r\n  private _directionY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  constructor(entity: Entity, scaleOffsetX: number, scaleOffsetY: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._offset = new Vector(scaleOffsetX, scaleOffsetY);\r\n    this._speedX = this._speedY = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startScale = this._tx.scale.clone();\r\n      this._endScale = this._startScale.add(this._offset);\r\n      this._distanceX = Math.abs(this._endScale.x - this._startScale.x);\r\n      this._distanceY = Math.abs(this._endScale.y - this._startScale.y);\r\n      this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;\r\n      this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;\r\n    }\r\n\r\n    this._motion.scaleFactor.x = this._speedX * this._directionX;\r\n    this._motion.scaleFactor.y = this._speedY * this._directionY;\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = this._endScale;\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.x - this._startScale.x) >= (this._distanceX - 0.01) &&\r\n        Math.abs(this._tx.scale.y - this._startScale.y) >= (this._distanceY - 0.01))\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class CallMethod implements Action {\r\n  private _method: () => any = null;\r\n  private _hasBeenCalled: boolean = false;\r\n  constructor(method: () => any) {\r\n    this._method = method;\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    this._method();\r\n    this._hasBeenCalled = true;\r\n  }\r\n  public isComplete() {\r\n    return this._hasBeenCalled;\r\n  }\r\n  public reset() {\r\n    this._hasBeenCalled = false;\r\n  }\r\n  public stop() {\r\n    this._hasBeenCalled = true;\r\n  }\r\n}\r\n","import { Entity} from '../../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class EaseTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1 * 1000; // 1 second\r\n  private _lerpStart: Vector = new Vector(0, 0);\r\n  private _lerpEnd: Vector = new Vector(0, 0);\r\n  private _initialized: boolean = false;\r\n  private _stopped: boolean = false;\r\n  constructor(\r\n    entity: Entity,\r\n    x: number,\r\n    y: number,\r\n    duration: number,\r\n    public easingFcn: (currentTime: number, startValue: number, endValue: number, duration: number) => number\r\n  ) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = new Vector(x, y);\r\n  }\r\n  private _initialize() {\r\n    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._currentLerpTime = 0;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._initialized) {\r\n      this._initialize();\r\n      this._initialized = true;\r\n    }\r\n\r\n    // Need to update lerp time first, otherwise the first update will always be zero\r\n    this._currentLerpTime += delta;\r\n    let newX = this._tx.pos.x;\r\n    let newY = this._tx.pos.y;\r\n    if (this._currentLerpTime < this._lerpDuration) {\r\n      if (this._lerpEnd.x < this._lerpStart.x) {\r\n        newX =\r\n          this._lerpStart.x -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n      } else {\r\n        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n      }\r\n\r\n      if (this._lerpEnd.y < this._lerpStart.y) {\r\n        newY =\r\n          this._lerpStart.y -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n      } else {\r\n        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n      }\r\n      // Given the lerp position figure out the velocity in pixels per second\r\n      this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n    } else {\r\n      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n      this._motion.vel = Vector.Zero;\r\n    }\r\n  }\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._currentLerpTime >= this._lerpDuration;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._initialized = false;\r\n    this._stopped = false;\r\n    this._currentLerpTime = 0;\r\n  }\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class EaseBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1 * 1000; // 1 second\r\n  private _lerpStart: Vector = new Vector(0, 0);\r\n  private _lerpEnd: Vector = new Vector(0, 0);\r\n  private _offset: Vector;\r\n  private _initialized: boolean = false;\r\n  private _stopped: boolean = false;\r\n  constructor(\r\n    entity: Entity,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    duration: number,\r\n    public easingFcn: (currentTime: number, startValue: number, endValue: number, duration: number) => number\r\n  ) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._lerpDuration = duration;\r\n    this._offset = new Vector(offsetX, offsetY);\r\n  }\r\n  private _initialize() {\r\n    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._currentLerpTime = 0;\r\n    this._lerpEnd = this._lerpStart.add(this._offset);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._initialized) {\r\n      this._initialize();\r\n      this._initialized = true;\r\n    }\r\n\r\n    // Need to update lerp time first, otherwise the first update will always be zero\r\n    this._currentLerpTime += delta;\r\n    let newX = this._tx.pos.x;\r\n    let newY = this._tx.pos.y;\r\n    if (this._currentLerpTime < this._lerpDuration) {\r\n      if (this._lerpEnd.x < this._lerpStart.x) {\r\n        newX =\r\n          this._lerpStart.x -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n      } else {\r\n        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n      }\r\n\r\n      if (this._lerpEnd.y < this._lerpStart.y) {\r\n        newY =\r\n          this._lerpStart.y -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n      } else {\r\n        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n      }\r\n      // Given the lerp position figure out the velocity in pixels per second\r\n      this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n    } else {\r\n      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n      this._motion.vel = Vector.Zero;\r\n    }\r\n  }\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._currentLerpTime >= this._lerpDuration;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._initialized = false;\r\n    this._stopped = false;\r\n    this._currentLerpTime = 0;\r\n  }\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n}","import { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\n\r\nexport class Blink implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  private _timeVisible: number = 0;\r\n  private _timeNotVisible: number = 0;\r\n  private _elapsedTime: number = 0;\r\n  private _totalTime: number = 0;\r\n  private _duration: number;\r\n  private _stopped: boolean = false;\r\n  private _started: boolean = false;\r\n  constructor(entity: Entity, timeVisible: number, timeNotVisible: number, numBlinks: number = 1) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._timeVisible = timeVisible;\r\n    this._timeNotVisible = timeNotVisible;\r\n    this._duration = (timeVisible + timeNotVisible) * numBlinks;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._elapsedTime = 0;\r\n      this._totalTime = 0;\r\n    }\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n    this._totalTime += delta;\r\n    if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {\r\n      this._graphics.visible = false;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {\r\n      this._graphics.visible = true;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.visible = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._totalTime >= this._duration;\r\n  }\r\n\r\n  public stop(): void {\r\n    if (this._graphics) {\r\n      this._graphics.visible = true;\r\n    }\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset() {\r\n    this._started = false;\r\n    this._stopped = false;\r\n    this._elapsedTime = 0;\r\n    this._totalTime = 0;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class Fade implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  public x: number;\r\n  public y: number;\r\n\r\n  private _endOpacity: number;\r\n  private _speed: number;\r\n  private _ogspeed: number;\r\n  private _multiplier: number = 1;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, endOpacity: number, speed: number) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._endOpacity = endOpacity;\r\n    this._speed = this._ogspeed = speed;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._speed = this._ogspeed;\r\n\r\n      // determine direction when we start\r\n      if (this._endOpacity < this._graphics.opacity) {\r\n        this._multiplier = -1;\r\n      } else {\r\n        this._multiplier = 1;\r\n      }\r\n    }\r\n\r\n    if (this._speed > 0) {\r\n      this._graphics.opacity += (this._multiplier *\r\n        (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;\r\n    }\r\n\r\n    this._speed -= delta;\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.opacity = this._endOpacity;\r\n    }\r\n\r\n    Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class Delay implements Action {\r\n  private _elapsedTime: number = 0;\r\n  private _delay: number;\r\n  private _started: boolean = false;\r\n  private _stopped = false;\r\n  constructor(delay: number) {\r\n    this._delay = delay;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n  }\r\n\r\n  isComplete(): boolean {\r\n    return this._stopped || this._elapsedTime >= this._delay;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  reset(): void {\r\n    this._elapsedTime = 0;\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionsComponent } from '../ActionsComponent';\r\n\r\nexport class Die implements Action {\r\n  private _entity: Entity;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    this._entity.get(ActionsComponent).clearActions();\r\n    this._entity.kill();\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    return;\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Follow implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _followTx: TransformComponent;\r\n  private _followMotion: MotionComponent;\r\n\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _maximumDistance: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, entityToFollow: Entity, followDistance?: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._followTx = entityToFollow.get(TransformComponent);\r\n    this._followMotion = entityToFollow.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);\r\n    this._speed = 0;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));\r\n    if (actorToFollowSpeed !== 0) {\r\n      this._speed = actorToFollowSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    if (this._distanceBetween >= this._maximumDistance) {\r\n      const m = this._dir.scale(this._speed);\r\n      this._motion.vel = vec(m.x, m.y);\r\n    } else {\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    // the actor following should never stop unless specified to do so\r\n    return this._stopped;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Meet implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _meetTx: TransformComponent;\r\n  private _meetMotion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedWasSpecified = false;\r\n\r\n  constructor(actor: Entity, actorToMeet: Entity, speed?: number) {\r\n    this._tx = actor.get(TransformComponent);\r\n    this._motion = actor.get(MotionComponent);\r\n    this._meetTx = actorToMeet.get(TransformComponent);\r\n    this._meetMotion = actorToMeet.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._speed = speed || 0;\r\n\r\n    if (speed !== undefined) {\r\n      this._speedWasSpecified = true;\r\n    }\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));\r\n    if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {\r\n      this._speed = actorToMeetSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._distanceBetween <= 1;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n    this._distanceBetween = undefined;\r\n  }\r\n}\r\n","import { RotationType } from './RotationType';\r\n\r\nimport { EasingFunction, EasingFunctions } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { Repeat } from './Action/Repeat';\r\nimport { RepeatForever } from './Action/RepeatForever';\r\nimport { MoveBy } from './Action/MoveBy';\r\nimport { MoveTo } from './Action/MoveTo';\r\nimport { RotateTo } from './Action/RotateTo';\r\nimport { RotateBy } from './Action/RotateBy';\r\nimport { ScaleTo } from './Action/ScaleTo';\r\nimport { ScaleBy } from './Action/ScaleBy';\r\nimport { CallMethod } from './Action/CallMethod';\r\nimport { EaseTo } from './Action/EaseTo';\r\nimport { EaseBy } from './Action/EaseBy';\r\nimport { Blink } from './Action/Blink';\r\nimport { Fade } from './Action/Fade';\r\nimport { Delay } from './Action/Delay';\r\nimport { Die } from './Action/Die';\r\nimport { Follow } from './Action/Follow';\r\nimport { Meet } from './Action/Meet';\r\nimport { Vector } from '../Math/vector';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Action } from './Action';\r\n\r\n/**\r\n * The fluent Action API allows you to perform \"actions\" on\r\n * [[Actor|Actors]] such as following, moving, rotating, and\r\n * more. You can implement your own actions by implementing\r\n * the [[Action]] interface.\r\n */\r\nexport class ActionContext {\r\n  private _entity: Entity;\r\n  private _queue: ActionQueue;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n    this._queue = new ActionQueue(entity);\r\n  }\r\n\r\n  public getQueue(): ActionQueue {\r\n    return this._queue;\r\n  }\r\n\r\n  public update(elapsedMs: number) {\r\n    this._queue.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._queue.clearActions();\r\n  }\r\n\r\n  public runAction(action: Action) {\r\n    action.reset();\r\n    this._queue.add(action);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  public easeTo(...args: any[]): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let duration = 0;\r\n    let easingFcn = EasingFunctions.Linear;\r\n    if (args[0] instanceof Vector) {\r\n      x = args[0].x;\r\n      y = args[0].y;\r\n      duration = args[1];\r\n      easingFcn = args[2] ?? easingFcn;\r\n    } else {\r\n      x = args[0];\r\n      y = args[1];\r\n      duration = args[2];\r\n      easingFcn = args[3] ?? easingFcn;\r\n    }\r\n\r\n    this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by a specified vector offset relative to the current position given\r\n   * a duration and a [[EasingFunction]]. This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset Vector offset relative to the current position\r\n   * @param duration The duration in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeBy(offset: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  /**\r\n   * This method will move an actor by a specified x and y offset relative to the current position given\r\n   * a duration and a [[EasingFunction]]. This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset Vector offset relative to the current position\r\n   * @param duration The duration in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeBy(offsetX: number, offsetY: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeBy(...args: any[]): ActionContext {\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n    let duration = 0;\r\n    let easingFcn = EasingFunctions.Linear;\r\n    if (args[0] instanceof Vector) {\r\n      offsetX = args[0].x;\r\n      offsetY = args[0].y;\r\n      duration = args[1];\r\n      easingFcn = args[2] ?? easingFcn;\r\n    } else {\r\n      offsetX = args[0];\r\n      offsetY = args[1];\r\n      duration = args[2];\r\n      easingFcn = args[3] ?? easingFcn;\r\n    }\r\n\r\n    this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let speed = 0;\r\n    if (xOrPos instanceof Vector) {\r\n      x = xOrPos.x;\r\n      y = xOrPos.y;\r\n      speed = yOrSpeed;\r\n    } else {\r\n      x = xOrPos;\r\n      y = yOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveTo(this._entity, x, y, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let xOffset = 0;\r\n    let yOffset = 0;\r\n    let speed = 0;\r\n    if (xOffsetOrVector instanceof Vector) {\r\n      xOffset = xOffsetOrVector.x;\r\n      yOffset = xOffsetOrVector.y;\r\n      speed = yOffsetOrSpeed;\r\n    } else {\r\n      xOffset = xOffsetOrVector;\r\n      yOffset = yOffsetOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number | undefined,\r\n    speedYOrUndefined?: number | undefined): ActionContext {\r\n\r\n    let sizeX = 1;\r\n    let sizeY = 1;\r\n    let speedX = 0;\r\n    let speedY = 0;\r\n\r\n    if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {\r\n      sizeX = sizeXOrVector.x;\r\n      sizeY = sizeXOrVector.y;\r\n\r\n      speedX = sizeYOrSpeed.x;\r\n      speedY = sizeYOrSpeed.y;\r\n    }\r\n    if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {\r\n      sizeX = sizeXOrVector;\r\n      sizeY = sizeYOrSpeed;\r\n\r\n      speedX = speedXOrUndefined;\r\n      speedY = speedYOrUndefined;\r\n    }\r\n\r\n    this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number | undefined): ActionContext {\r\n    let sizeOffsetX = 1;\r\n    let sizeOffsetY = 1;\r\n\r\n    if (sizeOffsetXOrVector instanceof Vector) {\r\n      sizeOffsetX = sizeOffsetXOrVector.x;\r\n      sizeOffsetY = sizeOffsetXOrVector.y;\r\n\r\n      speed = sizeOffsetYOrSpeed;\r\n    }\r\n    if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {\r\n      sizeOffsetX = sizeOffsetXOrVector;\r\n      sizeOffsetY = sizeOffsetYOrSpeed;\r\n    }\r\n\r\n    this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks: number = 1): ActionContext {\r\n    this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    this._queue.add(new Fade(this._entity, opacity, time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    this._queue.add(new Delay(time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    this._queue.add(new Die(this._entity));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    this._queue.add(new CallMethod(method));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    if (!times) {\r\n      this.repeatForever(repeatBuilder);\r\n      return this;\r\n    }\r\n    this._queue.add(new Repeat(this._entity, repeatBuilder, times));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    this._queue.add(new RepeatForever(this._entity, repeatBuilder));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Entity, followDistance?: number): ActionContext {\r\n    if (followDistance === undefined) {\r\n      this._queue.add(new Follow(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Follow(this._entity, entity, followDistance));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Entity, speed?: number): ActionContext {\r\n    if (speed === undefined) {\r\n      this._queue.add(new Meet(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Meet(this._entity, entity, speed));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    const temp = new Promise<void>((resolve) => {\r\n      this._queue.add(\r\n        new CallMethod(() => {\r\n          resolve();\r\n        })\r\n      );\r\n    });\r\n    return temp;\r\n  }\r\n}\r\n","import { ActionContext } from './ActionContext';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Actor } from '../Actor';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Vector } from '../Math/vector';\r\nimport { EasingFunction } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { RotationType } from './RotationType';\r\nimport { Action } from './Action';\r\n\r\nexport interface ActionContextMethods extends Pick<ActionContext, keyof ActionContext> { };\r\n\r\nexport class ActionsComponent extends Component<'ex.actions'> implements ActionContextMethods {\r\n  public readonly type = 'ex.actions';\r\n  dependencies = [TransformComponent, MotionComponent];\r\n  private _ctx: ActionContext;\r\n\r\n  onAdd(entity: Entity) {\r\n    this._ctx = new ActionContext(entity);\r\n  }\r\n\r\n  onRemove() {\r\n    this._ctx = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal action queue\r\n   * @returns action queue\r\n   */\r\n  public getQueue(): ActionQueue {\r\n    return this._ctx?.getQueue();\r\n  }\r\n\r\n  public runAction(action: Action): ActionContext {\r\n    return this._ctx?.runAction(action);\r\n  }\r\n\r\n  /**\r\n   * Updates the internal action context, performing action and moving through the internal queue\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number): void {\r\n    return this._ctx?.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._ctx?.clearActions();\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeTo(...args: any[]): ActionContext {\r\n    return this._ctx.easeTo.apply(this._ctx, args);\r\n  }\r\n\r\n  public easeBy(offset: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeBy(offsetX: number, offsetY: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeBy(...args: any[]): ActionContext {\r\n    return this._ctx.easeBy.apply(this._ctx, args);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset The (x, y) offset to apply to this actor\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateTo(angleRadians, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(\r\n    sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number,\r\n    speedYOrUndefined?: number): ActionContext {\r\n    return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number): ActionContext {\r\n    return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks?: number): ActionContext {\r\n    return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    return this._ctx.fade(opacity, time);\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    return this._ctx.delay(time);\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    return this._ctx.die();\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    return this._ctx.callMethod(method);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    return this._ctx.repeat(repeatBuilder, times);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    return this._ctx.repeatForever(repeatBuilder);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Actor, followDistance?: number): ActionContext {\r\n    return this._ctx.follow(entity, followDistance);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Actor, speed?: number): ActionContext {\r\n    return this._ctx.meet(entity, speed);\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    return this._ctx.toPromise();\r\n  }\r\n}","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\n\r\n/**\r\n * Enum representing the different font size units\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\r\n */\r\nexport enum FontUnit {\r\n  /**\r\n   * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values\r\n   */\r\n  Em = 'em',\r\n  /**\r\n   * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element\r\n   */\r\n  Rem = 'rem',\r\n  /**\r\n   * Pixel is a unit of length in screen pixels\r\n   */\r\n  Px = 'px',\r\n  /**\r\n   * Point is a physical unit length (1/72 of an inch)\r\n   */\r\n  Pt = 'pt',\r\n  /**\r\n   * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff\r\n   */\r\n  Percent = '%'\r\n}\r\n\r\n/**\r\n * Enum representing the different horizontal text alignments\r\n */\r\nexport enum TextAlign {\r\n  /**\r\n   * The text is left-aligned.\r\n   */\r\n  Left = 'left',\r\n  /**\r\n   * The text is right-aligned.\r\n   */\r\n  Right = 'right',\r\n  /**\r\n   * The text is centered.\r\n   */\r\n  Center = 'center',\r\n  /**\r\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,\r\n   * right-aligned for right-to-left locales).\r\n   */\r\n  Start = 'start',\r\n  /**\r\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,\r\n   * left-aligned for right-to-left locales).\r\n   */\r\n  End = 'end'\r\n}\r\n\r\n/**\r\n * Enum representing the different baseline text alignments\r\n */\r\nexport enum BaseAlign {\r\n  /**\r\n   * The text baseline is the top of the em square.\r\n   */\r\n  Top = 'top',\r\n  /**\r\n   * The text baseline is the hanging baseline.  Currently unsupported; this will act like\r\n   * alphabetic.\r\n   */\r\n  Hanging = 'hanging',\r\n  /**\r\n   * The text baseline is the middle of the em square.\r\n   */\r\n  Middle = 'middle',\r\n  /**\r\n   * The text baseline is the normal alphabetic baseline.\r\n   */\r\n  Alphabetic = 'alphabetic',\r\n  /**\r\n   * The text baseline is the ideographic baseline; this is the bottom of\r\n   * the body of the characters, if the main body of characters protrudes\r\n   * beneath the alphabetic baseline.  Currently unsupported; this will\r\n   * act like alphabetic.\r\n   */\r\n  Ideographic = 'ideographic',\r\n  /**\r\n   * The text baseline is the bottom of the bounding box.  This differs\r\n   * from the ideographic baseline in that the ideographic baseline\r\n   * doesn't consider descenders.\r\n   */\r\n  Bottom = 'bottom'\r\n}\r\n\r\n/**\r\n * Enum representing the different possible font styles\r\n */\r\nexport enum FontStyle {\r\n  Normal = 'normal',\r\n  Italic = 'italic',\r\n  Oblique = 'oblique'\r\n}\r\n\r\n/**\r\n * Enum representing the text direction, useful for other languages, or writing text in reverse\r\n */\r\nexport enum Direction {\r\n  LeftToRight = 'ltr',\r\n  RightToLeft = 'rtl'\r\n}\r\n\r\n/**\r\n * Font rendering option\r\n */\r\nexport interface FontOptions {\r\n  /**\r\n   * Optionally the size of the font in the specified [[FontUnit]] by default 10.\r\n   */\r\n  size?: number;\r\n  /**\r\n   * Optionally specify unit to measure fonts in, by default Pixels\r\n   */\r\n  unit?: FontUnit;\r\n  /**\r\n   * Optionally specify the font family, by default 'sans-serif'\r\n   */\r\n  family?: string;\r\n  /**\r\n   * Optionally specify the font style, by default Normal\r\n   */\r\n  style?: FontStyle;\r\n  /**\r\n   * Optionally set whether the font is bold, by default false\r\n   */\r\n  bold?: boolean;\r\n  /**\r\n   * Optionally specify the text align, by default Left\r\n   */\r\n  textAlign?: TextAlign;\r\n  /**\r\n   * Optionally specify the text base align, by default Alphabetic\r\n   */\r\n  baseAlign?: BaseAlign;\r\n  /**\r\n   * Optionally specify the text direction, by default LeftToRight\r\n   */\r\n  direction?: Direction;\r\n  /**\r\n   * Optionally specify the quality of the text bitmap, it is a multiplier on the size size, by default 2.\r\n   * Higher quality text has a higher memory impact\r\n   */\r\n  quality?: number;\r\n  /**\r\n   * Optionally specify a text shadow, by default none is specified\r\n   */\r\n  shadow?: {\r\n    blur?: number;\r\n    offset?: Vector;\r\n    color?: Color;\r\n  };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface FontRenderer {\r\n  measureText(text: string): BoundingBox;\r\n  render(ex: ExcaliburGraphicsContext, text: string, color: Color, x: number, y: number): void;\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { BoundingBox } from '../Collision/Index';\r\nimport { Color } from '../Color';\r\nimport { line } from '../Util/DrawUtil';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BaseAlign, Direction, FontOptions, FontStyle, FontUnit, TextAlign, FontRenderer } from './FontCommon';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { RasterOptions } from './Raster';\r\nimport { TextureLoader } from '.';\r\nimport { ImageFiltering } from './Filtering';\r\n\r\n/**\r\n * Represents a system or web font in Excalibur\r\n *\r\n * If no options specified, the system sans-serif 10 pixel is used\r\n *\r\n * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/\r\n */\r\nexport class Font extends Graphic implements FontRenderer {\r\n  /**\r\n   * Set the font filtering mode, by default set to [[ImageFiltering.Blended]] regardless of the engine default smoothing\r\n   *\r\n   * If you have a pixel style font that may be a reason to switch this to [[ImageFiltering.Pixel]]\r\n   */\r\n  public filtering: ImageFiltering = ImageFiltering.Blended;\r\n  constructor(options: FontOptions & GraphicOptions & RasterOptions = {}) {\r\n    super(options); // <- Graphics properties\r\n\r\n    // Raster properties\r\n    this.smoothing = options?.smoothing ?? this.smoothing;\r\n    this.padding = options?.padding ?? this.padding;\r\n    this.color = options?.color ?? this.color;\r\n    this.strokeColor = options?.strokeColor ?? this.strokeColor;\r\n    this.lineDash = options?.lineDash ?? this.lineDash;\r\n    this.lineWidth = options?.lineWidth ?? this.lineWidth;\r\n    this.filtering = options?.filtering ?? this.filtering;\r\n\r\n    // Font specific properties\r\n    this.family = options?.family ?? this.family;\r\n    this.style = options?.style ?? this.style;\r\n    this.bold = options?.bold ?? this.bold;\r\n    this.size = options?.size ?? this.size;\r\n    this.unit = options?.unit ?? this.unit;\r\n    this.textAlign = options?.textAlign ?? this.textAlign;\r\n    this.baseAlign = options?.baseAlign ?? this.baseAlign;\r\n    this.direction = options?.direction ?? this.direction;\r\n    this.quality = options?.quality ?? this.quality;\r\n    if (options?.shadow) {\r\n      this.shadow = {};\r\n      this.shadow.blur = options.shadow.blur ?? this.shadow.blur;\r\n      this.shadow.offset = options.shadow.offset ?? this.shadow.offset;\r\n      this.shadow.color = options.shadow.color ?? this.shadow.color;\r\n    }\r\n  }\r\n\r\n  public clone() {\r\n    return new Font({\r\n      ...this.cloneGraphicOptions(),\r\n      size: this.size,\r\n      unit: this.unit,\r\n      family: this.family,\r\n      style: this.style,\r\n      bold: this.bold,\r\n      textAlign: this.textAlign,\r\n      baseAlign: this.baseAlign,\r\n      direction: this.direction,\r\n      shadow: this.shadow\r\n        ? {\r\n          blur: this.shadow.blur,\r\n          offset: this.shadow.offset,\r\n          color: this.shadow.color\r\n        }\r\n        : null\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.\r\n   * If quality is set to 1, then just enough raster bitmap is generated to render the text.\r\n   *\r\n   * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.\r\n   *\r\n   * (Default 2)\r\n   */\r\n  public quality = 2;\r\n\r\n  // Raster properties for fonts\r\n  public padding = 2;\r\n  public smoothing = false;\r\n  public lineWidth = 1;\r\n  public lineDash: number[] = [];\r\n  public color: Color = Color.Black;\r\n  public strokeColor: Color;\r\n\r\n  public family: string = 'sans-serif';\r\n  public style: FontStyle = FontStyle.Normal;\r\n  public bold: boolean = false;\r\n  public unit: FontUnit = FontUnit.Px;\r\n  public textAlign: TextAlign = TextAlign.Left;\r\n  public baseAlign: BaseAlign = BaseAlign.Alphabetic;\r\n  public direction: Direction = Direction.LeftToRight;\r\n  public size: number = 10;\r\n  public shadow: { blur?: number; offset?: Vector; color?: Color } = null;\r\n\r\n  public get fontString() {\r\n    return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;\r\n  }\r\n\r\n  private _textBounds: BoundingBox = new BoundingBox();\r\n\r\n  public get localBounds(): BoundingBox {\r\n    return this._textBounds;\r\n  }\r\n\r\n\r\n  protected _drawImage(_ex: ExcaliburGraphicsContext, _x: number, _y: number) {\r\n    // TODO weird vestigial drawimage\r\n  }\r\n\r\n\r\n  protected _rotate(ex: ExcaliburGraphicsContext) {\r\n    // TODO this needs to change depending on the bounding box...\r\n    const origin = this.origin ?? this._textBounds.center;\r\n    ex.translate(origin.x, origin.y);\r\n    ex.rotate(this.rotation);\r\n    ex.translate(-origin.x, -origin.y);\r\n  }\r\n\r\n  protected _flip(ex: ExcaliburGraphicsContext) {\r\n    if (this.flipHorizontal) {\r\n      ex.translate(this._textBounds.width / this.scale.x, 0);\r\n      ex.scale(-1, 1);\r\n    }\r\n\r\n    if (this.flipVertical) {\r\n      ex.translate(0, -this._textBounds.height / 2 / this.scale.y);\r\n      ex.scale(1, -1);\r\n    }\r\n  }\r\n\r\n\r\n  private _cachedTextMeasurement = new Map<string, {text: string, measurement: BoundingBox, rasterProps: string}>();\r\n  private _bitmapToTextMeasurement = new Map<CanvasRenderingContext2D, {text: string, measurement: BoundingBox, rasterProps: string}>();\r\n  /**\r\n   * Returns a BoundingBox that is the total size of the text including multiple lines\r\n   *\r\n   * Does not include any padding or adjustment\r\n   * @param text\r\n   * @returns BoundingBox\r\n   */\r\n  public measureText(text: string): BoundingBox {\r\n    let measurementDirty = false;\r\n    let cached = this._cachedTextMeasurement.get(text);\r\n    if (!cached) {\r\n      measurementDirty = true;\r\n    }\r\n\r\n    const rasterProps = this._getRasterPropertiesHash();\r\n    if (!cached || rasterProps !== cached.rasterProps) {\r\n      measurementDirty = true;\r\n    }\r\n\r\n    if (measurementDirty) {\r\n      const lines = text.split('\\n');\r\n      const maxWidthLine = lines.reduce((a, b) => {\r\n        return a.length > b.length ? a : b;\r\n      });\r\n      const ctx = this._getTextBitmap(text);\r\n\r\n      this._applyFont(ctx); // font must be applied to the context to measure it\r\n      const metrics = ctx.measureText(maxWidthLine);\r\n      let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);\r\n\r\n      // TODO lineheight makes the text bounds wonky\r\n      const lineAdjustedHeight = textHeight * lines.length;\r\n      textHeight = lineAdjustedHeight;\r\n      const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);\r\n      const x = 0;\r\n      const y = 0;\r\n      // this._cachedText = text;\r\n      // this._cachedRasterProps = rasterProps;\r\n      // this._measurementDirty = false;\r\n      const measurement = new BoundingBox({\r\n        left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,\r\n        top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,\r\n        bottom: y + bottomBounds + this.padding,\r\n        right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding\r\n      });\r\n      cached = {\r\n        text,\r\n        rasterProps,\r\n        measurement\r\n      };\r\n      this._cachedTextMeasurement.set(text, cached);\r\n      this._bitmapToTextMeasurement.set(ctx, cached);\r\n      return cached.measurement;\r\n    } else {\r\n      return cached.measurement;\r\n    }\r\n  }\r\n\r\n  private _setDimension(textBounds: BoundingBox, bitmap: CanvasRenderingContext2D) {\r\n\r\n    // Changing the width and height clears the context properties\r\n    // We double the bitmap width to account for all possible alignment\r\n    // We scale by \"quality\" so we render text without jaggies\r\n    bitmap.canvas.width = (textBounds.width + this.padding * 2) * 2 * this.quality;\r\n    bitmap.canvas.height = (textBounds.height + this.padding * 2) * 2 * this.quality;\r\n  }\r\n\r\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\r\n    ex.restore();\r\n  }\r\n\r\n  /**\r\n   * We need to identify bitmaps with more than just the text content\r\n   *\r\n   * Any properties that can change the rendering of the text\r\n   */\r\n  private _getRasterPropertiesHash(color?: Color): string {\r\n    const hash = '__hashcode__' +\r\n    this.fontString +\r\n    this.showDebug +\r\n    this.textAlign +\r\n    this.baseAlign +\r\n    this.direction +\r\n    JSON.stringify(this.shadow) +\r\n    (this.padding.toString() +\r\n    this.smoothing.toString() +\r\n    this.lineWidth.toString() +\r\n    this.lineDash.toString() +\r\n    this.strokeColor?.toString() +\r\n    ( color ? color.toString() : this.color?.toString()).toString());\r\n    return hash;\r\n  }\r\n\r\n  protected _applyRasterProperties(ctx: CanvasRenderingContext2D, color: Color) {\r\n    ctx.translate(this.padding, this.padding);\r\n    ctx.imageSmoothingEnabled = this.smoothing;\r\n    ctx.lineWidth = this.lineWidth;\r\n    ctx.setLineDash(this.lineDash ?? ctx.getLineDash());\r\n    ctx.strokeStyle = this.strokeColor?.toString();\r\n    ctx.fillStyle = color ? color.toString() : this.color?.toString();\r\n  }\r\n\r\n  private _applyFont(ctx: CanvasRenderingContext2D) {\r\n    ctx.translate(this.padding + ctx.canvas.width / 2, this.padding + ctx.canvas.height / 2);\r\n    ctx.scale(this.quality, this.quality);\r\n    ctx.textAlign = this.textAlign;\r\n    ctx.textBaseline = this.baseAlign;\r\n    ctx.font = this.fontString;\r\n    ctx.direction = this.direction;\r\n\r\n    if (this.shadow) {\r\n      ctx.shadowColor = this.shadow.color.toString();\r\n      ctx.shadowBlur = this.shadow.blur;\r\n      ctx.shadowOffsetX = this.shadow.offset.x;\r\n      ctx.shadowOffsetY = this.shadow.offset.y;\r\n    }\r\n  }\r\n\r\n  private _drawText(ctx: CanvasRenderingContext2D, text: string, colorOverride: Color, lineHeight: number): void {\r\n    const lines = text.split('\\n');\r\n    this._applyRasterProperties(ctx, colorOverride);\r\n    this._applyFont(ctx);\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i];\r\n      if (this.color) {\r\n        ctx.fillText(line, 0, i * lineHeight);\r\n      }\r\n\r\n      if (this.strokeColor) {\r\n        ctx.strokeText(line, 0, i * lineHeight);\r\n      }\r\n    }\r\n\r\n    if (this.showDebug) {\r\n      // Horizontal line\r\n      /* istanbul ignore next */\r\n      line(ctx, Color.Red, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);\r\n      // Vertical line\r\n      /* istanbul ignore next */\r\n      line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);\r\n    }\r\n  }\r\n\r\n  private _textToBitmap = new Map<string, CanvasRenderingContext2D>();\r\n  private _bitmapUsage = new Map<CanvasRenderingContext2D, number>();\r\n  private _getTextBitmap(text: string, color?: Color): CanvasRenderingContext2D {\r\n    const textAndHash = text + this._getRasterPropertiesHash(color);\r\n    const bitmap = this._textToBitmap.get(textAndHash);\r\n    if (bitmap) {\r\n      return bitmap;\r\n    }\r\n\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    this._textToBitmap.set(textAndHash, ctx);\r\n    return ctx;\r\n  }\r\n\r\n  private _splitTextBitmap(bitmap: CanvasRenderingContext2D) {\r\n    const textImages: {x: number, y: number, canvas: HTMLCanvasElement}[] = [];\r\n    let currentX = 0;\r\n    let currentY = 0;\r\n    // 4k is the max for mobile devices\r\n    const width = Math.min(4096, bitmap.canvas.width);\r\n    const height = Math.min(4096, bitmap.canvas.height);\r\n\r\n    // Splits the original bitmap into 4k max chunks\r\n    while (currentX < bitmap.canvas.width) {\r\n      while (currentY < bitmap.canvas.height) {\r\n        // create new bitmap\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        // draw current slice to new bitmap in < 4k chunks\r\n        ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);\r\n\r\n        textImages.push({x: currentX, y: currentY, canvas});\r\n        currentY += height;\r\n      }\r\n      currentX += width;\r\n      currentY = 0;\r\n    }\r\n    return textImages;\r\n  }\r\n\r\n  private _textFragments: {x: number, y: number, canvas: HTMLCanvasElement}[] = [];\r\n  public render(ex: ExcaliburGraphicsContext, text: string, colorOverride: Color, x: number, y: number) {\r\n    if (this.showDebug) {\r\n      this.clearCache();\r\n    }\r\n    this.checkAndClearCache();\r\n    // Get bitmap for rastering text, this is cached by raster properties\r\n    const bitmap = this._getTextBitmap(text, colorOverride);\r\n    const isNewBitmap = !this._bitmapUsage.get(bitmap);\r\n\r\n    // Bounds of the text\r\n    this._textBounds = this.measureText(text);\r\n\r\n    if (isNewBitmap) {\r\n      // Setting dimension is expensive because it invalidates the bitmap\r\n      this._setDimension(this._textBounds, bitmap);\r\n    }\r\n\r\n    // Apply affine transformations\r\n    this._preDraw(ex, x, y);\r\n\r\n    const lines = text.split('\\n');\r\n    const lineHeight = this._textBounds.height / lines.length;\r\n\r\n    if (isNewBitmap) {\r\n      // draws the text to the bitmap\r\n      this._drawText(bitmap, text, colorOverride, lineHeight);\r\n\r\n      // clean up any existing fragments\r\n      for (const frag of this._textFragments) {\r\n        TextureLoader.delete(frag.canvas);\r\n      }\r\n\r\n      this._textFragments = this._splitTextBitmap(bitmap);\r\n\r\n      for (const frag of this._textFragments) {\r\n        TextureLoader.load(frag.canvas, this.filtering, true);\r\n      }\r\n    }\r\n\r\n    // draws the bitmap fragments to excalibur graphics context\r\n    for (const frag of this._textFragments) {\r\n      ex.drawImage(\r\n        frag.canvas,\r\n        0,\r\n        0,\r\n        frag.canvas.width,\r\n        frag.canvas.height,\r\n        frag.x / this.quality + x - bitmap.canvas.width / this.quality / 2,\r\n        frag.y / this.quality + y - bitmap.canvas.height / this.quality / 2,\r\n        frag.canvas.width / this.quality,\r\n        frag.canvas.height / this.quality\r\n      );\r\n    }\r\n\r\n    this._postDraw(ex);\r\n\r\n    // Cache the bitmap for certain amount of time\r\n    this._bitmapUsage.set(bitmap, performance.now());\r\n  }\r\n\r\n  /**\r\n   * Get the internal cache size of the font\r\n   * This is useful when debugging memory usage, these numbers indicate the number of cached in memory text bitmaps\r\n   */\r\n  public get cacheSize() {\r\n    return this._bitmapUsage.size;\r\n  }\r\n\r\n  /**\r\n   * Force clear all cached text bitmaps\r\n   */\r\n  public clearCache() {\r\n    this._bitmapUsage.clear();\r\n  }\r\n\r\n  /**\r\n   * Remove any expired cached text bitmaps\r\n   */\r\n  public checkAndClearCache() {\r\n    for (const [bitmap, time] of this._bitmapUsage.entries()) {\r\n      // if bitmap hasn't been used in 1 second clear it\r\n      if (time + 1000 < performance.now()) {\r\n        this._bitmapUsage.delete(bitmap);\r\n        // Cleanup measurements\r\n        const measurement = this._bitmapToTextMeasurement.get(bitmap);\r\n        if (measurement) {\r\n          this._cachedTextMeasurement.delete(measurement.text);\r\n          this._bitmapToTextMeasurement.delete(bitmap);\r\n        }\r\n        TextureLoader.delete(bitmap.canvas);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { SpriteFont } from './SpriteFont';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Color } from '../Color';\r\nimport { Font } from './Font';\r\n\r\nexport interface TextOptions {\r\n  /**\r\n   * Text to draw\r\n   */\r\n  text: string;\r\n\r\n  /**\r\n   * Optionally override the font color, currently unsupported by SpriteFont\r\n   */\r\n  color?: Color;\r\n\r\n  /**\r\n   * Optionally specify a font, if none specified a default font is used (System sans-serif 10 pixel)\r\n   */\r\n  font?: Font | SpriteFont;\r\n}\r\n\r\n/**\r\n * Represent Text graphics in excalibur\r\n *\r\n * Useful for in game labels, ui, or overlays\r\n */\r\nexport class Text extends Graphic {\r\n  public color?: Color;\r\n  constructor(options: TextOptions & GraphicOptions) {\r\n    super(options);\r\n    // This order is important font, color, then text\r\n    this.font = options.font ?? new Font();\r\n    this.color = options.color ?? this.color;\r\n    this.text = options.text;\r\n  }\r\n\r\n  public clone(): Text {\r\n    return new Text({\r\n      text: this.text.slice(),\r\n      color: this.color?.clone() ?? Color.Black,\r\n      font: this.font.clone()\r\n    });\r\n  }\r\n\r\n  private _text: string = '';\r\n  public get text() {\r\n    return this._text;\r\n  }\r\n\r\n  public set text(value: string) {\r\n    this._text = value;\r\n    const bounds = this.font.measureText(this._text);\r\n    this._textWidth = bounds.width;\r\n    this._textHeight = bounds.height;\r\n  }\r\n\r\n  private _font: Font | SpriteFont;\r\n  public get font(): Font | SpriteFont {\r\n    return this._font;\r\n  }\r\n  public set font(font: Font | SpriteFont) {\r\n    this._font = font;\r\n  }\r\n\r\n  private _textWidth: number = 0;\r\n\r\n  public get width() {\r\n    if (this._textWidth === 0) {\r\n      this._calculateDimension();\r\n    }\r\n    return this._textWidth * this.scale.x;\r\n  }\r\n\r\n  private _textHeight: number = 0;\r\n  public get height() {\r\n    if (this._textHeight === 0) {\r\n      this._calculateDimension();\r\n    }\r\n    return this._textHeight * this.scale.y;\r\n  }\r\n\r\n  private _calculateDimension() {\r\n    const { width, height } = this.font.measureText(this._text);\r\n    this._textWidth = width;\r\n    this._textHeight = height;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    return this.font.measureText(this._text).scale(this.scale);\r\n  }\r\n\r\n  protected override _rotate(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected override _flip(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected override _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    let color = Color.Black;\r\n    if (this.font instanceof Font) {\r\n      color = this.color ?? this.font.color;\r\n    }\r\n\r\n    if (this.isStale() || this.font.isStale()) {\r\n      this.font.flipHorizontal = this.flipHorizontal;\r\n      this.font.flipVertical = this.flipVertical;\r\n      this.font.rotation = this.rotation;\r\n      this.font.origin = this.origin;\r\n      this.font.opacity = this.opacity;\r\n    }\r\n    this.font.tint = this.tint;\r\n\r\n    const { width, height } = this.font.measureText(this._text);\r\n    this._textWidth = width;\r\n    this._textHeight = height;\r\n\r\n    this.font.render(ex, this._text, color, x, y);\r\n    if (this.font.showDebug) {\r\n      ex.debug.drawRect(x - width, y - height, width * 2, height * 2);\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Animation, HasTick } from './Animation';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/Index';\r\n\r\nexport interface GraphicsGroupingOptions {\r\n  members: GraphicsGrouping[];\r\n}\r\n\r\nexport interface GraphicsGrouping {\r\n  pos: Vector;\r\n  graphic: Graphic;\r\n}\r\n\r\nexport class GraphicsGroup extends Graphic implements HasTick {\r\n  public members: GraphicsGrouping[] = [];\r\n\r\n  constructor(options: GraphicsGroupingOptions & GraphicOptions) {\r\n    super(options);\r\n    this.members = options.members;\r\n    this._updateDimensions();\r\n  }\r\n\r\n  public clone(): GraphicsGroup {\r\n    return new GraphicsGroup({\r\n      members: [...this.members],\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n\r\n  private _updateDimensions(): BoundingBox {\r\n    let bb = new BoundingBox();\r\n    for (const { graphic, pos } of this.members) {\r\n      bb = graphic.localBounds.translate(pos).combine(bb);\r\n    }\r\n\r\n    this.width = bb.width;\r\n    this.height = bb.height;\r\n\r\n    return bb;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    let bb = new BoundingBox();\r\n    for (const { graphic, pos } of this.members) {\r\n      bb = graphic.localBounds.translate(pos).combine(bb);\r\n    }\r\n    return bb;\r\n  }\r\n\r\n  private _isAnimationOrGroup(graphic: Graphic): graphic is Animation | GraphicsGroup {\r\n    return graphic instanceof Animation || graphic instanceof GraphicsGroup;\r\n  }\r\n\r\n  public tick(elapsedMilliseconds: number, idempotencyToken?: number) {\r\n    for (const member of this.members) {\r\n      const maybeAnimation = member.graphic;\r\n      if (this._isAnimationOrGroup(maybeAnimation)) {\r\n        maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);\r\n      }\r\n    }\r\n  }\r\n\r\n  public reset() {\r\n    for (const member of this.members) {\r\n      const maybeAnimation = member.graphic;\r\n      if (this._isAnimationOrGroup(maybeAnimation)) {\r\n        maybeAnimation.reset();\r\n      }\r\n    }\r\n  }\r\n\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    this._updateDimensions();\r\n    super._preDraw(ex, x, y);\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    for (const member of this.members) {\r\n      ex.save();\r\n      ex.translate(x, y);\r\n      member.graphic.draw(ex, member.pos.x, member.pos.y);\r\n      if (this.showDebug) {\r\n        /* istanbul ignore next */\r\n        ex.debug.drawRect(0, 0, this.width, this.height);\r\n      }\r\n      ex.restore();\r\n    }\r\n  }\r\n}\r\n","import { Logger } from '../Util/Log';\r\nimport { Class } from '../Class';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Enum representing physical input key codes\r\n */\r\nexport enum Keys {\r\n  // NUMPAD\r\n  Num0 = 'Numpad0',\r\n  Num1 = 'Numpad1',\r\n  Num2 = 'Numpad2',\r\n  Num3 = 'Numpad3',\r\n  Num4 = 'Numpad4',\r\n  Num5 = 'Numpad5',\r\n  Num6 = 'Numpad6',\r\n  Num7 = 'Numpad7',\r\n  Num8 = 'Numpad8',\r\n  Num9 = 'Numpad9',\r\n  NumAdd = 'NumpadAdd',\r\n  NumSubtract = 'NumpadSubtract',\r\n  NumMultiply = 'NumpadMultiply',\r\n  NumDivide = 'NumpadDivide',\r\n  // NumComma = 'NumpadComma', // not x-browser\r\n  NumDecimal = 'NumpadDecimal',\r\n  Numpad0 = 'Numpad0',\r\n  Numpad1 = 'Numpad1',\r\n  Numpad2 = 'Numpad2',\r\n  Numpad3 = 'Numpad3',\r\n  Numpad4 = 'Numpad4',\r\n  Numpad5 = 'Numpad5',\r\n  Numpad6 = 'Numpad6',\r\n  Numpad7 = 'Numpad7',\r\n  Numpad8 = 'Numpad8',\r\n  Numpad9 = 'Numpad9',\r\n  NumpadAdd = 'NumpadAdd',\r\n  NumpadSubtract = 'NumpadSubtract',\r\n  NumpadMultiply = 'NumpadMultiply',\r\n  NumpadDivide = 'NumpadDivide',\r\n  // NumpadComma = 'NumpadComma', // not x-browser\r\n  NumpadDecimal = 'NumpadDecimal',\r\n\r\n  // MODIFIERS\r\n  NumLock = 'NumLock',\r\n  ShiftLeft = 'ShiftLeft',\r\n  ShiftRight = 'ShiftRight',\r\n  AltLeft = 'AltLeft',\r\n  AltRight = 'AltRight',\r\n  ControlLeft = 'ControlLeft',\r\n  ControlRight = 'ControlRight',\r\n  MetaLeft = 'MetaLeft',\r\n  MetaRight = 'MetaRight',\r\n\r\n  // NUMBERS\r\n  Key0 = 'Digit0',\r\n  Key1 = 'Digit1',\r\n  Key2 = 'Digit2',\r\n  Key3 = 'Digit3',\r\n  Key4 = 'Digit4',\r\n  Key5 = 'Digit5',\r\n  Key6 = 'Digit6',\r\n  Key7 = 'Digit7',\r\n  Key8 = 'Digit8',\r\n  Key9 = 'Digit9',\r\n  Digit0 = 'Digit0',\r\n  Digit1 = 'Digit1',\r\n  Digit2 = 'Digit2',\r\n  Digit3 = 'Digit3',\r\n  Digit4 = 'Digit4',\r\n  Digit5 = 'Digit5',\r\n  Digit6 = 'Digit6',\r\n  Digit7 = 'Digit7',\r\n  Digit8 = 'Digit8',\r\n  Digit9 = 'Digit9',\r\n\r\n  // FUNCTION KEYS\r\n  F1 = 'F1',\r\n  F2 = 'F2',\r\n  F3 = 'F3',\r\n  F4 = 'F4',\r\n  F5 = 'F5',\r\n  F6 = 'F6',\r\n  F7 = 'F7',\r\n  F8 = 'F8',\r\n  F9 = 'F9',\r\n  F10 = 'F10',\r\n  F11 = 'F11',\r\n  F12 = 'F12',\r\n\r\n  // LETTERS\r\n  A = 'KeyA',\r\n  B = 'KeyB',\r\n  C = 'KeyC',\r\n  D = 'KeyD',\r\n  E = 'KeyE',\r\n  F = 'KeyF',\r\n  G = 'KeyG',\r\n  H = 'KeyH',\r\n  I = 'KeyI',\r\n  J = 'KeyJ',\r\n  K = 'KeyK',\r\n  L = 'KeyL',\r\n  M = 'KeyM',\r\n  N = 'KeyN',\r\n  O = 'KeyO',\r\n  P = 'KeyP',\r\n  Q = 'KeyQ',\r\n  R = 'KeyR',\r\n  S = 'KeyS',\r\n  T = 'KeyT',\r\n  U = 'KeyU',\r\n  V = 'KeyV',\r\n  W = 'KeyW',\r\n  X = 'KeyX',\r\n  Y = 'KeyY',\r\n  Z = 'KeyZ',\r\n  KeyA = 'KeyA',\r\n  KeyB = 'KeyB',\r\n  KeyC = 'KeyC',\r\n  KeyD = 'KeyD',\r\n  KeyE = 'KeyE',\r\n  KeyF = 'KeyF',\r\n  KeyG = 'KeyG',\r\n  KeyH = 'KeyH',\r\n  KeyI = 'KeyI',\r\n  KeyJ = 'KeyJ',\r\n  KeyK = 'KeyK',\r\n  KeyL = 'KeyL',\r\n  KeyM = 'KeyM',\r\n  KeyN = 'KeyN',\r\n  KeyO = 'KeyO',\r\n  KeyP = 'KeyP',\r\n  KeyQ = 'KeyQ',\r\n  KeyR = 'KeyR',\r\n  KeyS = 'KeyS',\r\n  KeyT = 'KeyT',\r\n  KeyU = 'KeyU',\r\n  KeyV = 'KeyV',\r\n  KeyW = 'KeyW',\r\n  KeyX = 'KeyX',\r\n  KeyY = 'KeyY',\r\n  KeyZ = 'KeyZ',\r\n\r\n  // SYMBOLS\r\n  Semicolon = 'Semicolon',\r\n  Quote = 'Quote',\r\n  Comma = 'Comma',\r\n  Minus = 'Minus',\r\n  Period = 'Period',\r\n  Slash = 'Slash',\r\n  Equal = 'Equal',\r\n  BracketLeft = 'BracketLeft',\r\n  Backslash = 'Backslash',\r\n  BracketRight = 'BracketRight',\r\n  Backquote = 'Backquote',\r\n\r\n  // DIRECTIONS\r\n  Up = 'ArrowUp',\r\n  Down = 'ArrowDown',\r\n  Left = 'ArrowLeft',\r\n  Right = 'ArrowRight',\r\n  ArrowUp = 'ArrowUp',\r\n  ArrowDown = 'ArrowDown',\r\n  ArrowLeft = 'ArrowLeft',\r\n  ArrowRight = 'ArrowRight',\r\n\r\n  // OTHER\r\n  Space = 'Space',\r\n  Backspace = 'Backspace',\r\n  Delete = 'Delete',\r\n  Esc = 'Escape',\r\n  Escape = 'Escape',\r\n  Enter = 'Enter',\r\n  NumpadEnter = 'NumpadEnter',\r\n  ContextMenu = 'ContextMenu'\r\n}\r\n\r\n/**\r\n * Event thrown on a game object for a key event\r\n */\r\nexport class KeyEvent extends Events.GameEvent<any> {\r\n  /**\r\n   * @param key  The key responsible for throwing the event\r\n   * @param value The key's typed value the browser detected\r\n   * @param originalEvent The original keyboard event that Excalibur handled\r\n   */\r\n  constructor(public key: Keys, public value?: string, public originalEvent?: KeyboardEvent) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Provides keyboard support for Excalibur.\r\n */\r\nexport class Keyboard extends Class {\r\n  private _keys: Keys[] = [];\r\n  private _keysUp: Keys[] = [];\r\n  private _keysDown: Keys[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public on(eventName: Events.press, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.release, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.hold, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Initialize Keyboard event listeners\r\n   */\r\n  init(global?: GlobalEventHandlers): void {\r\n    if (!global) {\r\n      try {\r\n        // Try and listen to events on top window frame if within an iframe.\r\n        //\r\n        // See https://github.com/excaliburjs/Excalibur/issues/1294\r\n        //\r\n        // Attempt to add an event listener, which triggers a DOMException on\r\n        // cross-origin iframes\r\n        const noop = () => {\r\n          return;\r\n        };\r\n        window.top.addEventListener('blur', noop);\r\n        window.top.removeEventListener('blur', noop);\r\n\r\n        // this will be the same as window if not embedded within an iframe\r\n        global = window.top;\r\n      } catch {\r\n        // fallback to current frame\r\n        global = window;\r\n\r\n        Logger.getInstance().warn(\r\n          'Failed to bind to keyboard events to top frame. ' +\r\n            'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.'\r\n        );\r\n      }\r\n    }\r\n\r\n    global.addEventListener('blur', () => {\r\n      this._keys.length = 0; // empties array efficiently\r\n    });\r\n\r\n    // key up is on window because canvas cannot have focus\r\n    global.addEventListener('keyup', this._handleKeyUp);\r\n\r\n    // key down is on window because canvas cannot have focus\r\n    global.addEventListener('keydown', this._handleKeyDown);\r\n  }\r\n\r\n  private _handleKeyDown = (ev: KeyboardEvent) => {\r\n    const code = ev.code as Keys;\r\n    if (this._keys.indexOf(code) === -1) {\r\n      this._keys.push(code);\r\n      this._keysDown.push(code);\r\n      const keyEvent = new KeyEvent(code, ev.key, ev);\r\n      this.eventDispatcher.emit('down', keyEvent);\r\n      this.eventDispatcher.emit('press', keyEvent);\r\n    }\r\n  };\r\n\r\n  private _handleKeyUp = (ev: KeyboardEvent) => {\r\n    const code = ev.code as Keys;\r\n    const key = this._keys.indexOf(code);\r\n    this._keys.splice(key, 1);\r\n    this._keysUp.push(code);\r\n    const keyEvent = new KeyEvent(code, ev.key, ev);\r\n\r\n    // alias the old api, we may want to deprecate this in the future\r\n    this.eventDispatcher.emit('up', keyEvent);\r\n    this.eventDispatcher.emit('release', keyEvent);\r\n  };\r\n\r\n  public update() {\r\n    // Reset keysDown and keysUp after update is complete\r\n    this._keysDown.length = 0;\r\n    this._keysUp.length = 0;\r\n\r\n    // Emit synthetic \"hold\" event\r\n    for (let i = 0; i < this._keys.length; i++) {\r\n      this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets list of keys being pressed down\r\n   */\r\n  public getKeys(): Keys[] {\r\n    return this._keys;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.\r\n   * @param key Test whether a key was just pressed\r\n   */\r\n  public wasPressed(key: Keys): boolean {\r\n    return this._keysDown.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key is held down. This is persisted between frames.\r\n   * @param key  Test whether a key is held down\r\n   */\r\n  public isHeld(key: Keys): boolean {\r\n    return this._keys.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.\r\n   * @param key  Test whether a key was just released\r\n   */\r\n  public wasReleased(key: Keys): boolean {\r\n    return this._keysUp.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Trigger a manual key event\r\n   * @param type\r\n   * @param key\r\n   * @param character\r\n   */\r\n  public triggerEvent(type: 'down' | 'up', key: Keys, character?: string) {\r\n    if (type === 'down') {\r\n      this._handleKeyDown(new KeyboardEvent('keydown', {\r\n        code: key,\r\n        key: character ?? null\r\n      }));\r\n    }\r\n    if (type === 'up') {\r\n      this._handleKeyUp(new KeyboardEvent('keyup', {\r\n        code: key,\r\n        key: character ?? null\r\n      }));\r\n    }\r\n  }\r\n}\r\n","import {\r\n  InitializeEvent,\r\n  KillEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PostCollisionEvent,\r\n  PreCollisionEvent,\r\n  CollisionStartEvent,\r\n  CollisionEndEvent,\r\n  PostKillEvent,\r\n  PreKillEvent,\r\n  GameEvent,\r\n  ExitTriggerEvent,\r\n  EnterTriggerEvent,\r\n  EnterViewPortEvent,\r\n  ExitViewPortEvent\r\n} from './Events';\r\nimport { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { CanInitialize, CanUpdate, CanBeKilled } from './Interfaces/LifecycleEvents';\r\nimport { Scene } from './Scene';\r\nimport { Logger } from './Util/Log';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { Eventable } from './Interfaces/Evented';\r\nimport * as Events from './Events';\r\nimport { PointerEvents } from './Interfaces/PointerEventHandlers';\r\nimport { CollisionType } from './Collision/CollisionType';\r\n\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from './EntityComponentSystem/Components/MotionComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Rectangle } from './Graphics/Rectangle';\r\nimport { ColliderComponent } from './Collision/ColliderComponent';\r\nimport { Shape } from './Collision/Colliders/Shape';\r\nimport { watch } from './Util/Watch';\r\nimport { Collider, CollisionGroup } from './Collision/Index';\r\nimport { Circle } from './Graphics/Circle';\r\nimport { PointerEvent } from './Input/PointerEvent';\r\nimport { WheelEvent } from './Input/WheelEvent';\r\nimport { PointerComponent } from './Input/PointerComponent';\r\nimport { ActionsComponent } from './Actions/ActionsComponent';\r\nimport { Raster } from './Graphics/Raster';\r\nimport { Text } from './Graphics/Text';\r\nimport { CoordPlane } from './Math/coord-plane';\r\n\r\n/**\r\n * Type guard for checking if something is an Actor\r\n * @param x\r\n */\r\nexport function isActor(x: any): x is Actor {\r\n  return x instanceof Actor;\r\n}\r\n\r\n/**\r\n * Actor contructor options\r\n */\r\nexport interface ActorArgs {\r\n  /**\r\n   * Optionally set the name of the actor, default is 'anonymous'\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally set the x position of the actor, default is 0\r\n   */\r\n  x?: number;\r\n  /**\r\n   * Optionally set the y position of the actor, default is 0\r\n   */\r\n  y?: number;\r\n  /**\r\n   * Optionally set the (x, y) position of the actor as a vector, default is (0, 0)\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally set the coordinate plane of the actor, default is [[CoordPlane.World]] meaning actor is subject to camera positioning\r\n   */\r\n  coordPlane?: CoordPlane;\r\n  /**\r\n   * Optionally set the width of a box collider for the actor\r\n   */\r\n  width?: number;\r\n  /**\r\n   * Optionally set the height of a box collider for the actor\r\n   */\r\n  height?: number;\r\n  /**\r\n   * Optionally set the radius of the circle collider for the actor\r\n   */\r\n  radius?: number;\r\n  /**\r\n   * Optionally set the velocity of the actor in pixels/sec\r\n   */\r\n  vel?: Vector;\r\n  /**\r\n   * Optionally set the acceleration of the actor in pixels/sec^2\r\n   */\r\n  acc?: Vector;\r\n  /**\r\n   * Optionally se the rotation in radians (180 degrees = Math.PI radians)\r\n   */\r\n  rotation?: number;\r\n  /**\r\n   * Optionally set the angular velocity of the actor in radians/sec (180 degrees = Math.PI radians)\r\n   */\r\n  angularVelocity?: number;\r\n  /**\r\n   * Optionally set the scale of the actor's transform\r\n   */\r\n  scale?: Vector;\r\n  /**\r\n   * Optionally set the z index of the actor, default is 0\r\n   */\r\n  z?: number;\r\n  /**\r\n   * Optionally set the color of an actor, only used if no graphics are present\r\n   * If a width/height or a radius was set a default graphic will be added\r\n   */\r\n  color?: Color;\r\n  /**\r\n   * Optionally set the visibility of the actor\r\n   */\r\n  visible?: boolean;\r\n  /**\r\n   * Optionally set the anchor for graphics in the actor\r\n   */\r\n  anchor?: Vector;\r\n  /**\r\n   * Optionally set the collision type\r\n   */\r\n  collisionType?: CollisionType;\r\n  /**\r\n   * Optionally supply a collider for an actor, if supplied ignores any supplied width/height\r\n   */\r\n  collider?: Collider;\r\n  /**\r\n   * Optionally suppy a [[CollisionGroup]]\r\n   */\r\n  collisionGroup?: CollisionGroup;\r\n}\r\n\r\n/**\r\n * The most important primitive in Excalibur is an `Actor`. Anything that\r\n * can move on the screen, collide with another `Actor`, respond to events,\r\n * or interact with the current scene, must be an actor. An `Actor` **must**\r\n * be part of a [[Scene]] for it to be drawn to the screen.\r\n */\r\nexport class Actor extends Entity implements Eventable, PointerEvents, CanInitialize, CanUpdate, CanBeKilled {\r\n  // #region Properties\r\n\r\n  /**\r\n   * Set defaults for all Actors\r\n   */\r\n  public static defaults = {\r\n    anchor: Vector.Half\r\n  };\r\n\r\n  /**\r\n   * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,\r\n   * acceleration, mass, inertia, etc.\r\n   */\r\n  public get body(): BodyComponent {\r\n    return this.get(BodyComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[TransformComponent]]\r\n   */\r\n  public get transform(): TransformComponent {\r\n    return this.get(TransformComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[MotionComponent]]\r\n   */\r\n  public get motion(): MotionComponent {\r\n    return this.get(MotionComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[GraphicsComponent]]\r\n   */\r\n  public get graphics(): GraphicsComponent {\r\n    return this.get(GraphicsComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[ColliderComponent]]\r\n   */\r\n  public get collider(): ColliderComponent {\r\n    return this.get(ColliderComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[PointerComponent]] config\r\n   */\r\n  public get pointer(): PointerComponent {\r\n    return this.get(PointerComponent);\r\n  }\r\n\r\n  /**\r\n   * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.\r\n   *\r\n   *  Access to the Actor's built in [[ActionsComponent]] which forwards to the\r\n   * [[ActionContext|Action context]] of the actor.\r\n   */\r\n  public get actions(): ActionsComponent {\r\n    return this.get(ActionsComponent);\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor in pixels\r\n   */\r\n  public get pos(): Vector {\r\n    return this.transform.pos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in pixels\r\n   */\r\n  public set pos(thePos: Vector) {\r\n    this.transform.pos = thePos.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor from the last frame\r\n   */\r\n  public get oldPos(): Vector {\r\n    return this.body.oldPos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in the last frame\r\n   */\r\n  public set oldPos(thePos: Vector) {\r\n    this.body.oldPos.setTo(thePos.x, thePos.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public set vel(theVel: Vector) {\r\n    this.motion.vel = theVel.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor from the last frame\r\n   */\r\n  public get oldVel(): Vector {\r\n    return this.body.oldVel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor from the last frame\r\n   */\r\n  public set oldVel(theVel: Vector) {\r\n    this.body.oldVel.setTo(theVel.x, theVel.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be\r\n   * useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration vector of teh actor in pixels/second/second\r\n   */\r\n  public set acc(theAcc: Vector) {\r\n    this.motion.acc = theAcc.clone();\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public set oldAcc(theAcc: Vector) {\r\n    this.body.oldAcc.setTo(theAcc.x, theAcc.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public get oldAcc(): Vector {\r\n    return this.body.oldAcc;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public get rotation(): number {\r\n    return this.transform.rotation;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public set rotation(theAngle: number) {\r\n    this.transform.rotation = theAngle;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotational velocity of the actor in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotational velocity of the actor in radians/sec\r\n   */\r\n  public set angularVelocity(angularVelocity: number) {\r\n    this.motion.angularVelocity = angularVelocity;\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this.get(TransformComponent).scale;\r\n  }\r\n\r\n  public set scale(scale: Vector) {\r\n    this.get(TransformComponent).scale = scale;\r\n  }\r\n\r\n  /**\r\n   * The anchor to apply all actor related transformations like rotation,\r\n   * translation, and scaling. By default the anchor is in the center of\r\n   * the actor. By default it is set to the center of the actor (.5, .5)\r\n   *\r\n   * An anchor of (.5, .5) will ensure that drawings are centered.\r\n   *\r\n   * Use `anchor.setTo` to set the anchor to a different point using\r\n   * values between 0 and 1. For example, anchoring to the top-left would be\r\n   * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.\r\n   */\r\n  private _anchor: Vector = watch(Vector.Half, (v) => this._handleAnchorChange(v));\r\n  public get anchor(): Vector {\r\n    return this._anchor;\r\n  }\r\n\r\n  public set anchor(vec: Vector) {\r\n    this._anchor = watch(vec, (v) => this._handleAnchorChange(v));\r\n    this._handleAnchorChange(vec);\r\n  }\r\n\r\n  private _handleAnchorChange(v: Vector) {\r\n    if (this.graphics) {\r\n      this.graphics.anchor = v;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicates whether the actor is physically in the viewport\r\n   */\r\n  public get isOffScreen(): boolean {\r\n    return this.hasTag('ex.offscreen');\r\n  }\r\n\r\n  /**\r\n   * Convenience reference to the global logger\r\n   */\r\n  public logger: Logger = Logger.getInstance();\r\n\r\n  /**\r\n   * The scene that the actor is in\r\n   */\r\n  public scene: Scene = null;\r\n\r\n  /**\r\n   * Draggable helper\r\n   */\r\n  private _draggable: boolean = false;\r\n  private _dragging: boolean = false;\r\n\r\n  private _pointerDragStartHandler = () => {\r\n    this._dragging = true;\r\n  };\r\n\r\n  private _pointerDragEndHandler = () => {\r\n    this._dragging = false;\r\n  };\r\n\r\n  private _pointerDragMoveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.worldPos;\r\n    }\r\n  };\r\n\r\n  private _pointerDragLeaveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.worldPos;\r\n    }\r\n  };\r\n\r\n  public get draggable(): boolean {\r\n    return this._draggable;\r\n  }\r\n\r\n  public set draggable(isDraggable: boolean) {\r\n    if (isDraggable) {\r\n      if (isDraggable && !this._draggable) {\r\n        this.on('pointerdragstart', this._pointerDragStartHandler);\r\n        this.on('pointerdragend', this._pointerDragEndHandler);\r\n        this.on('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.on('pointerdragleave', this._pointerDragLeaveHandler);\r\n      } else if (!isDraggable && this._draggable) {\r\n        this.off('pointerdragstart', this._pointerDragStartHandler);\r\n        this.off('pointerdragend', this._pointerDragEndHandler);\r\n        this.off('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.off('pointerdragleave', this._pointerDragLeaveHandler);\r\n      }\r\n\r\n      this._draggable = isDraggable;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the color of the actor's current graphic\r\n   */\r\n  public get color(): Color {\r\n    return this._color;\r\n  }\r\n  public set color(v: Color) {\r\n    this._color = v.clone();\r\n    const defaultLayer = this.graphics.layers.default;\r\n    const currentGraphic = defaultLayer.graphics[0]?.graphic;\r\n    if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {\r\n      currentGraphic.color = this._color;\r\n    }\r\n  }\r\n  private _color: Color;\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   *\r\n   * @param config\r\n   */\r\n  constructor(config?: ActorArgs) {\r\n    super();\r\n\r\n    const {\r\n      name,\r\n      x,\r\n      y,\r\n      pos,\r\n      coordPlane,\r\n      scale,\r\n      width,\r\n      height,\r\n      radius,\r\n      collider,\r\n      vel,\r\n      acc,\r\n      rotation,\r\n      angularVelocity,\r\n      z,\r\n      color,\r\n      visible,\r\n      anchor,\r\n      collisionType,\r\n      collisionGroup\r\n    } = {\r\n      ...config\r\n    };\r\n\r\n    this._setName(name);\r\n    this.anchor = anchor ?? Actor.defaults.anchor.clone();\r\n    const tx = new TransformComponent();\r\n    this.addComponent(tx);\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.rotation = rotation ?? 0;\r\n    this.scale = scale ?? vec(1, 1);\r\n    this.z = z ?? 0;\r\n    tx.coordPlane = coordPlane ?? CoordPlane.World;\r\n\r\n    this.addComponent(new PointerComponent);\r\n\r\n    this.addComponent(new GraphicsComponent({\r\n      anchor: this.anchor\r\n    }));\r\n    this.addComponent(new MotionComponent());\r\n    this.vel = vel ?? Vector.Zero;\r\n    this.acc = acc ?? Vector.Zero;\r\n    this.angularVelocity = angularVelocity ?? 0;\r\n\r\n    this.addComponent(new ActionsComponent());\r\n\r\n    this.addComponent(new BodyComponent());\r\n    this.body.collisionType = collisionType ?? CollisionType.Passive;\r\n    if (collisionGroup) {\r\n      this.body.group = collisionGroup;\r\n    }\r\n\r\n    if (collider) {\r\n      this.addComponent(new ColliderComponent(collider));\r\n    } else if (radius) {\r\n      this.addComponent(new ColliderComponent(Shape.Circle(radius)));\r\n    } else {\r\n      if (width > 0 && height > 0) {\r\n        this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));\r\n      } else {\r\n        this.addComponent(new ColliderComponent()); // no collider\r\n      }\r\n    }\r\n\r\n    this.graphics.visible = visible ?? true;\r\n\r\n    if (color) {\r\n      this.color = color;\r\n      if (width && height) {\r\n        this.graphics.add(\r\n          new Rectangle({\r\n            color: color,\r\n            width,\r\n            height\r\n          })\r\n        );\r\n      } else if (radius) {\r\n        this.graphics.add(\r\n          new Circle({\r\n            color: color,\r\n            radius\r\n          })\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the actor. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n    for (const child of this.children) {\r\n      child._initialize(engine);\r\n    }\r\n  }\r\n\r\n  // #region Events\r\n\r\n  public on(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public on(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touched a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public on(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public on(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public on(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public on(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public on(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public on(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public on(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public on(eventName: Events.pointerdragstart, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragend, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragenter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragleave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragmove, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public on(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public once(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public once(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public once(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public once(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public once(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public once(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public once(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public once(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public once(eventName: Events.pointerdragstart, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragend, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragenter, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragleave, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragmove, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public once(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.exittrigger, handler?: (event: ExitTriggerEvent) => void): void;\r\n  public off(eventName: Events.entertrigger, handler?: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public off(eventName: Events.collisionstart, handler?: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public off(eventName: Events.collisionend, handler?: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public off(eventName: Events.precollision, handler?: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public off(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public off(eventName: Events.pointerup, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdown, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerenter, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerleave, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointermove, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointercancel, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerwheel, handler?: (event: WheelEvent) => void): void;\r\n  public off(eventName: Events.pointerdragstart, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragend, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragenter, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragleave, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragmove, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.prekill, handler?: (event: PreKillEvent) => void): void;\r\n  public off(eventName: Events.postkill, handler?: (event: PostKillEvent) => void): void;\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Actor>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.enterviewport, handler?: (event: EnterViewPortEvent) => void): void;\r\n  public off(eventName: Events.exitviewport, handler?: (event: ExitViewPortEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<Actor>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPreKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _prekill(_scene: Scene) {\r\n    super.emit('prekill', new PreKillEvent(this));\r\n    this.onPreKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`\r\n   *\r\n   * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].\r\n   */\r\n  public onPreKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPostKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postkill(_scene: Scene) {\r\n    super.emit('postkill', new PostKillEvent(this));\r\n    this.onPostKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`\r\n   *\r\n   * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].\r\n   */\r\n  public onPostKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If the current actor is a member of the scene, this will remove\r\n   * it from the scene graph. It will no longer be drawn or updated.\r\n   */\r\n  public kill() {\r\n    if (this.scene) {\r\n      this._prekill(this.scene);\r\n      this.emit('kill', new KillEvent(this));\r\n      super.kill();\r\n      this._postkill(this.scene);\r\n    } else {\r\n      this.logger.warn('Cannot kill actor, it was never added to the Scene');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the current actor is killed, it will now not be killed.\r\n   */\r\n  public unkill() {\r\n    this.active = true;\r\n  }\r\n\r\n  /**\r\n   * Indicates wether the actor has been killed.\r\n   */\r\n  public isKilled(): boolean {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   */\r\n  public get z(): number {\r\n    return this.get(TransformComponent).z;\r\n  }\r\n\r\n\r\n  /**\r\n   * Sets the z-index of an actor and updates it in the drawing list for the scene.\r\n   * The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   * @param newZ new z-index to assign\r\n   */\r\n  public set z(newZ: number) {\r\n    this.get(TransformComponent).z = newZ;\r\n  }\r\n\r\n  /**\r\n   * Get the center point of an actor (global position)\r\n   */\r\n  public get center(): Vector {\r\n    const globalPos = this.getGlobalPos();\r\n    return new Vector(\r\n      globalPos.x + this.width / 2 - this.anchor.x * this.width,\r\n      globalPos.y + this.height / 2 - this.anchor.y * this.height);\r\n  }\r\n\r\n  /**\r\n   * Get the local center point of an actor\r\n   */\r\n  public get localCenter(): Vector {\r\n    return new Vector(\r\n      this.pos.x + this.width / 2 - this.anchor.x * this.width,\r\n      this.pos.y + this.height / 2 - this.anchor.y * this.height);\r\n  }\r\n\r\n  public get width() {\r\n    return this.collider.localBounds.width * this.getGlobalScale().x;\r\n  }\r\n\r\n  public get height() {\r\n    return this.collider.localBounds.height * this.getGlobalScale().y;\r\n  }\r\n\r\n  /**\r\n   * Gets this actor's rotation taking into account any parent relationships\r\n   *\r\n   * @returns Rotation angle in radians\r\n   */\r\n  public getGlobalRotation(): number {\r\n    return this.get(TransformComponent).globalRotation;\r\n  }\r\n\r\n  /**\r\n   * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation\r\n   *\r\n   * @returns Position in world coordinates\r\n   */\r\n  public getGlobalPos(): Vector {\r\n    return this.get(TransformComponent).globalPos;\r\n  }\r\n\r\n  /**\r\n   * Gets the global scale of the Actor\r\n   */\r\n  public getGlobalScale(): Vector {\r\n    return this.get(TransformComponent).globalScale;\r\n  }\r\n\r\n  // #region Collision\r\n\r\n  /**\r\n   * Tests whether the x/y specified are contained in the actor\r\n   * @param x  X coordinate to test (in world coordinates)\r\n   * @param y  Y coordinate to test (in world coordinates)\r\n   * @param recurse checks whether the x/y are contained in any child actors (if they exist).\r\n   */\r\n  public contains(x: number, y: number, recurse: boolean = false): boolean {\r\n    const point = vec(x, y);\r\n    const collider = this.get(ColliderComponent);\r\n    collider.update();\r\n    const geom = collider.get();\r\n    if (!geom) {\r\n      return false;\r\n    }\r\n    const containment = geom.contains(point);\r\n\r\n    if (recurse) {\r\n      return (\r\n        containment ||\r\n        this.children.some((child: Actor) => {\r\n          return child.contains(x, y, true);\r\n        })\r\n      );\r\n    }\r\n\r\n    return containment;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other\r\n   * @param actor     Actor to test\r\n   * @param distance  Distance in pixels to test\r\n   */\r\n  public within(actor: Actor, distance: number): boolean {\r\n    const collider = this.get(ColliderComponent);\r\n    const otherCollider = actor.get(ColliderComponent);\r\n    const me = collider.get();\r\n    const other = otherCollider.get();\r\n    if (me && other) {\r\n      return me.getClosestLineBetween(other).getLength() <= distance;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // #endregion\r\n\r\n  // #region Update\r\n\r\n  /**\r\n   * Called by the Engine, updates the state of the actor\r\n   * @internal\r\n   * @param engine The reference to the current game engine\r\n   * @param delta  The time elapsed since the last update in milliseconds\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an actor is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an actor is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  // endregion\r\n}\r\n","import { Vector, vec } from './Math/vector';\r\nimport { Engine } from './Engine';\r\nimport { Actor, ActorArgs } from './Actor';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { CoordPlane } from './Math/coord-plane';\r\n\r\n/**\r\n * Type guard to detect a screen element\r\n */\r\nexport function isScreenElement(actor: Actor) {\r\n  return actor instanceof ScreenElement;\r\n}\r\n\r\n/**\r\n * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does\r\n * not participate in collisions. Drawn on top of all other actors.\r\n */\r\nexport class ScreenElement extends Actor {\r\n  protected _engine: Engine;\r\n\r\n  constructor();\r\n  constructor(config?: ActorArgs);\r\n\r\n  constructor(config?: ActorArgs) {\r\n    super({ ...config });\r\n    this.get(TransformComponent).coordPlane = CoordPlane.Screen;\r\n    this.anchor = vec(0, 0);\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n    this.collider.useBoxCollider(this.width, this.height, this.anchor);\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    this._engine = engine;\r\n    super._initialize(engine);\r\n  }\r\n\r\n  public contains(x: number, y: number, useWorld: boolean = true) {\r\n    if (useWorld) {\r\n      return super.contains(x, y);\r\n    }\r\n\r\n    const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));\r\n    return super.contains(coords.x, coords.y);\r\n  }\r\n}\r\n","import { Scene } from './Scene';\r\nimport { Logger } from './Util/Log';\r\nimport * as ex from './index';\r\nimport { Random } from './Math/Random';\r\n\r\n\r\nexport interface TimerOptions {\r\n  repeats?: boolean;\r\n  numberOfRepeats?: number;\r\n  fcn?: () => void;\r\n  interval: number;\r\n  randomRange?: [number, number];\r\n  random?: ex.Random;\r\n}\r\n\r\n/**\r\n * The Excalibur timer hooks into the internal timer and fires callbacks,\r\n * after a certain interval, optionally repeating.\r\n */\r\nexport class Timer {\r\n  private _logger = Logger.getInstance();\r\n  private static _MAX_ID: number = 0;\r\n  public id: number = 0;\r\n\r\n  private _elapsedTime: number = 0;\r\n  private _totalTimeAlive: number = 0;\r\n\r\n  private _running = false;\r\n\r\n  private _numberOfTicks: number = 0;\r\n  private _callbacks: Array<() => void>;\r\n\r\n  public interval: number = 10;\r\n  public repeats: boolean = false;\r\n  public maxNumberOfRepeats: number = -1;\r\n  public randomRange: [number, number] = [0,0];\r\n  public random: ex.Random;\r\n  private _baseInterval = 10;\r\n  private _generateRandomInterval = () => {\r\n    return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);\r\n  };\r\n\r\n  private _complete = false;\r\n  public get complete() {\r\n    return this._complete;\r\n  }\r\n\r\n  public scene: Scene = null;\r\n\r\n  /**\r\n   * @param options    Options - repeats, numberOfRepeats, fcn, interval\r\n   * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.\r\n   * @param numberOfRepeats Specifies a maximum number of times that this timer will execute.\r\n   * @param fcn        The callback to be fired after the interval is complete.\r\n   * @param randomRange Indicates a range to select a random number to be added onto the interval\r\n   */\r\n  constructor(options: TimerOptions);\r\n  constructor(fcn: TimerOptions | (() => void), interval?: number,\r\n    repeats?: boolean, numberOfRepeats?: number, randomRange?: [number, number], random?: ex.Random) {\r\n    if (typeof fcn !== 'function') {\r\n      const options = fcn;\r\n      fcn = options.fcn;\r\n      interval = options.interval;\r\n      repeats = options.repeats;\r\n      numberOfRepeats = options.numberOfRepeats;\r\n      randomRange = options.randomRange;\r\n      random= options.random;\r\n    }\r\n\r\n    if (!!numberOfRepeats && numberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = numberOfRepeats;\r\n      if (!repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this.id = Timer._MAX_ID++;\r\n    this._callbacks = [];\r\n    this._baseInterval = this.interval = interval;\r\n    if (!!randomRange){\r\n      if (randomRange[0] > randomRange[1]) {\r\n        throw new Error('min value must be lower than max value for range');\r\n      }\r\n      //We use the instance of ex.Random to generate the range\r\n      this.random = random ?? new Random();\r\n      this.randomRange = randomRange;\r\n\r\n      this.interval = this._generateRandomInterval();\r\n      this.on(() => {\r\n        this.interval = this._generateRandomInterval();\r\n      });\r\n    };\r\n    this.repeats = repeats || this.repeats;\r\n    if (fcn) {\r\n      this.on(fcn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a new callback to be fired after the interval is complete\r\n   * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.\r\n   */\r\n  public on(fcn: () => void) {\r\n    this._callbacks.push(fcn);\r\n  }\r\n\r\n  /**\r\n   * Removes a callback from the callback list to be fired after the interval is complete.\r\n   * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.\r\n   */\r\n  public off(fcn: () => void) {\r\n    const index = this._callbacks.indexOf(fcn);\r\n    this._callbacks.splice(index, 1);\r\n  }\r\n  /**\r\n   * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.\r\n   * @param delta  Number of elapsed milliseconds since the last update.\r\n   */\r\n  public update(delta: number) {\r\n    if (this._running) {\r\n      this._totalTimeAlive += delta;\r\n      this._elapsedTime += delta;\r\n\r\n      if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {\r\n        this._complete = true;\r\n        this._running = false;\r\n        this._elapsedTime = 0;\r\n      }\r\n\r\n      if (!this.complete && this._elapsedTime >= this.interval) {\r\n        this._callbacks.forEach((c) => {\r\n          c.call(this);\r\n        });\r\n        this._numberOfTicks++;\r\n        if (this.repeats) {\r\n          this._elapsedTime = 0;\r\n        } else {\r\n          this._complete = true;\r\n          this._running = false;\r\n          this._elapsedTime = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.\r\n   *\r\n   * Warning** you may need to call `timer.start()` again if the timer had completed\r\n   * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback\r\n   * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes\r\n   */\r\n  public reset(newInterval?: number, newNumberOfRepeats?: number) {\r\n    if (!!newInterval && newInterval >= 0) {\r\n      this._baseInterval = this.interval= newInterval;\r\n    }\r\n\r\n    if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = newNumberOfRepeats;\r\n      if (!this.repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this._complete = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n  }\r\n\r\n  public get timesRepeated(): number {\r\n    return this._numberOfTicks;\r\n  }\r\n\r\n  public getTimeRunning(): number {\r\n    return this._totalTimeAlive;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds until the next action callback, if complete will return 0\r\n   */\r\n  public get timeToNextAction() {\r\n    if (this.complete) {\r\n      return 0;\r\n    }\r\n    return this.interval - this._elapsedTime;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds elapsed toward the next action\r\n   */\r\n  public get timeElapsedTowardNextAction() {\r\n    return this._elapsedTime;\r\n  }\r\n\r\n  public get isRunning() {\r\n    return this._running;\r\n  }\r\n\r\n  /**\r\n   * Pauses the timer, time will no longer increment towards the next call\r\n   */\r\n  public pause(): Timer {\r\n    this._running = false;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resumes the timer, time will now increment towards the next call.\r\n   */\r\n  public resume(): Timer {\r\n    this._running = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter\r\n   */\r\n  public start(): Timer {\r\n    if (!this.scene) {\r\n      this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');\r\n    }\r\n\r\n    this._running = true;\r\n    if (this.complete) {\r\n      this._complete = false;\r\n      this._elapsedTime = 0;\r\n      this._numberOfTicks = 0;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stops the timer and resets the elapsed time counter towards the next action invocation\r\n   */\r\n  public stop(): Timer {\r\n    this._running = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Cancels the timer, preventing any further executions.\r\n   */\r\n  public cancel() {\r\n    this.pause();\r\n    if (this.scene) {\r\n      this.scene.cancelTimer(this);\r\n    }\r\n  }\r\n}\r\n\r\n","import { Component } from '../EntityComponentSystem/Component';\r\nimport { vec, Vector } from '../Math/vector';\r\n\r\nexport class ParallaxComponent extends Component<'ex.parallax'> {\r\n  readonly type = 'ex.parallax';\r\n\r\n  parallaxFactor = vec(1.0, 1.0);\r\n\r\n  constructor(parallaxFactor?: Vector) {\r\n    super();\r\n    this.parallaxFactor = parallaxFactor ?? this.parallaxFactor;\r\n  }\r\n}","import { ExcaliburGraphicsContext } from '.';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\n\r\n\r\n/**\r\n * Provide arbitrary drawing for the purposes of debugging your game\r\n *\r\n * Will only show when the Engine is set to debug mode [[Engine.showDebug]] or [[Engine.toggleDebug]]\r\n *\r\n */\r\nexport class DebugGraphicsComponent extends Component<'ex.debuggraphics'> {\r\n  readonly type = 'ex.debuggraphics';\r\n  constructor(public draw: (ctx: ExcaliburGraphicsContext) => void, public useTransform = true) {\r\n    super();\r\n  }\r\n}","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Engine } from '../Engine';\r\nimport { Vector, vec } from '../Math/vector';\r\nimport { Logger } from '../Util/Log';\r\nimport * as Events from '../Events';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { BodyComponent } from '../Collision/BodyComponent';\r\nimport { CollisionType } from '../Collision/CollisionType';\r\nimport { Shape } from '../Collision/Colliders/Shape';\r\nimport { ExcaliburGraphicsContext, Graphic, GraphicsComponent, hasGraphicsTick, ParallaxComponent } from '../Graphics';\r\nimport { removeItemFromArray } from '../Util/Util';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { CompositeCollider } from '../Collision/Colliders/CompositeCollider';\r\nimport { Color } from '../Color';\r\nimport { DebugGraphicsComponent } from '../Graphics/DebugGraphicsComponent';\r\nimport { Collider } from '../Collision/Colliders/Collider';\r\n\r\nexport interface TileMapOptions {\r\n  /**\r\n   * Optionally name the isometric tile map\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally specify the position of the isometric tile map\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Width of an individual tile in pixels\r\n   */\r\n  tileWidth: number;\r\n  /**\r\n   * Height of an individual tile in pixels\r\n   */\r\n  tileHeight: number;\r\n  /**\r\n   * The number of tile columns, or the number of tiles wide\r\n   */\r\n  columns: number;\r\n  /**\r\n   * The number of tile  rows, or the number of tiles high\r\n   */\r\n  rows: number;\r\n\r\n  /**\r\n   * Optionally render from the top of the graphic, by default tiles are rendered from the bottom\r\n   */\r\n  renderFromTopOfGraphic?: boolean;\r\n}\r\n\r\n/**\r\n * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.\r\n *\r\n * TileMaps are useful for top down or side scrolling grid oriented games.\r\n */\r\nexport class TileMap extends Entity {\r\n  private _token = 0;\r\n  private _onScreenXStart: number = 0;\r\n  private _onScreenXEnd: number = Number.MAX_VALUE;\r\n  private _onScreenYStart: number = 0;\r\n  private _onScreenYEnd: number = Number.MAX_VALUE;\r\n\r\n  public logger: Logger = Logger.getInstance();\r\n  public readonly tiles: Tile[] = [];\r\n  private _rows: Tile[][] = [];\r\n  private _cols: Tile[][] = [];\r\n\r\n  public readonly tileWidth: number;\r\n  public readonly tileHeight: number;\r\n  public readonly rows: number;\r\n  public readonly columns: number;\r\n\r\n  public renderFromTopOfGraphic = false;\r\n\r\n  private _collidersDirty = true;\r\n  public flagCollidersDirty() {\r\n    this._collidersDirty = true;\r\n\r\n  }\r\n  private _transform: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _graphics: GraphicsComponent;\r\n  private _collider: ColliderComponent;\r\n  private _composite: CompositeCollider;\r\n\r\n  public get x(): number {\r\n    return this._transform.pos.x ?? 0;\r\n  }\r\n\r\n  public set x(val: number) {\r\n    if (this._transform?.pos) {\r\n      this.get(TransformComponent).pos = vec(val, this.y);\r\n    }\r\n  }\r\n\r\n  public get y(): number {\r\n    return this._transform?.pos.y ?? 0;\r\n  }\r\n\r\n  public set y(val: number) {\r\n    if (this._transform?.pos) {\r\n      this._transform.pos = vec(this.x, val);\r\n    }\r\n  }\r\n\r\n  public get z(): number {\r\n    return this._transform.z ?? 0;\r\n  }\r\n\r\n  public set z(val: number) {\r\n    if (this._transform) {\r\n      this._transform.z = val;\r\n    }\r\n  }\r\n\r\n  public get rotation(): number {\r\n    return this._transform?.rotation ?? 0;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    if (this._transform?.rotation) {\r\n      this._transform.rotation = val;\r\n    }\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this._transform?.scale ?? Vector.One;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    if (this._transform?.scale) {\r\n      this._transform.scale = val;\r\n    }\r\n  }\r\n\r\n  private _oldPos: Vector;\r\n  public get pos(): Vector {\r\n    return this._transform.pos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this._transform.pos = val;\r\n  }\r\n\r\n  public get vel(): Vector {\r\n    return this._motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this._motion.vel = val;\r\n  }\r\n\r\n  public on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n\r\n  /**\r\n   * @param options\r\n   */\r\n  constructor(options: TileMapOptions) {\r\n    super(null, options.name);\r\n    this.addComponent(new TransformComponent());\r\n    this.addComponent(new MotionComponent());\r\n    this.addComponent(\r\n      new BodyComponent({\r\n        type: CollisionType.Fixed\r\n      })\r\n    );\r\n    this.addComponent(\r\n      new GraphicsComponent({\r\n        onPostDraw: (ctx, delta) => this.draw(ctx, delta)\r\n      })\r\n    );\r\n    this.addComponent(new DebugGraphicsComponent((ctx) => this.debug(ctx)));\r\n    this.addComponent(new ColliderComponent());\r\n    this._graphics = this.get(GraphicsComponent);\r\n    this._transform = this.get(TransformComponent);\r\n    this._motion = this.get(MotionComponent);\r\n    this._collider = this.get(ColliderComponent);\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n\r\n    this._transform.pos = options.pos ?? Vector.Zero;\r\n    this._oldPos = this._transform.pos;\r\n    this.renderFromTopOfGraphic = options.renderFromTopOfGraphic ?? this.renderFromTopOfGraphic;\r\n    this.tileWidth = options.tileWidth;\r\n    this.tileHeight = options.tileHeight;\r\n    this.rows = options.rows;\r\n    this.columns = options.columns;\r\n    this.tiles = new Array<Tile>(this.rows * this.columns);\r\n    this._rows = new Array(this.rows);\r\n    this._cols = new Array(this.columns);\r\n    let currentCol: Tile[] = [];\r\n    for (let i = 0; i < this.columns; i++) {\r\n      for (let j = 0; j < this.rows; j++) {\r\n        const cd = new Tile({\r\n          x: i,\r\n          y: j,\r\n          map: this\r\n        });\r\n        cd.map = this;\r\n        this.tiles[i + j * this.columns] = cd;\r\n        currentCol.push(cd);\r\n        if (!this._rows[j]) {\r\n          this._rows[j] = [];\r\n        }\r\n        this._rows[j].push(cd);\r\n      }\r\n      this._cols[i] = currentCol;\r\n      currentCol = [];\r\n    }\r\n\r\n    this._graphics.localBounds = new BoundingBox({\r\n      left: 0,\r\n      top: 0,\r\n      right: this.columns * this.tileWidth,\r\n      bottom: this.rows * this.tileHeight\r\n    });\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n\r\n  private _originalOffsets = new WeakMap<Collider, Vector>();\r\n  private _getOrSetColliderOriginalOffset(collider: Collider): Vector {\r\n    if (!this._originalOffsets.has(collider)) {\r\n      const originalOffset = collider.offset;\r\n      this._originalOffsets.set(collider, originalOffset);\r\n      return originalOffset;\r\n    } else {\r\n      return this._originalOffsets.get(collider);\r\n    }\r\n  }\r\n  /**\r\n   * Tiles colliders based on the solid tiles in the tilemap.\r\n   */\r\n  private _updateColliders(): void {\r\n    this._composite.clearColliders();\r\n    const colliders: BoundingBox[] = [];\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n    let current: BoundingBox;\r\n    // Bad square tesselation algo\r\n    for (let i = 0; i < this.columns; i++) {\r\n      // Scan column for colliders\r\n      for (let j = 0; j < this.rows; j++) {\r\n        // Columns start with a new collider\r\n        if (j === 0) {\r\n          current = null;\r\n        }\r\n        const tile = this.tiles[i + j * this.columns];\r\n        // Current tile in column is solid build up current collider\r\n        if (tile.solid) {\r\n          // Use custom collider otherwise bounding box\r\n          if (tile.getColliders().length > 0) {\r\n            for (const collider of tile.getColliders()) {\r\n              const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n              collider.offset = vec(tile.x * this.tileWidth, tile.y * this.tileHeight).add(originalOffset);\r\n              collider.owner = this;\r\n              this._composite.addCollider(collider);\r\n            }\r\n            current = null;\r\n          } else {\r\n            if (!current) {\r\n              current = tile.bounds;\r\n            } else {\r\n              current = current.combine(tile.bounds);\r\n            }\r\n          }\r\n        } else {\r\n          // Not solid skip and cut off the current collider\r\n          if (current) {\r\n            colliders.push(current);\r\n          }\r\n          current = null;\r\n        }\r\n      }\r\n      // After a column is complete check to see if it can be merged into the last one\r\n      if (current) {\r\n        // if previous is the same combine it\r\n        const prev = colliders[colliders.length - 1];\r\n        if (prev && prev.top === current.top && prev.bottom === current.bottom) {\r\n          colliders[colliders.length - 1] = prev.combine(current);\r\n        } else {\r\n          // else new collider\r\n          colliders.push(current);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const c of colliders) {\r\n      const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));\r\n      collider.owner = this;\r\n      this._composite.addCollider(collider);\r\n    }\r\n    this._collider.update();\r\n  }\r\n\r\n  /**\r\n   * Returns the [[Tile]] by index (row major order)\r\n   */\r\n  public getTileByIndex(index: number): Tile {\r\n    return this.tiles[index];\r\n  }\r\n  /**\r\n   * Returns the [[Tile]] by its x and y integer coordinates\r\n   */\r\n  public getTile(x: number, y: number): Tile {\r\n    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n      return null;\r\n    }\r\n    return this.tiles[x + y * this.columns];\r\n  }\r\n  /**\r\n   * Returns the [[Tile]] by testing a point in world coordinates,\r\n   * returns `null` if no Tile was found.\r\n   */\r\n  public getTileByPoint(point: Vector): Tile {\r\n    const x = Math.floor((point.x - this.pos.x) / this.tileWidth);\r\n    const y = Math.floor((point.y - this.pos.y) / this.tileHeight);\r\n    const tile = this.getTile(x, y);\r\n    if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {\r\n      return tile;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public getRows(): readonly Tile[][] {\r\n    return this._rows;\r\n  }\r\n\r\n  public getColumns(): readonly Tile[][] {\r\n    return this._cols;\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    this.onPreUpdate(engine, delta);\r\n    this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));\r\n    if (!this._oldPos.equals(this.pos)) {\r\n      this.flagCollidersDirty();\r\n      for (let i = 0; i < this.tiles.length; i++) {\r\n        if (this.tiles[i]) {\r\n          this.tiles[i].flagDirty();\r\n        }\r\n      }\r\n    }\r\n    if (this._collidersDirty) {\r\n      this._collidersDirty = false;\r\n      this._updateColliders();\r\n    }\r\n\r\n    this._token++;\r\n    const worldBounds = engine.getWorldBounds();\r\n    const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);\r\n    const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);\r\n\r\n    let pos = this.pos;\r\n    const maybeParallax = this.get(ParallaxComponent);\r\n    let parallaxOffset = Vector.One;\r\n    if (maybeParallax) {\r\n      const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n      parallaxOffset = engine.currentScene.camera.pos.scale(oneMinusFactor);\r\n      pos = pos.add(parallaxOffset);\r\n    }\r\n\r\n    this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - pos.x) / this.tileWidth) - 2, 0);\r\n    this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - pos.y) / this.tileHeight) - 2, 0);\r\n    this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - pos.x) / this.tileWidth) + 2, 0);\r\n    this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - pos.y) / this.tileHeight) + 2, 0);\r\n    // why are we resetting pos?\r\n    this._transform.pos = vec(this.x, this.y);\r\n\r\n    this.onPostUpdate(engine, delta);\r\n    this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));\r\n  }\r\n\r\n  /**\r\n   * Draws the tile map to the screen. Called by the [[Scene]].\r\n   * @param ctx ExcaliburGraphicsContext\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext, delta: number): void {\r\n    this.emit('predraw', new Events.PreDrawEvent(ctx as any, delta, this)); // TODO fix event\r\n\r\n    let x = this._onScreenXStart;\r\n    const xEnd = Math.min(this._onScreenXEnd, this.columns);\r\n    let y = this._onScreenYStart;\r\n    const yEnd = Math.min(this._onScreenYEnd, this.rows);\r\n\r\n    let graphics: readonly Graphic[], graphicsIndex: number, graphicsLen: number;\r\n\r\n    for (x; x < xEnd; x++) {\r\n      for (y; y < yEnd; y++) {\r\n        // get non-negative tile sprites\r\n        graphics = this.getTile(x, y).getGraphics();\r\n\r\n        for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {\r\n          // draw sprite, warning if sprite doesn't exist\r\n          const graphic = graphics[graphicsIndex];\r\n          if (graphic) {\r\n            if (hasGraphicsTick(graphic)) {\r\n              graphic?.tick(delta, this._token);\r\n            }\r\n            const offsetY = this.renderFromTopOfGraphic ? 0 : (graphic.height - this.tileHeight);\r\n            graphic.draw(ctx, x * this.tileWidth, y * this.tileHeight - offsetY);\r\n          }\r\n        }\r\n      }\r\n      y = this._onScreenYStart;\r\n    }\r\n\r\n    this.emit('postdraw', new Events.PostDrawEvent(ctx as any, delta, this));\r\n  }\r\n\r\n  public debug(gfx: ExcaliburGraphicsContext) {\r\n    const width = this.tileWidth * this.columns;\r\n    const height = this.tileHeight * this.rows;\r\n    const pos = Vector.Zero;\r\n    for (let r = 0; r < this.rows + 1; r++) {\r\n      const yOffset = vec(0, r * this.tileHeight);\r\n      gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);\r\n    }\r\n\r\n    for (let c = 0; c < this.columns + 1; c++) {\r\n      const xOffset = vec(c * this.tileWidth, 0);\r\n      gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);\r\n    }\r\n\r\n    const colliders = this._composite.getColliders();\r\n    for (const collider of colliders) {\r\n      const grayish = Color.Gray;\r\n      grayish.a = 0.5;\r\n      const bounds = collider.localBounds;\r\n      const pos = collider.worldPos.sub(this.pos);\r\n      gfx.drawRectangle(pos, bounds.width, bounds.height, grayish);\r\n    }\r\n  }\r\n}\r\n\r\nexport interface TileOptions {\r\n  /**\r\n   * Integer tile x coordinate\r\n   */\r\n  x: number;\r\n  /**\r\n   * Integer tile y coordinate\r\n   */\r\n  y: number;\r\n  map: TileMap;\r\n  solid?: boolean;\r\n  graphics?: Graphic[];\r\n}\r\n\r\n/**\r\n * TileMap Tile\r\n *\r\n * A light-weight object that occupies a space in a collision map. Generally\r\n * created by a [[TileMap]].\r\n *\r\n * Tiles can draw multiple sprites. Note that the order of drawing is the order\r\n * of the sprites in the array so the last one will be drawn on top. You can\r\n * use transparency to create layers this way.\r\n */\r\nexport class Tile extends Entity {\r\n  private _bounds: BoundingBox;\r\n  private _pos: Vector;\r\n  private _posDirty = false;\r\n  // private _transform: TransformComponent;\r\n\r\n  /**\r\n   * Return the world position of the top left corner of the tile\r\n   */\r\n  public get pos() {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n      this._posDirty = false;\r\n    }\r\n    return this._pos;\r\n  }\r\n\r\n  /**\r\n   * Integer x coordinate of the tile\r\n   */\r\n  public readonly x: number;\r\n\r\n  /**\r\n   * Integer y coordinate of the tile\r\n   */\r\n  public readonly y: number;\r\n\r\n  /**\r\n   * Width of the tile in pixels\r\n   */\r\n  public readonly width: number;\r\n\r\n  /**\r\n   * Height of the tile in pixels\r\n   */\r\n  public readonly height: number;\r\n\r\n  /**\r\n   * Reference to the TileMap this tile is associated with\r\n   */\r\n  public map: TileMap;\r\n\r\n  private _solid = false;\r\n  /**\r\n   * Wether this tile should be treated as solid by the tilemap\r\n   */\r\n  public get solid(): boolean {\r\n    return this._solid;\r\n  }\r\n  /**\r\n   * Wether this tile should be treated as solid by the tilemap\r\n   */\r\n  public set solid(val: boolean) {\r\n    this.map?.flagCollidersDirty();\r\n    this._solid = val;\r\n  }\r\n\r\n  private _graphics: Graphic[] = [];\r\n\r\n  /**\r\n   * Current list of graphics for this tile\r\n   */\r\n  public getGraphics(): readonly Graphic[] {\r\n    return this._graphics;\r\n  }\r\n\r\n  /**\r\n   * Add another [[Graphic]] to this TileMap tile\r\n   * @param graphic\r\n   */\r\n  public addGraphic(graphic: Graphic) {\r\n    this._graphics.push(graphic);\r\n  }\r\n\r\n  /**\r\n   * Remove an instance of a [[Graphic]] from this tile\r\n   */\r\n  public removeGraphic(graphic: Graphic) {\r\n    removeItemFromArray(graphic, this._graphics);\r\n  }\r\n\r\n  /**\r\n   * Clear all graphics from this tile\r\n   */\r\n  public clearGraphics() {\r\n    this._graphics.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Current list of colliders for this tile\r\n   */\r\n  private _colliders: Collider[] = [];\r\n\r\n  /**\r\n   * Returns the list of colliders\r\n   */\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Adds a custom collider to the [[Tile]] to use instead of it's bounds\r\n   *\r\n   * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.\r\n   *\r\n   * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n   * @param collider\r\n   */\r\n  public addCollider(collider: Collider) {\r\n    this._colliders.push(collider);\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Removes a collider from the [[Tile]]\r\n   * @param collider\r\n   */\r\n  public removeCollider(collider: Collider) {\r\n    const index = this._colliders.indexOf(collider);\r\n    if (index > -1) {\r\n      this._colliders.splice(index, 1);\r\n    }\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Clears all colliders from the [[Tile]]\r\n   */\r\n  public clearColliders() {\r\n    this._colliders.length = 0;\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Arbitrary data storage per tile, useful for any game specific data\r\n   */\r\n  public data = new Map<string, any>();\r\n\r\n  constructor(options: TileOptions) {\r\n    super();\r\n    this.x = options.x;\r\n    this.y = options.y;\r\n    this.map = options.map;\r\n    this.width = options.map.tileWidth;\r\n    this.height = options.map.tileHeight;\r\n    this.solid = options.solid ?? this.solid;\r\n    this._graphics = options.graphics ?? [];\r\n    this._recalculate();\r\n  }\r\n\r\n  public flagDirty() {\r\n    return this._posDirty = true;\r\n  }\r\n\r\n  private _recalculate() {\r\n    this._pos = this.map.pos.add(\r\n      vec(\r\n        this.x * this.map.tileWidth,\r\n        this.y * this.map.tileHeight));\r\n    this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this.width, this._pos.y + this.height);\r\n    this._posDirty = false;\r\n  }\r\n\r\n  public get bounds() {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._bounds;\r\n  }\r\n\r\n  public get center(): Vector {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n    }\r\n    return new Vector(this._pos.x + this.width / 2, this._pos.y + this.height / 2);\r\n  }\r\n}","import { Engine } from './Engine';\r\nimport { Screen } from './Screen';\r\nimport { EasingFunction, EasingFunctions } from './Util/EasingFunctions';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { Actor } from './Actor';\r\nimport { removeItemFromArray } from './Util/Util';\r\nimport { CanUpdate, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { PreUpdateEvent, PostUpdateEvent, GameEvent, InitializeEvent } from './Events';\r\nimport { Class } from './Class';\r\nimport { BoundingBox } from './Collision/BoundingBox';\r\nimport { Logger } from './Util/Log';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { watchAny } from './Util/Watch';\r\nimport { AffineMatrix } from './Math/affine-matrix';\r\n\r\n/**\r\n * Interface that describes a custom camera strategy for tracking targets\r\n */\r\nexport interface CameraStrategy<T> {\r\n  /**\r\n   * Target of the camera strategy that will be passed to the action\r\n   */\r\n  target: T;\r\n\r\n  /**\r\n   * Camera strategies perform an action to calculate a new focus returned out of the strategy\r\n   * @param target The target object to apply this camera strategy (if any)\r\n   * @param camera The current camera implementation in excalibur running the game\r\n   * @param engine The current engine running the game\r\n   * @param delta The elapsed time in milliseconds since the last frame\r\n   */\r\n  action: (target: T, camera: Camera, engine: Engine, delta: number) => Vector;\r\n}\r\n\r\n/**\r\n * Container to house convenience strategy methods\r\n * @internal\r\n */\r\nexport class StrategyContainer {\r\n  constructor(public camera: Camera) {}\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.\r\n   * @param actor The actor to lock the camera to\r\n   */\r\n  public lockToActor(actor: Actor) {\r\n    this.camera.addStrategy(new LockCameraToActorStrategy(actor));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera\r\n   * @param actor The actor to lock the camera to\r\n   * @param axis The axis to follow the actor on\r\n   */\r\n  public lockToActorAxis(actor: Actor, axis: Axis) {\r\n    this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[ElasticToActorStrategy]] on the current camera\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param actor Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  public elasticToActor(actor: Actor, cameraElasticity: number, cameraFriction: number) {\r\n    this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera\r\n   * @param actor Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  public radiusAroundActor(actor: Actor, radius: number) {\r\n    this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera\r\n   * @param box The bounding box to limit the camera to.\r\n   */\r\n  public limitCameraBounds(box: BoundingBox) {\r\n    this.camera.addStrategy(new LimitCameraBoundsStrategy(box));\r\n  }\r\n}\r\n\r\n/**\r\n * Camera axis enum\r\n */\r\nexport enum Axis {\r\n  X,\r\n  Y\r\n}\r\n\r\n/**\r\n * Lock a camera to the exact x/y position of an actor.\r\n */\r\nexport class LockCameraToActorStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor) {}\r\n  public action = (target: Actor, _cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    return center;\r\n  };\r\n}\r\n\r\n/**\r\n * Lock a camera to a specific axis around an actor.\r\n */\r\nexport class LockCameraToActorAxisStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor, public axis: Axis) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    const currentFocus = cam.getFocus();\r\n    if (this.axis === Axis.X) {\r\n      return new Vector(center.x, currentFocus.y);\r\n    } else {\r\n      return new Vector(currentFocus.x, center.y);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.\r\n */\r\nexport class ElasticToActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param target Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  constructor(public target: Actor, public cameraElasticity: number, public cameraFriction: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    let focus = cam.getFocus();\r\n    let cameraVel = cam.vel.clone();\r\n\r\n    // Calculate the stretch vector, using the spring equation\r\n    // F = kX\r\n    // https://en.wikipedia.org/wiki/Hooke's_law\r\n    // Apply to the current camera velocity\r\n    const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X\r\n    cameraVel = cameraVel.add(stretch);\r\n\r\n    // Calculate the friction (-1 to apply a force in the opposition of motion)\r\n    // Apply to the current camera velocity\r\n    const friction = cameraVel.scale(-1).scale(this.cameraFriction);\r\n    cameraVel = cameraVel.add(friction);\r\n\r\n    // Update position by velocity deltas\r\n    focus = focus.add(cameraVel);\r\n\r\n    return focus;\r\n  };\r\n}\r\n\r\nexport class RadiusAroundActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   *\r\n   * @param target Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  constructor(public target: Actor, public radius: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    const focus = cam.getFocus();\r\n\r\n    const direction = position.sub(focus);\r\n    const distance = direction.size;\r\n    if (distance >= this.radius) {\r\n      const offset = distance - this.radius;\r\n      return focus.add(direction.normalize().scale(offset));\r\n    }\r\n    return focus;\r\n  };\r\n}\r\n\r\n/**\r\n * Prevent a camera from going beyond the given camera dimensions.\r\n */\r\nexport class LimitCameraBoundsStrategy implements CameraStrategy<BoundingBox> {\r\n  /**\r\n   * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.\r\n   *\r\n   * Note that this strategy does not perform any movement by itself.\r\n   * It only sets the camera position to within the given bounds when the camera has gone beyond them.\r\n   * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.\r\n   *\r\n   * Make sure that the camera bounds are at least as large as the viewport size.\r\n   *\r\n   * @param target The bounding box to limit the camera to\r\n   */\r\n\r\n  boundSizeChecked: boolean = false; // Check and warn only once\r\n\r\n  constructor(public target: BoundingBox) {}\r\n\r\n  public action = (target: BoundingBox, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const focus = cam.getFocus();\r\n\r\n    if (!this.boundSizeChecked) {\r\n      if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {\r\n        Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');\r\n      }\r\n      this.boundSizeChecked = true;\r\n    }\r\n\r\n    let focusX = focus.x;\r\n    let focusY = focus.y;\r\n    if (focus.x < target.left + _eng.halfDrawWidth) {\r\n      focusX = target.left + _eng.halfDrawWidth;\r\n    } else if (focus.x > target.right - _eng.halfDrawWidth) {\r\n      focusX = target.right - _eng.halfDrawWidth;\r\n    }\r\n\r\n    if (focus.y < target.top + _eng.halfDrawHeight) {\r\n      focusY = target.top + _eng.halfDrawHeight;\r\n    } else if (focus.y > target.bottom - _eng.halfDrawHeight) {\r\n      focusY = target.bottom - _eng.halfDrawHeight;\r\n    }\r\n\r\n    return vec(focusX, focusY);\r\n  };\r\n}\r\n\r\n/**\r\n * Cameras\r\n *\r\n * [[Camera]] is the base class for all Excalibur cameras. Cameras are used\r\n * to move around your game and set focus. They are used to determine\r\n * what is \"off screen\" and can be used to scale the game.\r\n *\r\n */\r\nexport class Camera extends Class implements CanUpdate, CanInitialize {\r\n  public transform: AffineMatrix = AffineMatrix.identity();\r\n  public inverse: AffineMatrix = AffineMatrix.identity();\r\n\r\n\r\n  protected _follow: Actor;\r\n\r\n  private _cameraStrategies: CameraStrategy<any>[] = [];\r\n\r\n  public strategy: StrategyContainer = new StrategyContainer(this);\r\n\r\n  /**\r\n   * Get or set current zoom of the camera, defaults to 1\r\n   */\r\n  private _z = 1;\r\n  public get zoom(): number {\r\n    return this._z;\r\n  }\r\n\r\n  public set zoom(val: number) {\r\n    this._z = val;\r\n    if (this._engine) {\r\n      this._halfWidth = this._engine.halfDrawWidth;\r\n      this._halfHeight = this._engine.halfDrawHeight;\r\n    }\r\n  }\r\n  /**\r\n   * Get or set rate of change in zoom, defaults to 0\r\n   */\r\n  public dz: number = 0;\r\n  /**\r\n   * Get or set zoom acceleration\r\n   */\r\n  public az: number = 0;\r\n\r\n  /**\r\n   * Current rotation of the camera\r\n   */\r\n  public rotation: number = 0;\r\n\r\n  private _angularVelocity: number = 0;\r\n\r\n  /**\r\n   * Get or set the camera's angular velocity\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this._angularVelocity;\r\n  }\r\n\r\n  public set angularVelocity(value: number) {\r\n    this._angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's position\r\n   */\r\n  private _posChanged = false;\r\n  private _pos: Vector = watchAny(Vector.Zero, () => (this._posChanged = true));\r\n  public get pos(): Vector {\r\n    return this._pos;\r\n  }\r\n  public set pos(vec: Vector) {\r\n    this._pos = watchAny(vec, () => (this._posChanged = true));\r\n    this._posChanged = true;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's velocity\r\n   */\r\n  public vel: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * Get or set the camera's acceleration\r\n   */\r\n  public acc: Vector = Vector.Zero;\r\n\r\n  private _cameraMoving: boolean = false;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1000; // 1 second\r\n  private _lerpStart: Vector = null;\r\n  private _lerpEnd: Vector = null;\r\n  private _lerpResolve: (value: Vector) => void;\r\n  private _lerpPromise: Promise<Vector>;\r\n\r\n  //camera effects\r\n  protected _isShaking: boolean = false;\r\n  private _shakeMagnitudeX: number = 0;\r\n  private _shakeMagnitudeY: number = 0;\r\n  private _shakeDuration: number = 0;\r\n  private _elapsedShakeTime: number = 0;\r\n  private _xShake: number = 0;\r\n  private _yShake: number = 0;\r\n\r\n  protected _isZooming: boolean = false;\r\n  private _zoomStart: number = 1;\r\n  private _zoomEnd: number = 1;\r\n  private _currentZoomTime: number = 0;\r\n  private _zoomDuration: number = 0;\r\n\r\n  private _zoomResolve: (val: boolean) => void;\r\n  private _zoomPromise: Promise<boolean>;\r\n  private _zoomEasing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n  private _easing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n\r\n  private _halfWidth: number = 0;\r\n  private _halfHeight: number = 0;\r\n\r\n  /**\r\n   * Get the camera's x position\r\n   */\r\n  public get x() {\r\n    return this.pos.x;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set x(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(value, this.pos.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the camera's y position\r\n   */\r\n  public get y() {\r\n    return this.pos.y;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set y(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(this.pos.x, value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x velocity\r\n   */\r\n  public get dx() {\r\n    return this.vel.x;\r\n  }\r\n\r\n  public set dx(value: number) {\r\n    this.vel = vec(value, this.vel.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y velocity\r\n   */\r\n  public get dy() {\r\n    return this.vel.y;\r\n  }\r\n\r\n  public set dy(value: number) {\r\n    this.vel = vec(this.vel.x, value);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x acceleration\r\n   */\r\n  public get ax() {\r\n    return this.acc.x;\r\n  }\r\n\r\n  public set ax(value: number) {\r\n    this.acc = vec(value, this.acc.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y acceleration\r\n   */\r\n  public get ay() {\r\n    return this.acc.y;\r\n  }\r\n\r\n  public set ay(value: number) {\r\n    this.acc = vec(this.acc.x, value);\r\n  }\r\n\r\n  /**\r\n   * Returns the focal point of the camera, a new point giving the x and y position of the camera\r\n   */\r\n  public getFocus() {\r\n    return this.pos;\r\n  }\r\n\r\n  /**\r\n   * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.\r\n   *\r\n   * @param pos The target position to move to\r\n   * @param duration The duration in milliseconds the move should last\r\n   * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)\r\n   * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.\r\n   *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.\r\n   */\r\n  public move(pos: Vector, duration: number, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<Vector> {\r\n    if (typeof easingFn !== 'function') {\r\n      throw 'Please specify an EasingFunction';\r\n    }\r\n\r\n    // cannot move when following an actor\r\n    if (this._follow) {\r\n      return Promise.reject(pos);\r\n    }\r\n\r\n    // resolve existing promise, if any\r\n    if (this._lerpPromise && this._lerpResolve) {\r\n      this._lerpResolve(pos);\r\n    }\r\n\r\n    this._lerpPromise = new Promise<Vector>((resolve) => {\r\n      this._lerpResolve = resolve;\r\n    });\r\n    this._lerpStart = this.getFocus().clone();\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = pos;\r\n    this._currentLerpTime = 0;\r\n    this._cameraMoving = true;\r\n    this._easing = easingFn;\r\n\r\n    return this._lerpPromise;\r\n  }\r\n\r\n  /**\r\n   * Sets the camera to shake at the specified magnitudes for the specified duration\r\n   * @param magnitudeX  The x magnitude of the shake\r\n   * @param magnitudeY  The y magnitude of the shake\r\n   * @param duration    The duration of the shake in milliseconds\r\n   */\r\n  public shake(magnitudeX: number, magnitudeY: number, duration: number) {\r\n    this._isShaking = true;\r\n    this._shakeMagnitudeX = magnitudeX;\r\n    this._shakeMagnitudeY = magnitudeY;\r\n    this._shakeDuration = duration;\r\n  }\r\n\r\n  /**\r\n   * Zooms the camera in or out by the specified scale over the specified duration.\r\n   * If no duration is specified, it take effect immediately.\r\n   * @param scale    The scale of the zoom\r\n   * @param duration The duration of the zoom in milliseconds\r\n   */\r\n  public zoomOverTime(scale: number, duration: number = 0, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<boolean> {\r\n    this._zoomPromise = new Promise<boolean>((resolve) => {\r\n      this._zoomResolve = resolve;\r\n    });\r\n\r\n    if (duration) {\r\n      this._isZooming = true;\r\n      this._zoomEasing = easingFn;\r\n      this._currentZoomTime = 0;\r\n      this._zoomDuration = duration;\r\n      this._zoomStart = this.zoom;\r\n      this._zoomEnd = scale;\r\n    } else {\r\n      this._isZooming = false;\r\n      this.zoom = scale;\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    return this._zoomPromise;\r\n  }\r\n\r\n  private _viewport: BoundingBox = null;\r\n  /**\r\n   * Gets the bounding box of the viewport of this camera in world coordinates\r\n   */\r\n  public get viewport(): BoundingBox {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n\r\n    return new BoundingBox(0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Adds a new camera strategy to this camera\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public addStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    this._cameraStrategies.push(cameraStrategy);\r\n  }\r\n\r\n  /**\r\n   * Removes a camera strategy by reference\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public removeStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    removeItemFromArray(cameraStrategy, this._cameraStrategies);\r\n  }\r\n\r\n  /**\r\n   * Clears all camera strategies from the camera\r\n   */\r\n  public clearAllStrategies() {\r\n    this._cameraStrategies.length = 0;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  private _engine: Engine;\r\n  private _screen: Screen;\r\n  private _isInitialized = false;\r\n  public get isInitialized() {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  public _initialize(_engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this._engine = _engine;\r\n      this._screen = _engine.screen;\r\n\r\n      const currentRes = this._screen.resolution;\r\n      let center = vec(currentRes.width / 2, currentRes.height / 2);\r\n      if (!this._engine.loadingComplete) {\r\n        // If there was a loading screen, we peek the configured resolution\r\n        const res = this._screen.peekResolution();\r\n        if (res) {\r\n          center = vec(res.width / 2, res.height / 2);\r\n        }\r\n      }\r\n      this._halfWidth = center.x;\r\n      this._halfHeight = center.y;\r\n\r\n      // If the user has not set the camera pos, apply default center screen position\r\n      if (!this._posChanged) {\r\n        this.pos = center;\r\n      }\r\n      // First frame bootstrap\r\n\r\n      // Ensure camera tx is correct\r\n      // Run update twice to ensure properties are init'd\r\n      this.updateTransform();\r\n\r\n      // Run strategies for first frame\r\n      this.runStrategies(_engine, _engine.clock.elapsed());\r\n\r\n      // Setup the first frame viewport\r\n      this.updateViewport();\r\n\r\n      // It's important to update the camera after strategies\r\n      // This prevents jitter\r\n      this.updateTransform();\r\n\r\n      this.onInitialize(_engine);\r\n      super.emit('initialize', new InitializeEvent(_engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onInitialize(_engine: Engine) {\r\n    // Overridable\r\n  }\r\n\r\n  public on(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public on(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public on(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public on(eventName: any, handler: any) {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: 'initialize', handler?: (event: InitializeEvent) => void): void;\r\n  public off(eventName: 'preupdate', handler?: (event: PreUpdateEvent) => void): void;\r\n  public off(eventName: 'postupdate', handler?: (event: PostUpdateEvent) => void): void;\r\n  public off(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public off(eventName: string, handler: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public once(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public once(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public runStrategies(engine: Engine, delta: number) {\r\n    for (const s of this._cameraStrategies) {\r\n      this.pos = s.action.call(s, s.target, this, engine, delta);\r\n    }\r\n  }\r\n\r\n  public updateViewport() {\r\n    // recalc viewport\r\n    this._viewport = new BoundingBox(\r\n      this.x - this._halfWidth,\r\n      this.y - this._halfHeight,\r\n      this.x + this._halfWidth,\r\n      this.y + this._halfHeight\r\n    );\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this._initialize(_engine);\r\n    this._preupdate(_engine, delta);\r\n\r\n    // Update placements based on linear algebra\r\n    this.pos = this.pos.add(this.vel.scale(delta / 1000));\r\n    this.zoom += (this.dz * delta) / 1000;\r\n\r\n    this.vel = this.vel.add(this.acc.scale(delta / 1000));\r\n    this.dz += (this.az * delta) / 1000;\r\n\r\n    this.rotation += (this.angularVelocity * delta) / 1000;\r\n\r\n    if (this._isZooming) {\r\n      if (this._currentZoomTime < this._zoomDuration) {\r\n        const zoomEasing = this._zoomEasing;\r\n        const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);\r\n\r\n        this.zoom = newZoom;\r\n        this._currentZoomTime += delta;\r\n      } else {\r\n        this._isZooming = false;\r\n        this.zoom = this._zoomEnd;\r\n        this._currentZoomTime = 0;\r\n        this._zoomResolve(true);\r\n      }\r\n    }\r\n\r\n    if (this._cameraMoving) {\r\n      if (this._currentLerpTime < this._lerpDuration) {\r\n        const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);\r\n\r\n        const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);\r\n\r\n        this.pos = lerpPoint;\r\n\r\n        this._currentLerpTime += delta;\r\n      } else {\r\n        this.pos = this._lerpEnd;\r\n        const end = this._lerpEnd.clone();\r\n\r\n        this._lerpStart = null;\r\n        this._lerpEnd = null;\r\n        this._currentLerpTime = 0;\r\n        this._cameraMoving = false;\r\n        // Order matters here, resolve should be last so any chain promises have a clean slate\r\n        this._lerpResolve(end);\r\n      }\r\n    }\r\n\r\n    if (this._isDoneShaking()) {\r\n      this._isShaking = false;\r\n      this._elapsedShakeTime = 0;\r\n      this._shakeMagnitudeX = 0;\r\n      this._shakeMagnitudeY = 0;\r\n      this._shakeDuration = 0;\r\n      this._xShake = 0;\r\n      this._yShake = 0;\r\n    } else {\r\n      this._elapsedShakeTime += delta;\r\n      this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;\r\n      this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;\r\n    }\r\n\r\n    this.runStrategies(_engine, delta);\r\n\r\n    this.updateViewport();\r\n\r\n    // It's important to update the camera after strategies\r\n    // This prevents jitter\r\n    this.updateTransform();\r\n\r\n    this._postupdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Applies the relevant transformations to the game canvas to \"move\" or apply effects to the Camera\r\n   * @param ctx Canvas context to apply transformations\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext): void {\r\n    ctx.multiply(this.transform);\r\n  }\r\n\r\n  public updateTransform() {\r\n    // center the camera\r\n    const newCanvasWidth = this._screen.resolution.width / this.zoom;\r\n    const newCanvasHeight = this._screen.resolution.height / this.zoom;\r\n    const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);\r\n\r\n    // Calculate camera transform\r\n    this.transform.reset();\r\n    this.transform.scale(this.zoom, this.zoom);\r\n    this.transform.translate(cameraPos.x, cameraPos.y);\r\n    this.transform.inverse(this.inverse);\r\n  }\r\n\r\n  private _isDoneShaking(): boolean {\r\n    return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;\r\n  }\r\n}\r\n","import { Engine } from './Engine';\r\nimport { EventDispatcher } from './EventDispatcher';\r\nimport { Vector } from './Math/vector';\r\nimport { ExitTriggerEvent, EnterTriggerEvent, CollisionEndEvent, CollisionStartEvent } from './Events';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { Entity } from './EntityComponentSystem';\r\nimport { Actor } from './Actor';\r\n\r\n/**\r\n * ITriggerOptions\r\n */\r\nexport interface TriggerOptions {\r\n  // position of the trigger\r\n  pos: Vector;\r\n  // width of the trigger\r\n  width: number;\r\n  // height of the trigger\r\n  height: number;\r\n  // whether the trigger is visible or not\r\n  visible: boolean;\r\n  // action to take when triggered\r\n  action: () => void;\r\n  // if specified the trigger will only fire on a specific actor and overrides any filter\r\n  target: Entity;\r\n  // Returns true if the triggers should fire on the collided actor\r\n  filter: (actor: Entity) => boolean;\r\n  // -1 if it should repeat forever\r\n  repeat: number;\r\n}\r\n\r\nconst triggerDefaults: Partial<TriggerOptions> = {\r\n  pos: Vector.Zero,\r\n  width: 10,\r\n  height: 10,\r\n  visible: false,\r\n  action: () => {\r\n    return;\r\n  },\r\n  filter: () => true,\r\n  repeat: -1\r\n};\r\n\r\n/**\r\n * Triggers are a method of firing arbitrary code on collision. These are useful\r\n * as 'buttons', 'switches', or to trigger effects in a game. By default triggers\r\n * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.\r\n */\r\nexport class Trigger extends Actor {\r\n  private _target: Entity;\r\n  /**\r\n   * Action to fire when triggered by collision\r\n   */\r\n  public action: () => void = () => {\r\n    return;\r\n  };\r\n  /**\r\n   * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when\r\n   * filter return true for the collided actor.\r\n   */\r\n  public filter: (actor: Entity) => boolean = () => true;\r\n  /**\r\n   * Number of times to repeat before killing the trigger,\r\n   */\r\n  public repeat: number = -1;\r\n\r\n  /**\r\n   *\r\n   * @param opts Trigger options\r\n   */\r\n  constructor(opts: Partial<TriggerOptions>) {\r\n    super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });\r\n    opts = {\r\n      ...triggerDefaults,\r\n      ...opts\r\n    };\r\n\r\n    this.filter = opts.filter || this.filter;\r\n    this.repeat = opts.repeat || this.repeat;\r\n    this.action = opts.action || this.action;\r\n    if (opts.target) {\r\n      this.target = opts.target;\r\n    }\r\n\r\n    this.graphics.visible = opts.visible;\r\n    this.body.collisionType = CollisionType.Passive;\r\n    this.eventDispatcher = new EventDispatcher();\r\n\r\n    this.events.on('collisionstart', (evt: CollisionStartEvent<Actor>) => {\r\n      if (this.filter(evt.other)) {\r\n        this.emit('enter', new EnterTriggerEvent(this, evt.other));\r\n        this._dispatchAction();\r\n        // remove trigger if its done, -1 repeat forever\r\n        if (this.repeat === 0) {\r\n          this.kill();\r\n        }\r\n      }\r\n    });\r\n\r\n    this.events.on('collisionend', (evt: CollisionEndEvent<Actor>) => {\r\n      if (this.filter(evt.other)) {\r\n        this.emit('exit', new ExitTriggerEvent(this, evt.other));\r\n      }\r\n    });\r\n  }\r\n\r\n  public set target(target: Entity) {\r\n    this._target = target;\r\n    this.filter = (actor: Entity) => actor === target;\r\n  }\r\n\r\n  public get target() {\r\n    return this._target;\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n  private _dispatchAction() {\r\n    if (this.repeat !== 0) {\r\n      this.action.call(this);\r\n      this.repeat--;\r\n    }\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { Message, Observer } from '../Util/Observable';\r\nimport { Component } from './Component';\r\nimport { Scene } from '../Scene';\r\n\r\n/**\r\n * Enum that determines whether to run the system in the update or draw phase\r\n */\r\nexport enum SystemType {\r\n  Update = 'update',\r\n  Draw = 'draw'\r\n}\r\n\r\nexport type SystemTypes<ComponentTypes> = ComponentTypes extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * An Excalibur [[System]] that updates entities of certain types.\r\n * Systems are scene specific\r\n *\r\n * Excalibur Systems currently require at least 1 Component type to operated\r\n *\r\n * Multiple types are declared as a type union\r\n * For example:\r\n *\r\n * ```typescript\r\n * class MySystem extends System<ComponentA | ComponentB> {\r\n *   public readonly types = ['a', 'b'] as const;\r\n *   public readonly systemType = SystemType.Update;\r\n *   public update(entities: Entity<ComponentA | ComponentB>) {\r\n *      ...\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport abstract class System<ComponentTypeUnion extends Component = Component, ContextType = Scene>\r\nimplements Observer<AddedEntity | RemovedEntity> {\r\n  /**\r\n   * The types of entities that this system operates on\r\n   * For example ['transform', 'motion']\r\n   */\r\n  abstract readonly types: readonly SystemTypes<ComponentTypeUnion>[];\r\n\r\n  /**\r\n   * Determine whether the system is called in the [[SystemType.Update]] or the [[SystemType.Draw]] phase. Update is first, then Draw.\r\n   */\r\n  abstract readonly systemType: SystemType;\r\n\r\n  /**\r\n   * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.\r\n   * For a system to execute before all other a lower priority value (-1 for example) must be set.\r\n   * For a system to execute after all other a higher priority value (10 for example) must be set.\r\n   */\r\n  public priority: number = 0;\r\n\r\n  /**\r\n   * Optionally specify a sort order for entities passed to the your system\r\n   * @param a The left entity\r\n   * @param b The right entity\r\n   */\r\n  sort?(a: Entity, b: Entity): number;\r\n\r\n  /**\r\n   * Optionally specify an initialize handler\r\n   * @param scene\r\n   */\r\n  initialize?(engine: ContextType): void;\r\n\r\n  /**\r\n   * Update all entities that match this system's types\r\n   * @param entities Entities to update that match this system's types\r\n   * @param delta Time in milliseconds\r\n   */\r\n  abstract update(entities: Entity[], delta: number): void;\r\n\r\n  /**\r\n   * Optionally run a preupdate before the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  preupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Optionally run a postupdate after the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  postupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Systems observe when entities match their types or no longer match their types, override\r\n   * @param _entityAddedOrRemoved\r\n   */\r\n  public notify(_entityAddedOrRemoved: AddedEntity | RemovedEntity) {\r\n    // Override me\r\n  }\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.\r\n */\r\nexport class AddedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Added' = 'Entity Added';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * Type guard to check for AddedEntity messages\r\n * @param x\r\n */\r\nexport function isAddedSystemEntity(x: Message<Entity>): x is AddedEntity {\r\n  return !!x && x.type === 'Entity Added';\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.\r\n */\r\nexport class RemovedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Removed' = 'Entity Removed';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * type guard to check for the RemovedEntity message\r\n */\r\nexport function isRemoveSystemEntity(x: Message<Entity>): x is RemovedEntity {\r\n  return !!x && x.type === 'Entity Removed';\r\n}\r\n","import { Entity, RemovedComponent, AddedComponent, isAddedComponent, isRemovedComponent } from './Entity';\r\nimport { Observer } from '../Util/Observable';\r\nimport { World } from './World';\r\nimport { Util } from '..';\r\n\r\n// Add/Remove entities and components\r\n\r\nexport class EntityManager<ContextType = any> implements Observer<RemovedComponent | AddedComponent> {\r\n  public entities: Entity[] = [];\r\n  public _entityIndex: { [entityId: string]: Entity } = {};\r\n\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Runs the entity lifecycle\r\n   * @param _context\r\n   */\r\n  public updateEntities(_context: ContextType, elapsed: number) {\r\n    for (const entity of this.entities) {\r\n      // TODO is this right?\r\n      entity.update((_context as any).engine, elapsed);\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  public findEntitiesForRemoval() {\r\n    for (const entity of this.entities) {\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EntityManager observes changes on entities\r\n   * @param message\r\n   */\r\n  public notify(message: RemovedComponent | AddedComponent): void {\r\n    if (isAddedComponent(message)) {\r\n      // we don't need the component, it's already on the entity\r\n      this._world.queryManager.addEntity(message.data.entity);\r\n    }\r\n\r\n    if (isRemovedComponent(message)) {\r\n      this._world.queryManager.removeComponent(message.data.entity, message.data.component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be tracked by the EntityManager\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    entity.active = true;\r\n    if (entity && !this._entityIndex[entity.id]) {\r\n      this._entityIndex[entity.id] = entity;\r\n      this.entities.push(entity);\r\n      this._world.queryManager.addEntity(entity);\r\n      entity.componentAdded$.register(this);\r\n      entity.componentRemoved$.register(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.addEntity(c));\r\n      entity.childrenAdded$.register({\r\n        notify: (e) => {\r\n          this.addEntity(e);\r\n        }\r\n      });\r\n      entity.childrenRemoved$.register({\r\n        notify: (e) => {\r\n          this.removeEntity(e, false);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  public removeEntity(entity: Entity, deferred?: boolean): void;\r\n  public removeEntity(id: number, deferred?: boolean): void;\r\n  public removeEntity(idOrEntity: number | Entity, deferred = true): void {\r\n    let id = 0;\r\n    if (idOrEntity instanceof Entity) {\r\n      id = idOrEntity.id;\r\n    } else {\r\n      id = idOrEntity;\r\n    }\r\n    const entity = this._entityIndex[id];\r\n    if (entity && entity.active) {\r\n      entity.kill();\r\n    }\r\n\r\n    if (entity && deferred) {\r\n      this._entitiesToRemove.push(entity);\r\n      return;\r\n    }\r\n\r\n    delete this._entityIndex[id];\r\n    if (entity) {\r\n      Util.removeItemFromArray(entity, this.entities);\r\n      this._world.queryManager.removeEntity(entity);\r\n      entity.componentAdded$.unregister(this);\r\n      entity.componentRemoved$.unregister(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.removeEntity(c, deferred));\r\n      entity.childrenAdded$.clear();\r\n      entity.childrenRemoved$.clear();\r\n\r\n      // stats\r\n      if ((this._world.context as any)?.engine) {\r\n        (this._world.context as any).engine.stats.currFrame.actors.killed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _entitiesToRemove: Entity[] = [];\r\n  public processEntityRemovals(): void {\r\n    for (const entity of this._entitiesToRemove) {\r\n      if (entity.active) {\r\n        continue;\r\n      }\r\n      this.removeEntity(entity, false);\r\n    }\r\n  }\r\n\r\n  public processComponentRemovals(): void {\r\n    for (const entity of this.entities) {\r\n      entity.processComponentRemoval();\r\n    }\r\n  }\r\n\r\n  public getById(id: number): Entity {\r\n    return this._entityIndex[id];\r\n  }\r\n\r\n  public getByName(name: string): Entity[]{\r\n    return this.entities.filter(e => e.name === name);\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const entity of this.entities) {\r\n      this.removeEntity(entity);\r\n    }\r\n  }\r\n}\r\n","export const buildTypeKey = (types: readonly string[]) => {\r\n  const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');\r\n  return key;\r\n};\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Observable } from '../Util/Observable';\r\nimport { Util, Component, ComponentCtor } from '..';\r\nimport { AddedEntity, RemovedEntity } from './System';\r\n\r\n/**\r\n * Represents query for entities that match a list of types that is cached and observable\r\n *\r\n * Queries can be strongly typed by supplying a type union in the optional type parameter\r\n * ```typescript\r\n * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);\r\n * ```\r\n */\r\nexport class Query<T extends Component = Component> extends Observable<AddedEntity | RemovedEntity> {\r\n  public types: readonly string[];\r\n  private _entities: Entity[] = [];\r\n  private _key: string;\r\n  public get key(): string {\r\n    if (this._key) {\r\n      return this._key;\r\n    }\r\n    return (this._key = buildTypeKey(this.types));\r\n  }\r\n\r\n  constructor(types: readonly string[]);\r\n  constructor(types: readonly ComponentCtor<T>[]);\r\n  constructor(types: readonly string[] | readonly ComponentCtor<T>[]) {\r\n    super();\r\n    if (types[0] instanceof Function) {\r\n      this.types = (types as ComponentCtor<T>[]).map(T =>  (new T).type);\r\n    } else {\r\n      this.types = types as string[];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a list of entities that match the query\r\n   *\r\n   * @param sort Optional sorting function to sort entities returned from the query\r\n   */\r\n  public getEntities(sort?: (a: Entity, b: Entity) => number): Entity[] {\r\n    if (sort) {\r\n      this._entities.sort(sort);\r\n    }\r\n    return this._entities;\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the query, will only be added if the entity matches the query types\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    if (!Util.contains(this._entities, entity) && this.matches(entity)) {\r\n      this._entities.push(entity);\r\n      this.notifyAll(new AddedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the entity is part of the query it will be removed regardless of types\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity): void {\r\n    if (Util.removeItemFromArray(entity, this._entities)) {\r\n      this.notifyAll(new RemovedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all entities and observers from the query\r\n   */\r\n  public clear(): void {\r\n    this._entities.length = 0;\r\n    for (const observer of this.observers) {\r\n      this.unregister(observer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns whether the entity's types match query\r\n   * @param entity\r\n   */\r\n  public matches(entity: Entity): boolean;\r\n\r\n  /**\r\n   * Returns whether the list of ComponentTypes have at least the same types as the query\r\n   * @param types\r\n   */\r\n  public matches(types: string[]): boolean;\r\n  public matches(typesOrEntity: string[] | Entity): boolean {\r\n    let types: string[] = [];\r\n    if (typesOrEntity instanceof Entity) {\r\n      types = typesOrEntity.types;\r\n    } else {\r\n      types = typesOrEntity;\r\n    }\r\n\r\n    let matches = true;\r\n    for (const type of this.types) {\r\n      matches = matches && types.indexOf(type) > -1;\r\n      if (!matches) {\r\n        return false;\r\n      }\r\n    }\r\n    return matches;\r\n  }\r\n\r\n  public contain(type: string) {\r\n    return this.types.indexOf(type) > -1;\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Query } from './Query';\r\nimport { Component } from './Component';\r\nimport { World } from './World';\r\n\r\n/**\r\n * The query manager is responsible for updating all queries when entities/components change\r\n */\r\nexport class QueryManager {\r\n  private _queries: { [entityComponentKey: string]: Query<any> } = {};\r\n\r\n  constructor(private _world: World<any>) {}\r\n\r\n  /**\r\n   * Adds a query to the manager and populates with any entities that match\r\n   * @param query\r\n   */\r\n  private _addQuery(query: Query<any>) {\r\n    this._queries[buildTypeKey(query.types)] = query;\r\n    for (const entity of this._world.entityManager.entities) {\r\n      query.addEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the query if there are no observers left\r\n   * @param query\r\n   */\r\n  public maybeRemoveQuery(query: Query): void {\r\n    if (query.observers.length === 0) {\r\n      query.clear();\r\n      delete this._queries[buildTypeKey(query.types)];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds the entity to any matching query in the query manage\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      if (this._queries[queryType]) {\r\n        this._queries[queryType].addEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from queries if the removed component disqualifies it\r\n   * @param entity\r\n   * @param component\r\n   */\r\n  public removeComponent(entity: Entity, component: Component) {\r\n    for (const queryType in this._queries) {\r\n      // If the component being removed from an entity is a part of a query,\r\n      // it is now disqualified from that query, remove it\r\n      if (this._queries[queryType].contain(component.type)) {\r\n        this._queries[queryType].removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from all queries it is currently a part of\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      this._queries[queryType].removeEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance\r\n   * @param types\r\n   */\r\n  public createQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const maybeExistingQuery = this.getQuery<T>(types);\r\n    if (maybeExistingQuery) {\r\n      return maybeExistingQuery;\r\n    }\r\n    const query = new Query<T>(types);\r\n    this._addQuery(query);\r\n    return query;\r\n  }\r\n\r\n  /**\r\n   * Retrieves an existing query by types if it exists otherwise returns null\r\n   * @param types\r\n   */\r\n  public getQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const key = buildTypeKey(types);\r\n    if (this._queries[key]) {\r\n      return this._queries[key] as Query<T>;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n","import { System, SystemType } from './System';\r\nimport { Scene, Util } from '..';\r\nimport { World } from './World';\r\n\r\nexport interface SystemCtor<T extends System> {\r\n  new (): T;\r\n}\r\n\r\n/**\r\n * The SystemManager is responsible for keeping track of all systems in a scene.\r\n * Systems are scene specific\r\n */\r\nexport class SystemManager<ContextType> {\r\n  /**\r\n   * List of systems, to add a new system call [[SystemManager.addSystem]]\r\n   */\r\n  public systems: System<any, ContextType>[] = [];\r\n  public _keyToSystem: { [key: string]: System<any, ContextType> };\r\n  public initialized = false;\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Get a system registered in the manager by type\r\n   * @param systemType\r\n   */\r\n  public get<T extends System>(systemType: SystemCtor<T>): T | null {\r\n    return this.systems.find((s) => s instanceof systemType) as unknown as T;\r\n  }\r\n\r\n  /**\r\n   * Adds a system to the manager, it will now be updated every frame\r\n   * @param system\r\n   */\r\n  public addSystem(system: System<any, ContextType>): void {\r\n    // validate system has types\r\n    if (!system.types || system.types.length === 0) {\r\n      throw new Error(`Attempted to add a System without any types`);\r\n    }\r\n\r\n    const query = this._world.queryManager.createQuery(system.types);\r\n    this.systems.push(system);\r\n    this.systems.sort((a, b) => a.priority - b.priority);\r\n    query.register(system);\r\n    if (this.initialized && system.initialize) {\r\n      system.initialize(this._world.context);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a system from the manager, it will no longer be updated\r\n   * @param system\r\n   */\r\n  public removeSystem(system: System<any, ContextType>) {\r\n    Util.removeItemFromArray(system, this.systems);\r\n    const query = this._world.queryManager.getQuery(system.types);\r\n    if (query) {\r\n      query.unregister(system);\r\n      this._world.queryManager.maybeRemoveQuery(query);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize all systems in the manager\r\n   *\r\n   * Systems added after initialize() will be initialized on add\r\n   */\r\n  public initialize() {\r\n    if (!this.initialized) {\r\n      this.initialized = true;\r\n      for (const s of this.systems) {\r\n        if (s.initialize) {\r\n          s.initialize(this._world.context);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates all systems\r\n   * @param type whether this is an update or draw system\r\n   * @param context context reference\r\n   * @param delta time in milliseconds\r\n   */\r\n  public updateSystems(type: SystemType, context: ContextType, delta: number) {\r\n    const systems = this.systems.filter((s) => s.systemType === type);\r\n    for (const s of systems) {\r\n      if (s.preupdate) {\r\n        s.preupdate(context, delta);\r\n      }\r\n    }\r\n\r\n    for (const s of systems) {\r\n      // Get entities that match the system types, pre-sort\r\n      const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);\r\n      // Initialize entities if needed\r\n      if (context instanceof Scene) {\r\n        for (const entity of entities) {\r\n          entity._initialize(context?.engine);\r\n        }\r\n      }\r\n      s.update(entities, delta);\r\n    }\r\n\r\n    for (const s of systems) {\r\n      if (s.postupdate) {\r\n        s.postupdate(context, delta);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const system of this.systems) {\r\n      this.removeSystem(system);\r\n    }\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { EntityManager } from './EntityManager';\r\nimport { QueryManager } from './QueryManager';\r\nimport { System, SystemType } from './System';\r\nimport { SystemManager } from './SystemManager';\r\n\r\n/**\r\n * The World is a self-contained entity component system for a particular context.\r\n */\r\nexport class World<ContextType> {\r\n  public queryManager: QueryManager = new QueryManager(this);\r\n  public entityManager: EntityManager<ContextType> = new EntityManager<ContextType>(this);\r\n  public systemManager: SystemManager<ContextType> = new SystemManager<ContextType>(this);\r\n\r\n  /**\r\n   * The context type is passed to the system updates\r\n   * @param context\r\n   */\r\n  constructor(public context: ContextType) {}\r\n\r\n  /**\r\n   * Update systems by type and time elapsed in milliseconds\r\n   */\r\n  update(type: SystemType, delta: number) {\r\n    if (type === SystemType.Update) {\r\n      this.entityManager.updateEntities(this.context, delta);\r\n    }\r\n    this.systemManager.updateSystems(type, this.context, delta);\r\n    this.entityManager.findEntitiesForRemoval();\r\n    this.entityManager.processComponentRemovals();\r\n    this.entityManager.processEntityRemovals();\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the ECS world\r\n   * @param entity\r\n   */\r\n  add(entity: Entity): void;\r\n  /**\r\n   * Add a system to the ECS world\r\n   * @param system\r\n   */\r\n  add(system: System<any, ContextType>): void;\r\n  add(entityOrSystem: Entity | System<any, ContextType>): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.addEntity(entityOrSystem);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.addSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from the ECS world\r\n   * @param entity\r\n   */\r\n  remove(entity: Entity, deferred?: boolean): void;\r\n  /**\r\n   * Remove a system from the ECS world\r\n   * @param system\r\n   */\r\n  remove(system: System<any, ContextType>): void;\r\n  remove(entityOrSystem: Entity | System<any, ContextType>, deferred = true): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.removeEntity(entityOrSystem, deferred);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.removeSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  clearEntities(): void {\r\n    this.entityManager.clear();\r\n  }\r\n\r\n  clearSystems(): void {\r\n    this.systemManager.clear();\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\n\r\nexport class EulerIntegrator {\r\n  // Scratch vectors to avoid allocation\r\n  private static _POS = new Vector(0, 0);\r\n  private static _SCALE = new Vector(1, 1);\r\n\r\n  private static _ACC = new Vector(0, 0);\r\n  private static _VEL = new Vector(0, 0);\r\n  private static _VEL_ACC = new Vector(0, 0);\r\n  private static _SCALE_FACTOR = new Vector(0, 0);\r\n\r\n  static integrate(transform: TransformComponent, motion: MotionComponent, totalAcc: Vector, elapsedMs: number): void {\r\n    const seconds = elapsedMs / 1000;\r\n    // This code looks a little wild, but it's to avoid creating any new Vector instances\r\n    // integration is done in a tight loop so this is key to avoid GC'ing\r\n    motion.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));\r\n    transform.pos\r\n      .add(motion.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS)\r\n      .addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));\r\n\r\n    motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;\r\n    const rotation = transform.rotation + motion.angularVelocity * seconds;\r\n\r\n    transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);\r\n    const tx = transform.get();\r\n    tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { Physics } from './Physics';\r\nimport { BodyComponent } from './BodyComponent';\r\nimport { CollisionType } from './CollisionType';\r\nimport { EulerIntegrator } from './Integrator';\r\n\r\nexport class MotionSystem extends System<TransformComponent | MotionComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  update(entities: Entity[], elapsedMs: number): void {\r\n    let transform: TransformComponent;\r\n    let motion: MotionComponent;\r\n    for (let i = 0; i < entities.length; i++) {\r\n      transform = entities[i].get(TransformComponent);\r\n      motion = entities[i].get(MotionComponent);\r\n\r\n      const optionalBody = entities[i].get(BodyComponent);\r\n      if (optionalBody?.sleeping) {\r\n        continue;\r\n      }\r\n\r\n      const totalAcc = motion.acc.clone();\r\n      if (optionalBody?.collisionType === CollisionType.Active && optionalBody?.useGravity) {\r\n        totalAcc.addEqual(Physics.gravity);\r\n      }\r\n      optionalBody?.captureOldTransform();\r\n\r\n      // Update transform and motion based on Euler linear algebra\r\n      EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);\r\n    }\r\n  }\r\n}\r\n","import { PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Side } from '../Side';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent } from '../BodyComponent';\r\n\r\n/**\r\n * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,\r\n * and negates velocity along the collision normal.\r\n *\r\n * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.\r\n *\r\n */\r\nexport class ArcadeSolver implements CollisionSolver {\r\n  directionMap = new Map<string, string>();\r\n  distanceMap = new Map<string, number>();\r\n\r\n  public solve(contacts: CollisionContact[]): CollisionContact[] {\r\n    // Events and init\r\n    this.preSolve(contacts);\r\n\r\n    // Remove any canceled contacts\r\n    contacts = contacts.filter(c => !c.isCanceled());\r\n\r\n    // Sort contacts by distance to avoid artifacts with seams\r\n    // It's important to solve in a specific order\r\n    contacts.sort((a, b) => {\r\n      const aDist = this.distanceMap.get(a.id);\r\n      const bDist = this.distanceMap.get(b.id);\r\n      return aDist - bDist;\r\n    });\r\n\r\n    for (const contact of contacts) {\r\n      // Solve position first in arcade\r\n      this.solvePosition(contact);\r\n\r\n      // Solve velocity second in arcade\r\n      this.solveVelocity(contact);\r\n    }\r\n\r\n    // Events and any contact house-keeping the solver needs\r\n    this.postSolve(contacts);\r\n\r\n    return contacts;\r\n  }\r\n\r\n  public preSolve(contacts: CollisionContact[]) {\r\n\r\n    for (const contact of contacts) {\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n\r\n      const distance = contact.colliderA.worldPos.squareDistance(contact.colliderB.worldPos);\r\n      this.distanceMap.set(contact.id, distance);\r\n\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      if (contact.isCanceled()) {\r\n        continue;\r\n      }\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public solvePosition(contact: CollisionContact) {\r\n    const epsilon = .0001;\r\n    // if bounds no longer intersect skip to the next\r\n    // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles\r\n    if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {\r\n      // Cancel the contact to prevent and solving\r\n      contact.cancel();\r\n      return;\r\n    }\r\n\r\n    if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {\r\n      // Cancel near 0 mtv collisions\r\n      contact.cancel();\r\n      return;\r\n    }\r\n\r\n    let mtv = contact.mtv;\r\n    const colliderA = contact.colliderA;\r\n    const colliderB = contact.colliderB;\r\n    const bodyA = colliderA.owner?.get(BodyComponent);\r\n    const bodyB = colliderB.owner?.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n        return;\r\n      }\r\n\r\n      if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {\r\n        // split overlaps if both are Active\r\n        mtv = mtv.scale(0.5);\r\n      }\r\n\r\n      // Resolve overlaps\r\n      if (bodyA.collisionType === CollisionType.Active) {\r\n        bodyA.globalPos.x -= mtv.x;\r\n        bodyA.globalPos.y -= mtv.y;\r\n        colliderA.update(bodyA.transform.get());\r\n      }\r\n\r\n      if (bodyB.collisionType === CollisionType.Active) {\r\n        bodyB.globalPos.x += mtv.x;\r\n        bodyB.globalPos.y += mtv.y;\r\n        colliderB.update(bodyB.transform.get());\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  public solveVelocity(contact: CollisionContact) {\r\n    if (contact.isCanceled()) {\r\n      return;\r\n    }\r\n\r\n    const colliderA = contact.colliderA;\r\n    const colliderB = contact.colliderB;\r\n    const bodyA = colliderA.owner?.get(BodyComponent);\r\n    const bodyB = colliderB.owner?.get(BodyComponent);\r\n\r\n    if (bodyA && bodyB) {\r\n\r\n      if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n        return;\r\n      }\r\n\r\n      const normal = contact.normal;\r\n      const opposite = normal.negate();\r\n\r\n      if (bodyA.collisionType === CollisionType.Active) {\r\n        // only adjust velocity if the contact normal is opposite to the current velocity\r\n        // this avoids catching edges on a platform when sliding off\r\n        if (bodyA.vel.normalize().dot(opposite) < 0) {\r\n          // Cancel out velocity opposite direction of collision normal\r\n          const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));\r\n          bodyA.vel = bodyA.vel.add(velAdj);\r\n        }\r\n      }\r\n\r\n      if (bodyB.collisionType === CollisionType.Active) {\r\n        // only adjust velocity if the contact normal is opposite to the current velocity\r\n        // this avoids catching edges on a platform\r\n        if (bodyB.vel.normalize().dot(normal) < 0) {\r\n          const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));\r\n          bodyB.vel = bodyB.vel.add(velAdj);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\n\r\n/**\r\n * Holds information about contact points, meant to be reused over multiple frames of contact\r\n */\r\nexport class ContactConstraintPoint {\r\n  constructor(public point: Vector, public local: Vector, public contact: CollisionContact) {\r\n    this.update();\r\n  }\r\n\r\n  /**\r\n   * Updates the contact information\r\n   */\r\n  update() {\r\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\r\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\r\n\r\n    if (bodyA && bodyB) {\r\n      const normal = this.contact.normal;\r\n      const tangent = this.contact.tangent;\r\n\r\n      this.aToContact = this.point.sub(bodyA.globalPos);\r\n      this.bToContact = this.point.sub(bodyB.globalPos);\r\n\r\n      const aToContactNormal = this.aToContact.cross(normal);\r\n      const bToContactNormal = this.bToContact.cross(normal);\r\n\r\n      this.normalMass =\r\n        bodyA.inverseMass +\r\n        bodyB.inverseMass +\r\n        bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n        bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n      const aToContactTangent = this.aToContact.cross(tangent);\r\n      const bToContactTangent = this.bToContact.cross(tangent);\r\n\r\n      this.tangentMass =\r\n        bodyA.inverseMass +\r\n        bodyB.inverseMass +\r\n        bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n        bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns the relative velocity between bodyA and bodyB\r\n   */\r\n  public getRelativeVelocity() {\r\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\r\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      // Relative velocity in linear terms\r\n      // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\r\n      const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));\r\n      const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));\r\n      return velB.sub(velA);\r\n    }\r\n    return Vector.Zero;\r\n  }\r\n\r\n  /**\r\n   * Impulse accumulated over time in normal direction\r\n   */\r\n  public normalImpulse: number = 0;\r\n\r\n  /**\r\n   * Impulse accumulated over time in the tangent direction\r\n   */\r\n  public tangentImpulse: number = 0;\r\n\r\n  /**\r\n   * Effective mass seen in the normal direction\r\n   */\r\n  public normalMass: number = 0;\r\n\r\n  /**\r\n   * Effective mass seen in the tangent direction\r\n   */\r\n  public tangentMass: number = 0;\r\n\r\n  /**\r\n   * Direction from center of mass of bodyA to contact point\r\n   */\r\n  public aToContact: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Direction from center of mass of bodyB to contact point\r\n   */\r\n  public bToContact: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Original contact velocity combined with bounciness\r\n   */\r\n  public originalVelocityAndRestitution: number = 0;\r\n}\r\n","import { CollisionPostSolveEvent, CollisionPreSolveEvent, PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { clamp } from '../../Math/util';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { ContactConstraintPoint } from './ContactConstraintPoint';\r\nimport { Side } from '../Side';\r\nimport { Physics } from '../Physics';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent, DegreeOfFreedom } from '../BodyComponent';\r\nimport { CollisionJumpTable } from '../Colliders/CollisionJumpTable';\r\n\r\nexport class RealisticSolver implements CollisionSolver {\r\n  lastFrameContacts: Map<string, CollisionContact> = new Map();\r\n\r\n  // map contact id to contact points\r\n  idToContactConstraint: Map<string, ContactConstraintPoint[]> = new Map();\r\n\r\n  getContactConstraints(id: string) {\r\n    return this.idToContactConstraint.get(id) ?? [];\r\n  }\r\n\r\n  public solve(contacts: CollisionContact[]): CollisionContact[] {\r\n    // Events and init\r\n    this.preSolve(contacts);\r\n\r\n    // Remove any canceled contacts\r\n    contacts = contacts.filter(c => !c.isCanceled());\r\n\r\n    // Solve velocity first\r\n    this.solveVelocity(contacts);\r\n\r\n    // Solve position last because non-overlap is the most important\r\n    this.solvePosition(contacts);\r\n\r\n    // Events and any contact house-keeping the solver needs\r\n    this.postSolve(contacts);\r\n\r\n    return contacts;\r\n  }\r\n\r\n  preSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n\r\n      // Match awake state for sleeping\r\n      contact.matchAwake();\r\n    }\r\n\r\n    // Keep track of contacts that done\r\n    const finishedContactIds = Array.from(this.idToContactConstraint.keys());\r\n    for (const contact of contacts) {\r\n      // Remove all current contacts that are not done\r\n      const index = finishedContactIds.indexOf(contact.id);\r\n      if (index > -1) {\r\n        finishedContactIds.splice(index, 1);\r\n      }\r\n      const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n      let pointIndex = 0;\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        for (const point of contact.points) {\r\n          const normal = contact.normal;\r\n          const tangent = contact.tangent;\r\n\r\n          const aToContact = point.sub(bodyA.globalPos);\r\n          const bToContact = point.sub(bodyB.globalPos);\r\n\r\n          const aToContactNormal = aToContact.cross(normal);\r\n          const bToContactNormal = bToContact.cross(normal);\r\n\r\n          const normalMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n            bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n          const aToContactTangent = aToContact.cross(tangent);\r\n          const bToContactTangent = bToContact.cross(tangent);\r\n\r\n          const tangentMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n            bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n\r\n          // Preserve normal/tangent impulse by re-using the contact point if it's close\r\n          if (contactPoints[pointIndex] && contactPoints[pointIndex]?.point?.squareDistance(point) < 4) {\r\n            contactPoints[pointIndex].point = point;\r\n            contactPoints[pointIndex].local = contact.localPoints[pointIndex];\r\n          } else {\r\n            // new contact if it's not close or doesn't exist\r\n            contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);\r\n          }\r\n\r\n          // Update contact point calculations\r\n          contactPoints[pointIndex].aToContact = aToContact;\r\n          contactPoints[pointIndex].bToContact = bToContact;\r\n          contactPoints[pointIndex].normalMass = 1.0 / normalMass;\r\n          contactPoints[pointIndex].tangentMass = 1.0 / tangentMass;\r\n\r\n          // Calculate relative velocity before solving to accurately do restitution\r\n          const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;\r\n          const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());\r\n          contactPoints[pointIndex].originalVelocityAndRestitution = 0;\r\n          if (relativeVelocity < -0.1) { // TODO what's a good threshold here?\r\n            contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;\r\n          }\r\n          pointIndex++;\r\n        }\r\n      }\r\n      this.idToContactConstraint.set(contact.id, contactPoints);\r\n    }\r\n\r\n    // Clean up any contacts that did not occur last frame\r\n    for (const id of finishedContactIds) {\r\n      this.idToContactConstraint.delete(id);\r\n    }\r\n\r\n    // Warm contacts with accumulated impulse\r\n    // Useful for tall stacks\r\n    if (Physics.warmStart) {\r\n      this.warmStart(contacts);\r\n    } else {\r\n      for (const contact of contacts) {\r\n        const contactPoints = this.getContactConstraints(contact.id);\r\n        for (const point of contactPoints) {\r\n          point.normalImpulse = 0;\r\n          point.tangentImpulse = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n\r\n      if (bodyA && bodyB) {\r\n        // Skip post solve for active+passive collisions\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        // Update motion values for sleeping\r\n        bodyA.updateMotion();\r\n        bodyB.updateMotion();\r\n      }\r\n\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n    }\r\n\r\n    // Store contacts\r\n    this.lastFrameContacts.clear();\r\n    for (const c of contacts) {\r\n      this.lastFrameContacts.set(c.id, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Warm up body's based on previous frame contact points\r\n   * @param contacts\r\n   */\r\n  warmStart(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n        for (const point of contactPoints) {\r\n          if (Physics.warmStart) {\r\n            const normalImpulse = contact.normal.scale(point.normalImpulse);\r\n            const tangentImpulse = contact.tangent.scale(point.tangentImpulse);\r\n            const impulse = normalImpulse.add(tangentImpulse);\r\n\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          } else {\r\n            point.normalImpulse = 0;\r\n            point.tangentImpulse = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iteratively solve the position overlap constraint\r\n   * @param contacts\r\n   */\r\n  solvePosition(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.positionIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n          for (const point of constraints) {\r\n            const normal = contact.normal;\r\n            const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);\r\n\r\n            const steeringConstant = Physics.steeringFactor; //0.2;\r\n            const maxCorrection = -5;\r\n            const slop = Physics.slop; //1;\r\n\r\n            // Clamp to avoid over-correction\r\n            // Remember that we are shooting for 0 overlap in the end\r\n            const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\r\n            const impulse = normal.scale(-steeringForce * point.normalMass);\r\n\r\n            // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\r\n            // We adjust position and rotation instead of doing the velocity\r\n            if (bodyA.collisionType === CollisionType.Active) {\r\n              // TODO make applyPseudoImpulse function?\r\n              const impulseForce = impulse.negate().scale(bodyA.inverseMass);\r\n              if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n                impulseForce.x = 0;\r\n              }\r\n              if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n                impulseForce.y = 0;\r\n              }\r\n\r\n              bodyA.globalPos = bodyA.globalPos.add(impulseForce);\r\n              if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n                bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\r\n              }\r\n            }\r\n\r\n            if (bodyB.collisionType === CollisionType.Active) {\r\n              const impulseForce = impulse.scale(bodyB.inverseMass);\r\n              if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n                impulseForce.x = 0;\r\n              }\r\n              if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n                impulseForce.y = 0;\r\n              }\r\n\r\n              bodyB.globalPos = bodyB.globalPos.add(impulseForce);\r\n              if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n                bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  solveVelocity(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.velocityIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const friction = Math.min(bodyA.friction, bodyB.friction);\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n          // Friction constraint\r\n          for (const point of constraints) {\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Negate velocity in tangent direction to simulate friction\r\n            const tangentVelocity = -relativeVelocity.dot(contact.tangent);\r\n            let impulseDelta = tangentVelocity * point.tangentMass;\r\n\r\n            // Clamping based in Erin Catto's GDC 2006 talk\r\n            // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\r\n            // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\r\n            // But deltas can vary\r\n            const maxFriction = friction * point.normalImpulse;\r\n            const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\r\n            impulseDelta = newImpulse - point.tangentImpulse;\r\n            point.tangentImpulse = newImpulse;\r\n\r\n            const impulse = contact.tangent.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n\r\n          // Bounce constraint\r\n          for (const point of constraints) {\r\n            // Need to recalc relative velocity because the previous step could have changed vel\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Compute impulse in normal direction\r\n            const normalVelocity = relativeVelocity.dot(contact.normal);\r\n\r\n            // Per Erin it is a mistake to apply the restitution inside the iteration\r\n            // From Erin Catto's Box2D we keep original contact velocity and adjust by small impulses\r\n            let impulseDelta = -point.normalMass * (normalVelocity - point.originalVelocityAndRestitution);\r\n\r\n            // Clamping based in Erin Catto's GDC 2014 talk\r\n            // Accumulated impulse stored in the contact is always positive (dV > 0)\r\n            // But deltas can be negative\r\n            const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\r\n            impulseDelta = newImpulse - point.normalImpulse;\r\n            point.normalImpulse = newImpulse;\r\n\r\n            const impulse = contact.normal.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem/System';\r\nimport { CollisionEndEvent, CollisionStartEvent, ContactEndEvent, ContactStartEvent } from '../Events';\r\nimport { CollisionResolutionStrategy, Physics } from './Physics';\r\nimport { ArcadeSolver } from './Solver/ArcadeSolver';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { DynamicTreeCollisionProcessor } from './Detection/DynamicTreeCollisionProcessor';\r\nimport { RealisticSolver } from './Solver/RealisticSolver';\r\nimport { CollisionSolver } from './Solver/Solver';\r\nimport { ColliderComponent } from './ColliderComponent';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { Engine, ExcaliburGraphicsContext, Scene } from '..';\r\n\r\nexport class CollisionSystem extends System<TransformComponent | MotionComponent | ColliderComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion', 'ex.collider'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  private _engine: Engine;\r\n  private _realisticSolver = new RealisticSolver();\r\n  private _arcadeSolver = new ArcadeSolver();\r\n  private _processor = new DynamicTreeCollisionProcessor();\r\n  private _lastFrameContacts = new Map<string, CollisionContact>();\r\n  private _currentFrameContacts = new Map<string, CollisionContact>();\r\n\r\n  private _trackCollider = (c: Collider) => this._processor.track(c);\r\n  private _untrackCollider = (c: Collider) => this._processor.untrack(c);\r\n\r\n  notify(message: AddedEntity | RemovedEntity) {\r\n    if (isAddedSystemEntity(message)) {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      colliderComponent.$colliderAdded.subscribe(this._trackCollider);\r\n      colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);\r\n      const collider = colliderComponent.get();\r\n      if (collider) {\r\n        this._processor.track(collider);\r\n      }\r\n    } else {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      const collider = colliderComponent.get();\r\n      if (colliderComponent && collider) {\r\n        this._processor.untrack(collider);\r\n      }\r\n    }\r\n  }\r\n\r\n  initialize(scene: Scene) {\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  update(entities: Entity[], elapsedMs: number): void {\r\n    if (!Physics.enabled) {\r\n      return;\r\n    }\r\n\r\n    // Collect up all the colliders and update them\r\n    let colliders: Collider[] = [];\r\n    for (const entity of entities) {\r\n      const colliderComp = entity.get(ColliderComponent);\r\n      const collider = colliderComp?.get();\r\n      if (colliderComp && colliderComp.owner?.active && collider) {\r\n        colliderComp.update();\r\n        if (collider instanceof CompositeCollider) {\r\n          const compositeColliders = collider.getColliders();\r\n          colliders = colliders.concat(compositeColliders);\r\n        } else {\r\n          colliders.push(collider);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update the spatial partitioning data structures\r\n    // TODO if collider invalid it will break the processor\r\n    // TODO rename \"update\" to something more specific\r\n    this._processor.update(colliders);\r\n\r\n    // Run broadphase on all colliders and locates potential collisions\r\n    const pairs = this._processor.broadphase(colliders, elapsedMs);\r\n\r\n    this._currentFrameContacts.clear();\r\n\r\n    // Given possible pairs find actual contacts\r\n    let contacts = this._processor.narrowphase(pairs, this._engine?.debug?.stats?.currFrame);\r\n\r\n    const solver: CollisionSolver = this.getSolver();\r\n\r\n    // Solve, this resolves the position/velocity so entities aren't overlapping\r\n    contacts = solver.solve(contacts);\r\n\r\n    // Record contacts for start/end\r\n    for (const contact of contacts) {\r\n      // Process composite ids, things with the same composite id are treated as the same collider for start/end\r\n      const index = contact.id.indexOf('|');\r\n      if (index > 0) {\r\n        const compositeId = contact.id.substring(index + 1);\r\n        this._currentFrameContacts.set(compositeId, contact);\r\n      } else {\r\n        this._currentFrameContacts.set(contact.id, contact);\r\n      }\r\n    }\r\n\r\n    // Emit contact start/end events\r\n    this.runContactStartEnd();\r\n\r\n    // reset the last frame cache\r\n    this._lastFrameContacts.clear();\r\n\r\n    // Keep track of collisions contacts that have started or ended\r\n    this._lastFrameContacts = new Map(this._currentFrameContacts);\r\n  }\r\n\r\n  getSolver(): CollisionSolver {\r\n    return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;\r\n  }\r\n\r\n  debug(ex: ExcaliburGraphicsContext) {\r\n    this._processor.debug(ex);\r\n  }\r\n\r\n  public runContactStartEnd() {\r\n    // Composite collider collisions may have a duplicate id because we want to treat those as a singular start/end\r\n    for (const [id, c] of this._currentFrameContacts) {\r\n      // find all new contacts\r\n      if (!this._lastFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));\r\n        colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c) as any);\r\n        colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));\r\n        colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c) as any);\r\n      }\r\n    }\r\n\r\n    // find all contacts that have ceased\r\n    for (const [id, c] of this._lastFrameContacts) {\r\n      if (!this._currentFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));\r\n        colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB) as any);\r\n        colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));\r\n        colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA) as any);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { SpriteSheet } from './SpriteSheet';\r\nimport { Logger } from '../Util/Log';\r\nimport { clamp } from '../Math/util';\r\n\r\nexport interface HasTick {\r\n  /**\r\n   *\r\n   * @param elapsedMilliseconds The amount of real world time in milliseconds that has elapsed that must be updated in the animation\r\n   * @param idempotencyToken Optional idempotencyToken prevents a ticking animation from updating twice per frame\r\n   */\r\n  tick(elapsedMilliseconds: number, idempotencyToken?: number): void;\r\n}\r\n\r\nexport enum AnimationDirection {\r\n  /**\r\n   * Animation is playing forwards\r\n   */\r\n  Forward = 'forward',\r\n  /**\r\n   * Animation is play backwards\r\n   */\r\n  Backward = 'backward'\r\n}\r\n\r\nexport enum AnimationStrategy {\r\n  /**\r\n   * Animation ends without displaying anything\r\n   */\r\n  End = 'end',\r\n  /**\r\n   * Animation loops to the first frame after the last frame\r\n   */\r\n  Loop = 'loop',\r\n  /**\r\n   * Animation plays to the last frame, then backwards to the first frame, then repeats\r\n   */\r\n  PingPong = 'pingpong',\r\n  /**\r\n   * Animation ends stopping on the last frame\r\n   */\r\n  Freeze = 'freeze'\r\n}\r\n\r\n/**\r\n * Frame of animation\r\n */\r\nexport interface Frame {\r\n  /**\r\n   * Optionally specify a graphic to show, no graphic shows an empty frame\r\n   */\r\n  graphic?: Graphic;\r\n  /**\r\n   * Optionally specify the number of ms the frame should be visible, overrides the animation duration (default 100 ms)\r\n   */\r\n  duration?: number;\r\n}\r\n\r\n/**\r\n * Animation options for building an animation via constructor.\r\n */\r\nexport interface AnimationOptions {\r\n  /**\r\n   * List of frames in the order you wish to play them\r\n   */\r\n  frames: Frame[];\r\n  /**\r\n   * Optionally reverse the direction of play\r\n   */\r\n  reverse?: boolean;\r\n  /**\r\n   * Optionally specify a default frame duration in ms (Default is 1000)\r\n   */\r\n  frameDuration?: number;\r\n  /**\r\n   * Optionally specify a total duration of the animation in ms to calculate each frame's duration\r\n   */\r\n  totalDuration?: number;\r\n  /**\r\n   * Optionally specify the [[AnimationStrategy]] for the Animation\r\n   */\r\n  strategy?: AnimationStrategy;\r\n}\r\n\r\n// TODO wire up to new Emitter\r\nexport type AnimationEvents = {\r\n  frame: Frame;\r\n  loop: Animation;\r\n  ended: Animation;\r\n};\r\n\r\n/**\r\n * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]\r\n *\r\n * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]\r\n */\r\nexport class Animation extends Graphic implements HasTick {\r\n  private static _LOGGER = Logger.getInstance();\r\n  public events = new EventDispatcher<any>(); // TODO replace with new Emitter\r\n  public frames: Frame[] = [];\r\n  public strategy: AnimationStrategy = AnimationStrategy.Loop;\r\n  public frameDuration: number = 100;\r\n  public timeScale: number = 1;\r\n\r\n  private _idempotencyToken = -1;\r\n\r\n  private _firstTick = true;\r\n  private _currentFrame = 0;\r\n  private _timeLeftInFrame = 0;\r\n  private _direction = 1; // TODO only used in ping-pong\r\n  private _done = false;\r\n  private _playing = true;\r\n\r\n  constructor(options: GraphicOptions & AnimationOptions) {\r\n    super(options);\r\n    this.frames = options.frames;\r\n    this.strategy = options.strategy ?? this.strategy;\r\n    this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : options.frameDuration ?? this.frameDuration;\r\n    if (options.reverse) {\r\n      this.reverse();\r\n    }\r\n    this.goToFrame(0);\r\n  }\r\n\r\n  public clone(): Animation {\r\n    return new Animation({\r\n      frames: this.frames.map((f) => ({ ...f })),\r\n      frameDuration: this.frameDuration,\r\n      reverse: this._reversed,\r\n      strategy: this.strategy,\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n\r\n  public override get width(): number {\r\n    const maybeFrame = this.currentFrame;\r\n    if (maybeFrame) {\r\n      return Math.abs(maybeFrame.graphic.width * this.scale.x);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  public override get height(): number {\r\n    const maybeFrame = this.currentFrame;\r\n    if (maybeFrame) {\r\n      return Math.abs(maybeFrame.graphic.height * this.scale.y);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n\r\n  /**\r\n   * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame\r\n   * and optional [[AnimationStrategy]]\r\n   *\r\n   * Example:\r\n   * ```typescript\r\n   * const spriteSheet = SpriteSheet.fromImageSource({...});\r\n   *\r\n   * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);\r\n   * ```\r\n   *\r\n   * @param spriteSheet\r\n   * @param frameIndices\r\n   * @param durationPerFrameMs\r\n   * @param strategy\r\n   */\r\n  public static fromSpriteSheet(\r\n    spriteSheet: SpriteSheet,\r\n    frameIndices: number[],\r\n    durationPerFrameMs: number,\r\n    strategy: AnimationStrategy = AnimationStrategy.Loop\r\n  ): Animation {\r\n    const maxIndex = spriteSheet.sprites.length - 1;\r\n    const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);\r\n    if (invalidIndices.length) {\r\n      Animation._LOGGER.warn(\r\n        `Indices into SpriteSheet were provided that don\\'t exist: ${invalidIndices.join(',')} no frame will be shown`\r\n      );\r\n    }\r\n    return new Animation({\r\n      frames: spriteSheet.sprites\r\n        .filter((_, index) => frameIndices.indexOf(index) > -1)\r\n        .map((f) => ({\r\n          graphic: f,\r\n          duration: durationPerFrameMs\r\n        })),\r\n      strategy: strategy\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the current Frame of the animation\r\n   */\r\n  public get currentFrame(): Frame | null {\r\n    if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {\r\n      return this.frames[this._currentFrame];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the current frame index of the animation\r\n   */\r\n  public get currentFrameIndex(): number {\r\n    return this._currentFrame;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is playing\r\n   */\r\n  public get isPlaying(): boolean {\r\n    return this._playing;\r\n  }\r\n\r\n  private _reversed = false;\r\n  /**\r\n   * Reverses the play direction of the Animation, this preserves the current frame\r\n   */\r\n  public reverse(): void {\r\n    // Don't mutate with the original frame list, create a copy\r\n    this.frames = this.frames.slice().reverse();\r\n    this._reversed = !this._reversed;\r\n  }\r\n\r\n  /**\r\n   * Returns the current play direction of the animation\r\n   */\r\n  public get direction(): AnimationDirection {\r\n    // Keep logically consistent with ping-pong direction\r\n    // If ping-pong is forward = 1 and reversed is true then we are logically reversed\r\n    const reversed = (this._reversed && this._direction === 1) ? true : false;\r\n    return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;\r\n  }\r\n\r\n  /**\r\n   * Plays or resumes the animation from the current frame\r\n   */\r\n  public play(): void {\r\n    this._playing = true;\r\n  }\r\n\r\n  /**\r\n   * Pauses the animation on the current frame\r\n   */\r\n  public pause(): void {\r\n    this._playing = false;\r\n    this._firstTick = true; // firstTick must be set to emit the proper frame event\r\n  }\r\n\r\n  /**\r\n   * Reset the animation back to the beginning, including if the animation were done\r\n   */\r\n  public reset(): void {\r\n    this._done = false;\r\n    this._firstTick = true;\r\n    this._currentFrame = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation can end\r\n   */\r\n  public get canFinish(): boolean {\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.End:\r\n      case AnimationStrategy.Freeze: {\r\n        return true;\r\n      }\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is done, for looping type animations\r\n   * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`\r\n   *\r\n   * See the `ex.Animation.canFinish()` method to know if an animation type can end\r\n   */\r\n  public get done(): boolean {\r\n    return this._done;\r\n  }\r\n\r\n  /**\r\n   * Jump the animation immediately to a specific frame if it exists\r\n   * @param frameNumber\r\n   */\r\n  public goToFrame(frameNumber: number) {\r\n    this._currentFrame = frameNumber;\r\n    this._timeLeftInFrame = this.frameDuration;\r\n    const maybeFrame = this.frames[this._currentFrame];\r\n    if (maybeFrame && !this._done) {\r\n      this._timeLeftInFrame = maybeFrame?.duration || this.frameDuration;\r\n      this.events.emit('frame', maybeFrame as any);\r\n    }\r\n  }\r\n\r\n  private _nextFrame(): number {\r\n    const currentFrame = this._currentFrame;\r\n    if (this._done) {\r\n      return currentFrame;\r\n    }\r\n    let next = -1;\r\n\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.Loop: {\r\n        next = (currentFrame + 1) % this.frames.length;\r\n        if (next === 0) {\r\n          this.events.emit('loop', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.End: {\r\n        next = currentFrame + 1;\r\n        if (next >= this.frames.length) {\r\n          this._done = true;\r\n          this._currentFrame = this.frames.length;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.Freeze: {\r\n        next = clamp(currentFrame + 1, 0, this.frames.length - 1);\r\n        if (next >= this.frames.length - 1) {\r\n          this._done = true;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.PingPong: {\r\n        if (currentFrame + this._direction >= this.frames.length) {\r\n          this._direction = -1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        if (currentFrame + this._direction < 0) {\r\n          this._direction = 1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        next = currentFrame + (this._direction % this.frames.length);\r\n        break;\r\n      }\r\n    }\r\n    return next;\r\n  }\r\n\r\n  /**\r\n   * Called internally by Excalibur to update the state of the animation potential update the current frame\r\n   * @param elapsedMilliseconds Milliseconds elapsed\r\n   * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame\r\n   */\r\n  public tick(elapsedMilliseconds: number, idempotencyToken: number = 0): void {\r\n    if (this._idempotencyToken === idempotencyToken) {\r\n      return;\r\n    }\r\n    this._idempotencyToken = idempotencyToken;\r\n    if (!this._playing) {\r\n      return;\r\n    }\r\n\r\n    // if it's the first frame emit frame event\r\n    if (this._firstTick) {\r\n      this._firstTick = false;\r\n      this.events.emit('frame', this.currentFrame as any);\r\n    }\r\n\r\n    this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;\r\n    if (this._timeLeftInFrame <= 0) {\r\n      this.goToFrame(this._nextFrame());\r\n    }\r\n  }\r\n\r\n  protected _drawImage(ctx: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this.currentFrame) {\r\n      this.currentFrame.graphic.draw(ctx, x, y);\r\n    }\r\n  }\r\n}\r\n","export type Constructor<T> = {\r\n  new (...args: any[]): T;\r\n};\r\n/**\r\n * Configurable helper extends base type and makes all properties available as option bag arguments\r\n * @internal\r\n * @param base\r\n */\r\nexport function Configurable<T extends Constructor<{}>>(base: T): T {\r\n  return class extends base {\r\n    public assign(props: Partial<T>) {\r\n      //set the value of every property that was passed in,\r\n      //if the constructor previously set this value, it will be overridden here\r\n      for (const k in props) {\r\n        // eslint-disable-next-line\r\n        if (typeof (<any>this)[k] !== 'function') {\r\n          // eslint-disable-next-line\r\n          (<any>this)[k] = (<any>props)[k];\r\n        }\r\n      }\r\n    }\r\n\r\n    constructor(...args: any[]) {\r\n      super(...args);\r\n      //get the number of arguments that aren't undefined. TS passes a value to all parameters\r\n      //of whatever ctor is the implementation, so args.length doesn't work here.\r\n      const size = args.filter(function(value) {\r\n        return value !== undefined;\r\n      }).length;\r\n      if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {\r\n        this.assign(args[0]);\r\n      }\r\n    }\r\n  };\r\n}\r\n","import { Engine } from './Engine';\r\nimport { Actor } from './Actor';\r\nimport { Color } from './Color';\r\nimport { Vector, vec } from './Math/vector';\r\nimport * as Util from './Util/Util';\r\nimport { Configurable } from './Configurable';\r\nimport { Random } from './Math/Random';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { Sprite } from './Graphics/Sprite';\r\nimport { BoundingBox } from './Collision/BoundingBox';\r\nimport { clamp, randomInRange } from './Math/util';\r\n\r\n/**\r\n * An enum that represents the types of emitter nozzles\r\n */\r\nexport enum EmitterType {\r\n  /**\r\n   * Constant for the circular emitter type\r\n   */\r\n  Circle,\r\n  /**\r\n   * Constant for the rectangular emitter type\r\n   */\r\n  Rectangle\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ParticleImpl extends Entity {\r\n  public position: Vector = new Vector(0, 0);\r\n  public velocity: Vector = new Vector(0, 0);\r\n  public acceleration: Vector = new Vector(0, 0);\r\n  public particleRotationalVelocity: number = 0;\r\n  public currentRotation: number = 0;\r\n\r\n  public focus: Vector = null;\r\n  public focusAccel: number = 0;\r\n  public opacity: number = 1;\r\n  public beginColor: Color = Color.White;\r\n  public endColor: Color = Color.White;\r\n\r\n  // Life is counted in ms\r\n  public life: number = 300;\r\n  public fadeFlag: boolean = false;\r\n\r\n  // Color transitions\r\n  private _rRate: number = 1;\r\n  private _gRate: number = 1;\r\n  private _bRate: number = 1;\r\n  private _aRate: number = 0;\r\n  private _currentColor: Color = Color.White;\r\n\r\n  public emitter: ParticleEmitter = null;\r\n  public particleSize: number = 5;\r\n  public particleSprite: Sprite = null;\r\n\r\n  public startSize: number;\r\n  public endSize: number;\r\n  public sizeRate: number = 0;\r\n  public elapsedMultiplier: number = 0;\r\n\r\n  public visible = true;\r\n  public isOffscreen = false;\r\n\r\n  public transform: TransformComponent;\r\n  public graphics: GraphicsComponent;\r\n\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super();\r\n    let emitter = emitterOrConfig;\r\n    if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {\r\n      const config = emitterOrConfig;\r\n      emitter = config.emitter;\r\n      life = config.life;\r\n      opacity = config.opacity;\r\n      endColor = config.endColor;\r\n      beginColor = config.beginColor;\r\n      position = config.position;\r\n      velocity = config.velocity;\r\n      acceleration = config.acceleration;\r\n      startSize = config.startSize;\r\n      endSize = config.endSize;\r\n    }\r\n    this.emitter = <ParticleEmitter>emitter;\r\n    this.life = life || this.life;\r\n    this.opacity = opacity || this.opacity;\r\n    this.endColor = endColor || this.endColor.clone();\r\n    this.beginColor = beginColor || this.beginColor.clone();\r\n    this._currentColor = this.beginColor.clone();\r\n    this.position = (position || this.position).add(this.emitter.pos);\r\n    this.velocity = velocity || this.velocity;\r\n    this.acceleration = acceleration || this.acceleration;\r\n    this._rRate = (this.endColor.r - this.beginColor.r) / this.life;\r\n    this._gRate = (this.endColor.g - this.beginColor.g) / this.life;\r\n    this._bRate = (this.endColor.b - this.beginColor.b) / this.life;\r\n    this._aRate = this.opacity / this.life;\r\n\r\n    this.startSize = startSize || 0;\r\n    this.endSize = endSize || 0;\r\n\r\n    if (this.endSize > 0 && this.startSize > 0) {\r\n      this.sizeRate = (this.endSize - this.startSize) / this.life;\r\n      this.particleSize = this.startSize;\r\n    }\r\n\r\n    this.addComponent((this.transform = new TransformComponent()));\r\n    this.addComponent((this.graphics = new GraphicsComponent()));\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // TODO wut\r\n    if (this.particleSprite) {\r\n      this.graphics.opacity = this.opacity;\r\n      this.graphics.use(this.particleSprite);\r\n    } else {\r\n      this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);\r\n      this.graphics.onPostDraw = (ctx) => {\r\n        ctx.save();\r\n        this.graphics.opacity = this.opacity;\r\n        const tmpColor = this._currentColor.clone();\r\n        tmpColor.a = 1;\r\n        ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });\r\n        ctx.restore();\r\n      };\r\n    }\r\n  }\r\n\r\n  public kill() {\r\n    this.emitter.removeParticle(this);\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this.life = this.life - delta;\r\n    this.elapsedMultiplier = this.elapsedMultiplier + delta;\r\n\r\n    if (this.life < 0) {\r\n      this.kill();\r\n    }\r\n\r\n    if (this.fadeFlag) {\r\n      this.opacity = clamp(this._aRate * this.life, 0.0001, 1);\r\n    }\r\n\r\n    if (this.startSize > 0 && this.endSize > 0) {\r\n      this.particleSize = clamp(\r\n        this.sizeRate * delta + this.particleSize,\r\n        Math.min(this.startSize, this.endSize),\r\n        Math.max(this.startSize, this.endSize)\r\n      );\r\n    }\r\n\r\n    this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);\r\n    this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);\r\n    this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);\r\n    this._currentColor.a = clamp(this.opacity, 0.0001, 1);\r\n\r\n    if (this.focus) {\r\n      const accel = this.focus\r\n        .sub(this.position)\r\n        .normalize()\r\n        .scale(this.focusAccel)\r\n        .scale(delta / 1000);\r\n      this.velocity = this.velocity.add(accel);\r\n    } else {\r\n      this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));\r\n    }\r\n    this.position = this.position.add(this.velocity.scale(delta / 1000));\r\n\r\n    if (this.particleRotationalVelocity) {\r\n      this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);\r\n    }\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // todo wut\r\n    this.graphics.opacity = this.opacity;\r\n  }\r\n}\r\n\r\nexport interface ParticleArgs extends Partial<ParticleImpl> {\r\n  emitter: ParticleEmitter;\r\n  position?: Vector;\r\n  velocity?: Vector;\r\n  acceleration?: Vector;\r\n  particleRotationalVelocity?: number;\r\n  currentRotation?: number;\r\n  particleSize?: number;\r\n  particleSprite?: Sprite;\r\n}\r\n\r\n/**\r\n * Particle is used in a [[ParticleEmitter]]\r\n */\r\nexport class Particle extends Configurable(ParticleImpl) {\r\n  constructor(config: ParticleArgs);\r\n  constructor(\r\n    emitter: ParticleEmitter,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  );\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);\r\n  }\r\n}\r\n\r\nexport interface ParticleEmitterArgs {\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  width?: number;\r\n  height?: number;\r\n  isEmitting?: boolean;\r\n  minVel?: number;\r\n  maxVel?: number;\r\n  acceleration?: Vector;\r\n  minAngle?: number;\r\n  maxAngle?: number;\r\n  emitRate?: number;\r\n  particleLife?: number;\r\n  opacity?: number;\r\n  fadeFlag?: boolean;\r\n  focus?: Vector;\r\n  focusAccel?: number;\r\n  startSize?: number;\r\n  endSize?: number;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n  beginColor?: Color;\r\n  endColor?: Color;\r\n  particleSprite?: Sprite;\r\n  emitterType?: EmitterType;\r\n  radius?: number;\r\n  particleRotationalVelocity?: number;\r\n  randomRotation?: boolean;\r\n  random?: Random;\r\n}\r\n\r\n/**\r\n * Using a particle emitter is a great way to create interesting effects\r\n * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`\r\n * extend [[Actor]] allowing you to use all of the features that come with.\r\n */\r\nexport class ParticleEmitter extends Actor {\r\n  private _particlesToEmit: number = 0;\r\n\r\n  public numParticles: number = 0;\r\n\r\n  /**\r\n   * Random number generator\r\n   */\r\n  public random: Random;\r\n\r\n  /**\r\n   * Gets or sets the isEmitting flag\r\n   */\r\n  public isEmitting: boolean = true;\r\n  /**\r\n   * Gets or sets the backing particle collection\r\n   */\r\n  public particles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the backing deadParticle collection\r\n   */\r\n  public deadParticles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the minimum particle velocity\r\n   */\r\n  public minVel: number = 0;\r\n  /**\r\n   * Gets or sets the maximum particle velocity\r\n   */\r\n  public maxVel: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the acceleration vector for all particles\r\n   */\r\n  public acceleration: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Gets or sets the minimum angle in radians\r\n   */\r\n  public minAngle: number = 0;\r\n  /**\r\n   * Gets or sets the maximum angle in radians\r\n   */\r\n  public maxAngle: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the emission rate for particles (particles/sec)\r\n   */\r\n  public emitRate: number = 1; //particles/sec\r\n  /**\r\n   * Gets or sets the life of each particle in milliseconds\r\n   */\r\n  public particleLife: number = 2000;\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public get opacity(): number {\r\n    return super.graphics.opacity;\r\n  }\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public set opacity(opacity: number) {\r\n    super.graphics.opacity = opacity;\r\n  }\r\n  /**\r\n   * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.\r\n   */\r\n  public fadeFlag: boolean = false;\r\n\r\n  /**\r\n   * Gets or sets the optional focus where all particles should accelerate towards\r\n   */\r\n  public focus: Vector = null;\r\n  /**\r\n   * Gets or sets the acceleration for focusing particles if a focus has been specified\r\n   */\r\n  public focusAccel: number = null;\r\n  /**\r\n   * Gets or sets the optional starting size for the particles\r\n   */\r\n  public startSize: number = null;\r\n  /**\r\n   * Gets or sets the optional ending size for the particles\r\n   */\r\n  public endSize: number = null;\r\n\r\n  /**\r\n   * Gets or sets the minimum size of all particles\r\n   */\r\n  public minSize: number = 5;\r\n  /**\r\n   * Gets or sets the maximum size of all particles\r\n   */\r\n  public maxSize: number = 5;\r\n\r\n  /**\r\n   * Gets or sets the beginning color of all particles\r\n   */\r\n  public beginColor: Color = Color.White;\r\n  /**\r\n   * Gets or sets the ending color of all particles\r\n   */\r\n  public endColor: Color = Color.White;\r\n\r\n  private _sprite: Sprite = null;\r\n  /**\r\n   * Gets or sets the sprite that a particle should use\r\n   */\r\n  public get particleSprite(): Sprite {\r\n    return this._sprite;\r\n  }\r\n\r\n  public set particleSprite(val: Sprite) {\r\n    if (val) {\r\n      this._sprite = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the emitter type for the particle emitter\r\n   */\r\n  public emitterType: EmitterType = EmitterType.Rectangle;\r\n\r\n  /**\r\n   * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]\r\n   */\r\n  public radius: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the particle rotational speed velocity\r\n   */\r\n  public particleRotationalVelocity: number = 0;\r\n\r\n  /**\r\n   * Indicates whether particles should start with a random rotation\r\n   */\r\n  public randomRotation: boolean = false;\r\n\r\n  /**\r\n   * @param config particle emitter options bag\r\n   */\r\n  constructor(config: ParticleEmitterArgs) {\r\n    super({ width: config.width ?? 0, height: config.height ?? 0 });\r\n\r\n    const {\r\n      x,\r\n      y,\r\n      pos,\r\n      isEmitting,\r\n      minVel,\r\n      maxVel,\r\n      acceleration,\r\n      minAngle,\r\n      maxAngle,\r\n      emitRate,\r\n      particleLife,\r\n      opacity,\r\n      fadeFlag,\r\n      focus,\r\n      focusAccel,\r\n      startSize,\r\n      endSize,\r\n      minSize,\r\n      maxSize,\r\n      beginColor,\r\n      endColor,\r\n      particleSprite,\r\n      emitterType,\r\n      radius,\r\n      particleRotationalVelocity,\r\n      randomRotation,\r\n      random\r\n    } = { ...config };\r\n\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.isEmitting = isEmitting ?? this.isEmitting;\r\n    this.minVel = minVel ?? this.minVel;\r\n    this.maxVel = maxVel ?? this.maxVel;\r\n    this.acceleration = acceleration ?? this.acceleration;\r\n    this.minAngle = minAngle ?? this.minAngle;\r\n    this.maxAngle = maxAngle ?? this.maxAngle;\r\n    this.emitRate = emitRate ?? this.emitRate;\r\n    this.particleLife = particleLife ?? this.particleLife;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.fadeFlag = fadeFlag ?? this.fadeFlag;\r\n    this.focus = focus ?? this.focus;\r\n    this.focusAccel = focusAccel ?? this.focusAccel;\r\n    this.startSize = startSize ?? this.startSize;\r\n    this.endSize = endSize ?? this.endSize;\r\n    this.minSize = minSize ?? this.minSize;\r\n    this.maxSize = maxSize ?? this.maxSize;\r\n    this.beginColor = beginColor ?? this.beginColor;\r\n    this.endColor = endColor ?? this.endColor;\r\n    this.particleSprite = particleSprite ?? this.particleSprite;\r\n    this.emitterType = emitterType ?? this.emitterType;\r\n    this.radius = radius ?? this.radius;\r\n    this.particleRotationalVelocity = particleRotationalVelocity ?? this.particleRotationalVelocity;\r\n    this.randomRotation = randomRotation ?? this.randomRotation;\r\n\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n\r\n    this.random = random ?? new Random();\r\n  }\r\n\r\n  public removeParticle(particle: Particle) {\r\n    this.deadParticles.push(particle);\r\n  }\r\n\r\n  /**\r\n   * Causes the emitter to emit particles\r\n   * @param particleCount  Number of particles to emit right now\r\n   */\r\n  public emitParticles(particleCount: number) {\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const p = this._createParticle();\r\n      this.particles.push(p);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.add(p);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clearParticles() {\r\n    this.particles.length = 0;\r\n  }\r\n\r\n  // Creates a new particle given the constraints of the emitter\r\n  private _createParticle(): Particle {\r\n    // todo implement emitter constraints;\r\n    let ranX = 0;\r\n    let ranY = 0;\r\n\r\n    const angle = randomInRange(this.minAngle, this.maxAngle, this.random);\r\n    const vel = randomInRange(this.minVel, this.maxVel, this.random);\r\n    const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);\r\n    const dx = vel * Math.cos(angle);\r\n    const dy = vel * Math.sin(angle);\r\n\r\n    if (this.emitterType === EmitterType.Rectangle) {\r\n      ranX = randomInRange(0, this.width, this.random);\r\n      ranY = randomInRange(0, this.height, this.random);\r\n    } else if (this.emitterType === EmitterType.Circle) {\r\n      const radius = randomInRange(0, this.radius, this.random);\r\n      ranX = radius * Math.cos(angle);\r\n      ranY = radius * Math.sin(angle);\r\n    }\r\n\r\n    const p = new Particle(\r\n      this,\r\n      this.particleLife,\r\n      this.opacity,\r\n      this.beginColor,\r\n      this.endColor,\r\n      new Vector(ranX, ranY),\r\n      new Vector(dx, dy),\r\n      this.acceleration,\r\n      this.startSize,\r\n      this.endSize\r\n    );\r\n    p.fadeFlag = this.fadeFlag;\r\n    p.particleSize = size;\r\n    if (this.particleSprite) {\r\n      p.particleSprite = this.particleSprite;\r\n      p.graphics.opacity = this.opacity;\r\n      p.graphics.use(this._sprite);\r\n    }\r\n    p.particleRotationalVelocity = this.particleRotationalVelocity;\r\n    if (this.randomRotation) {\r\n      p.currentRotation = randomInRange(0, Math.PI * 2, this.random);\r\n    }\r\n    if (this.focus) {\r\n      p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));\r\n      p.focusAccel = this.focusAccel;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    super.update(engine, delta);\r\n\r\n    if (this.isEmitting) {\r\n      this._particlesToEmit += this.emitRate * (delta / 1000);\r\n      if (this._particlesToEmit > 1.0) {\r\n        this.emitParticles(Math.floor(this._particlesToEmit));\r\n        this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);\r\n      }\r\n    }\r\n\r\n    // deferred removal\r\n    for (let i = 0; i < this.deadParticles.length; i++) {\r\n      Util.removeItemFromArray(this.deadParticles[i], this.particles);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.remove(this.deadParticles[i], false);\r\n      }\r\n    }\r\n    this.deadParticles.length = 0;\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Scene } from '../Scene';\r\nimport { GraphicsComponent } from './GraphicsComponent';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Camera } from '../Camera';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem';\r\nimport { Engine } from '../Engine';\r\nimport { GraphicsGroup } from '.';\r\nimport { Particle } from '../Particles';\r\nimport { ParallaxComponent } from './ParallaxComponent';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\nimport { BodyComponent } from '../Collision/BodyComponent';\r\n\r\nexport class GraphicsSystem extends System<TransformComponent | GraphicsComponent> {\r\n  public readonly types = ['ex.transform', 'ex.graphics'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 0;\r\n  private _token = 0;\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  private _sortedTransforms: TransformComponent[] = [];\r\n  public get sortedTransforms() {\r\n    return this._sortedTransforms;\r\n  }\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  private _zHasChanged = false;\r\n  private _zIndexUpdate = () => {\r\n    this._zHasChanged = true;\r\n  };\r\n\r\n  public preupdate(): void {\r\n    // Graphics context could be switched to fallback in a new frame\r\n    this._graphicsContext = this._engine.graphicsContext;\r\n    if (this._zHasChanged) {\r\n      this._sortedTransforms.sort((a, b) => {\r\n        return a.z - b.z;\r\n      });\r\n      this._zHasChanged = false;\r\n    }\r\n  }\r\n\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      this._sortedTransforms.push(tx);\r\n      tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n      this._zHasChanged = true;\r\n    } else {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n      const index = this._sortedTransforms.indexOf(tx);\r\n      if (index > -1) {\r\n        this._sortedTransforms.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  public update(_entities: Entity[], delta: number): void {\r\n    this._token++;\r\n    let graphics: GraphicsComponent;\r\n\r\n    // This is a performance enhancement, most things are in world space\r\n    // so if we can only do this once saves a ton of transform updates\r\n    this._graphicsContext.save();\r\n    if (this._camera) {\r\n      this._camera.draw(this._graphicsContext);\r\n    }\r\n    for (const transform of this._sortedTransforms) {\r\n      const entity = transform.owner as Entity;\r\n\r\n      // If the entity is offscreen skip\r\n      if (entity.hasTag('ex.offscreen')) {\r\n        continue;\r\n      }\r\n\r\n      graphics = entity.get(GraphicsComponent);\r\n      // Exit if graphics set to not visible\r\n      if (!graphics.visible) {\r\n        continue;\r\n      }\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      if (transform.coordPlane === CoordPlane.Screen) {\r\n        this._graphicsContext.restore();\r\n      }\r\n\r\n      this._graphicsContext.save();\r\n\r\n      // Tick any graphics state (but only once) for animations and graphics groups\r\n      graphics.update(delta, this._token);\r\n\r\n      // Apply parallax\r\n      const parallax = entity.get(ParallaxComponent);\r\n      if (parallax) {\r\n        // We use the Tiled formula\r\n        // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n        // cameraPos * (1 - parallaxFactor)\r\n        const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);\r\n        const parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n        this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);\r\n      }\r\n\r\n      // Position the entity + estimate lag\r\n      this._applyTransform(entity);\r\n\r\n      // Optionally run the onPreDraw graphics lifecycle draw\r\n      if (graphics.onPreDraw) {\r\n        graphics.onPreDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      // TODO remove this hack on the particle redo\r\n      const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;\r\n      this._graphicsContext.opacity = graphics.opacity * particleOpacity;\r\n\r\n      // Draw the graphics component\r\n      this._drawGraphicsComponent(graphics);\r\n\r\n      // Optionally run the onPostDraw graphics lifecycle draw\r\n      if (graphics.onPostDraw) {\r\n        graphics.onPostDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      // Reset the transform back to the original world space\r\n      if (transform.coordPlane === CoordPlane.Screen) {\r\n        this._graphicsContext.save();\r\n        if (this._camera) {\r\n          this._camera.draw(this._graphicsContext);\r\n        }\r\n      }\r\n    }\r\n    this._graphicsContext.restore();\r\n  }\r\n\r\n  private _drawGraphicsComponent(graphicsComponent: GraphicsComponent) {\r\n    if (graphicsComponent.visible) {\r\n      // this should be moved to the graphics system\r\n      for (const layer of graphicsComponent.layers.get()) {\r\n        for (const { graphic, options } of layer.graphics) {\r\n          let anchor = graphicsComponent.anchor;\r\n          let offset = graphicsComponent.offset;\r\n          if (options?.anchor) {\r\n            anchor = options.anchor;\r\n          }\r\n          if (options?.offset) {\r\n            offset = options.offset;\r\n          }\r\n          // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula\r\n          const offsetX = -graphic.width * anchor.x + offset.x;\r\n          const offsetY = -graphic.height * anchor.y + offset.y;\r\n\r\n          graphic?.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n\r\n          if (this._engine?.isDebug && this._engine.debug.graphics.showBounds) {\r\n            const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n            if (graphic instanceof GraphicsGroup) {\r\n              for (const g of graphic.members) {\r\n                g.graphic?.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n              }\r\n            } else {\r\n              /* istanbul ignore next */\r\n              graphic?.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      const optionalBody = ancestor?.get(BodyComponent);\r\n      let interpolatedPos = transform.pos;\r\n      let interpolatedScale = transform.scale;\r\n      let interpolatedRotation = transform.rotation;\r\n      if (optionalBody) {\r\n        if (this._engine.fixedUpdateFps &&\r\n            optionalBody.__oldTransformCaptured &&\r\n            optionalBody.enableFixedUpdateInterpolate) {\r\n\r\n          // Interpolate graphics if needed\r\n          const blend = this._engine.currentFrameLagMs / (1000 / this._engine.fixedUpdateFps);\r\n          interpolatedPos = transform.pos.scale(blend).add(\r\n            optionalBody.oldPos.scale(1.0 - blend)\r\n          );\r\n          interpolatedScale = transform.scale.scale(blend).add(\r\n            optionalBody.oldScale.scale(1.0 - blend)\r\n          );\r\n          // Rotational lerp https://stackoverflow.com/a/30129248\r\n          const cosine = (1.0 - blend) * Math.cos(optionalBody.oldRotation) + blend * Math.cos(transform.rotation);\r\n          const sine = (1.0 - blend) * Math.sin(optionalBody.oldRotation) + blend * Math.sin(transform.rotation);\r\n          interpolatedRotation = Math.atan2(sine, cosine);\r\n        }\r\n      }\r\n\r\n      if (transform) {\r\n        this._graphicsContext.z = transform.z;\r\n        this._graphicsContext.translate(interpolatedPos.x, interpolatedPos.y);\r\n        this._graphicsContext.scale(interpolatedScale.x, interpolatedScale.y);\r\n        this._graphicsContext.rotate(interpolatedRotation);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Scene } from '../Scene';\r\nimport { Camera } from '../Camera';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { Entity, TransformComponent } from '../EntityComponentSystem';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { toDegrees } from '../Math/util';\r\nimport { BodyComponent, CollisionSystem, CompositeCollider, GraphicsComponent, Particle } from '..';\r\nimport { DebugGraphicsComponent } from '../Graphics/DebugGraphicsComponent';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\n\r\nexport class DebugSystem extends System<TransformComponent> {\r\n  public readonly types = ['ex.transform'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 999; // lowest priority\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _collisionSystem: CollisionSystem;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._graphicsContext = scene.engine.graphicsContext;\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n    this._collisionSystem = scene.world.systemManager.get(CollisionSystem);\r\n  }\r\n\r\n  update(entities: Entity[], _delta: number): void {\r\n    if (!this._engine.isDebug) {\r\n      return;\r\n    }\r\n\r\n    const filterSettings = this._engine.debug.filter;\r\n\r\n    let id: number;\r\n    let name: string;\r\n    const entitySettings = this._engine.debug.entity;\r\n\r\n    let tx: TransformComponent;\r\n    const txSettings = this._engine.debug.transform;\r\n\r\n    let motion: MotionComponent;\r\n    const motionSettings = this._engine.debug.motion;\r\n\r\n    let colliderComp: ColliderComponent;\r\n    const colliderSettings = this._engine.debug.collider;\r\n\r\n    const physicsSettings = this._engine.debug.physics;\r\n\r\n    let graphics: GraphicsComponent;\r\n    const graphicsSettings = this._engine.debug.graphics;\r\n\r\n    let debugDraw: DebugGraphicsComponent;\r\n\r\n    let body: BodyComponent;\r\n    const bodySettings = this._engine.debug.body;\r\n\r\n    const cameraSettings = this._engine.debug.camera;\r\n    for (const entity of entities) {\r\n      if (entity.hasTag('offscreen')) {\r\n        // skip offscreen entities\r\n        continue;\r\n      }\r\n      if (entity instanceof Particle) {\r\n        // Particles crush the renderer :(\r\n        continue;\r\n      }\r\n      if (filterSettings.useFilter) {\r\n        const allIds = filterSettings.ids.length === 0;\r\n        const idMatch = allIds || filterSettings.ids.includes(entity.id);\r\n        if (!idMatch) {\r\n          continue;\r\n        }\r\n        const allNames = filterSettings.nameQuery === '';\r\n        const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);\r\n        if (!nameMatch) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      let cursor = Vector.Zero;\r\n      const lineHeight = vec(0, 16);\r\n      id = entity.id;\r\n      name = entity.name;\r\n      tx = entity.get(TransformComponent);\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      this._pushCameraTransform(tx);\r\n\r\n      this._graphicsContext.save();\r\n\r\n      this._applyTransform(entity);\r\n      if (tx) {\r\n        if (txSettings.showAll || txSettings.showPosition) {\r\n          this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });\r\n        }\r\n        if (txSettings.showAll || txSettings.showPositionLabel) {\r\n          this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n        if (txSettings.showAll || txSettings.showZIndex) {\r\n          this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showId) {\r\n          this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? 'child of id(' + entity.parent?.id + ')' : ''}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showName) {\r\n          this._graphicsContext.debug.drawText(`name(${name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showRotation) {\r\n          this._graphicsContext.drawLine(\r\n            Vector.Zero,\r\n            Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero),\r\n            txSettings.rotationColor,\r\n            2\r\n          );\r\n          this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showScale) {\r\n          this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);\r\n        }\r\n      }\r\n\r\n      graphics = entity.get(GraphicsComponent);\r\n      if (graphics) {\r\n        if (graphicsSettings.showAll || graphicsSettings.showBounds) {\r\n          const bounds = graphics.localBounds;\r\n          bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);\r\n        }\r\n      }\r\n\r\n      debugDraw = entity.get(DebugGraphicsComponent);\r\n      if (debugDraw) {\r\n        if (!debugDraw.useTransform) {\r\n          this._graphicsContext.restore();\r\n        }\r\n        debugDraw.draw(this._graphicsContext);\r\n        if (!debugDraw.useTransform) {\r\n          this._graphicsContext.save();\r\n          this._applyTransform(entity);\r\n        }\r\n      }\r\n\r\n      body = entity.get(BodyComponent);\r\n      if (body) {\r\n        if (bodySettings.showAll || bodySettings.showCollisionGroup) {\r\n          this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showCollisionType) {\r\n          this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMass) {\r\n          this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMotion) {\r\n          this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showSleeping) {\r\n          this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping: 'cant sleep'})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      motion = entity.get(MotionComponent);\r\n      if (motion) {\r\n        if (motionSettings.showAll || motionSettings.showVelocity) {\r\n          this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (motionSettings.showAll || motionSettings.showAcceleration) {\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);\r\n        }\r\n      }\r\n\r\n      // Colliders live in world space already so after the restore()\r\n      colliderComp = entity.get(ColliderComponent);\r\n      if (colliderComp) {\r\n        const collider = colliderComp.get();\r\n        if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {\r\n          collider.debug(this._graphicsContext, colliderSettings.geometryColor);\r\n        }\r\n        if (colliderSettings.showAll || colliderSettings.showBounds) {\r\n          if (collider instanceof CompositeCollider) {\r\n            const colliders = collider.getColliders();\r\n            for (const collider of colliders) {\r\n              const bounds = collider.bounds;\r\n              const pos = vec(bounds.left, bounds.top);\r\n              this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n              if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);\r\n              }\r\n            }\r\n            colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);\r\n          } else if (collider) {\r\n            const bounds = colliderComp.bounds;\r\n            const pos = vec(bounds.left, bounds.top);\r\n            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n            if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n              this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      this._popCameraTransform(tx);\r\n    }\r\n\r\n    this._graphicsContext.save();\r\n    this._camera.draw(this._graphicsContext);\r\n    if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {\r\n      this._collisionSystem.debug(this._graphicsContext);\r\n    }\r\n    if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {\r\n      for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });\r\n          }\r\n        }\r\n\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {\r\n              color: physicsSettings.collisionNormalColor\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this._graphicsContext.restore();\r\n\r\n    if (cameraSettings) {\r\n      this._graphicsContext.save();\r\n      this._camera.draw(this._graphicsContext);\r\n      if (cameraSettings.showAll || cameraSettings.showFocus) {\r\n        this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);\r\n      }\r\n      if (cameraSettings.showAll || cameraSettings.showZoom) {\r\n        this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);\r\n      }\r\n      this._graphicsContext.restore();\r\n    }\r\n\r\n    this._graphicsContext.flush();\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      if (transform) {\r\n        this._graphicsContext.translate(transform.pos.x, transform.pos.y);\r\n        this._graphicsContext.scale(transform.scale.x, transform.scale.y);\r\n        this._graphicsContext.rotate(transform.rotation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _pushCameraTransform(transform: TransformComponent) {\r\n    // Establish camera offset per entity\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      this._graphicsContext.save();\r\n      if (this._camera) {\r\n        this._camera.draw(this._graphicsContext);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _popCameraTransform(transform: TransformComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      // Apply camera world offset\r\n      this._graphicsContext.restore();\r\n    }\r\n  }\r\n}\r\n","import { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { Engine } from '../Engine';\r\nimport {\r\n  System,\r\n  TransformComponent,\r\n  SystemType,\r\n  Entity,\r\n  AddedEntity,\r\n  RemovedEntity,\r\n  isAddedSystemEntity\r\n} from '../EntityComponentSystem';\r\nimport { GraphicsComponent } from '../Graphics/GraphicsComponent';\r\nimport { Scene } from '../Scene';\r\nimport { PointerComponent } from './PointerComponent';\r\nimport { PointerEventReceiver } from './PointerEventReceiver';\r\nimport { PointerEvent } from './PointerEvent';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\n\r\n/**\r\n * The PointerSystem is responsible for dispatching pointer events to entities\r\n * that need them.\r\n *\r\n * The PointerSystem can be optionally configured by the [[PointerComponent]], by default Entities use\r\n * the [[Collider]]'s shape for pointer events.\r\n */\r\nexport class PointerSystem extends System<TransformComponent | PointerComponent> {\r\n  public readonly types = ['ex.transform', 'ex.pointer'] as const;\r\n  public readonly systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  private _engine: Engine;\r\n  private _receiver: PointerEventReceiver;\r\n\r\n  /**\r\n   * Optionally override component configuration for all entities\r\n   */\r\n  public overrideUseColliderShape = false;\r\n  /**\r\n   * Optionally override component configuration for all entities\r\n   */\r\n  public overrideUseGraphicsBounds = false;\r\n\r\n  public lastFrameEntityToPointers = new Map<number, number[]>();\r\n  public currentFrameEntityToPointers = new Map<number, number[]>();\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  private _sortedTransforms: TransformComponent[] = [];\r\n  private _sortedEntities: Entity[] = [];\r\n\r\n  private _zHasChanged = false;\r\n  private _zIndexUpdate = () => {\r\n    this._zHasChanged = true;\r\n  };\r\n\r\n  public preupdate(): void {\r\n    // event receiver might change per frame\r\n    this._receiver = this._engine.input.pointers;\r\n    if (this._zHasChanged) {\r\n      this._sortedTransforms.sort((a, b) => {\r\n        return b.z - a.z;\r\n      });\r\n      this._sortedEntities = this._sortedTransforms.map(t => t.owner);\r\n      this._zHasChanged = false;\r\n    }\r\n  }\r\n\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      this._sortedTransforms.push(tx);\r\n      this._sortedEntities.push(tx.owner);\r\n      tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n      this._zHasChanged = true;\r\n    } else {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n      const index = this._sortedTransforms.indexOf(tx);\r\n      if (index > -1) {\r\n        this._sortedTransforms.splice(index, 1);\r\n        this._sortedEntities.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  public entityCurrentlyUnderPointer(entity: Entity, pointerId: number) {\r\n    return this.currentFrameEntityToPointers.has(entity.id) &&\r\n           this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n  }\r\n\r\n  public entityWasUnderPointer(entity: Entity, pointerId: number) {\r\n    return this.lastFrameEntityToPointers.has(entity.id) &&\r\n           this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n  }\r\n\r\n  public entered(entity: Entity, pointerId: number) {\r\n    return this.entityCurrentlyUnderPointer(entity, pointerId) &&\r\n           !this.lastFrameEntityToPointers.has(entity.id);\r\n  }\r\n\r\n  public left(entity: Entity, pointerId: number) {\r\n    return !this.currentFrameEntityToPointers.has(entity.id) &&\r\n            this.entityWasUnderPointer(entity, pointerId);\r\n  }\r\n\r\n  public addPointerToEntity(entity: Entity, pointerId: number) {\r\n    if (!this.currentFrameEntityToPointers.has(entity.id)) {\r\n      this.currentFrameEntityToPointers.set(entity.id, [pointerId]);\r\n      return;\r\n    }\r\n    const pointers = this.currentFrameEntityToPointers.get(entity.id);\r\n    this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));\r\n  }\r\n\r\n  public update(_entities: Entity[]): void {\r\n    // Locate all the pointer/entity mappings\r\n    this._processPointerToEntity(this._sortedEntities);\r\n\r\n    // Dispatch pointer events on entities\r\n    this._dispatchEvents(this._sortedEntities);\r\n\r\n    // Clear last frame's events\r\n    this._receiver.update();\r\n    this.lastFrameEntityToPointers.clear();\r\n    this.lastFrameEntityToPointers = new Map<number, number[]>(this.currentFrameEntityToPointers);\r\n    this.currentFrameEntityToPointers.clear();\r\n    this._receiver.clear();\r\n  }\r\n\r\n  private _processPointerToEntity(entities: Entity[]) {\r\n    let transform: TransformComponent;\r\n    let collider: ColliderComponent;\r\n    let graphics: GraphicsComponent;\r\n    let pointer: PointerComponent;\r\n\r\n    // TODO probably a spatial partition optimization here to quickly query bounds for pointer\r\n    // doesn't seem to cause issues tho for perf\r\n\r\n    // Pre-process find entities under pointers\r\n    for (const entity of entities) {\r\n      transform = entity.get(TransformComponent);\r\n      pointer = entity.get(PointerComponent) ?? new PointerComponent;\r\n      // Check collider contains pointer\r\n      collider = entity.get(ColliderComponent);\r\n      if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {\r\n        collider.update();\r\n        const geom = collider.get();\r\n        if (geom) {\r\n          for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n            if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n              this.addPointerToEntity(entity, pointerId);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check graphics contains pointer\r\n      graphics = entity.get(GraphicsComponent);\r\n      if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {\r\n        const graphicBounds = graphics.localBounds.transform(transform.get().matrix);\r\n        for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n          if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n            this.addPointerToEntity(entity, pointerId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processDownAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastDownPerPointer = new Map<number, PointerEvent>();\r\n    // Loop through down and dispatch to entities\r\n    for (const event of this._receiver.currentFrameDown) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        entity.events.emit('pointerdown', event as any);\r\n        if (this._receiver.isDragStart(event.pointerId)) {\r\n          entity.events.emit('pointerdragstart', event as any);\r\n        }\r\n      }\r\n      lastDownPerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastDownPerPointer;\r\n  }\r\n\r\n  private _processUpAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastUpPerPointer = new Map<number, PointerEvent>();\r\n    // Loop through up and dispatch to entities\r\n    for (const event of this._receiver.currentFrameUp) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        entity.events.emit('pointerup', event as any);\r\n        if (this._receiver.isDragEnd(event.pointerId)) {\r\n          entity.events.emit('pointerdragend', event as any);\r\n        }\r\n      }\r\n      lastUpPerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastUpPerPointer;\r\n  }\r\n\r\n  private _processMoveAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastMovePerPointer = new Map<number, PointerEvent>();\r\n    // Loop through move and dispatch to entities\r\n    for (const event of this._receiver.currentFrameMove) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        // move\r\n        entity.events.emit('pointermove', event as any);\r\n\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragmove', event as any);\r\n        }\r\n      }\r\n      lastMovePerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastMovePerPointer;\r\n  }\r\n\r\n  private _processEnterLeaveAndEmit(entity: Entity, lastUpDownMoveEvents: PointerEvent[]) {\r\n    // up, down, and move are considered for enter and leave\r\n    for (const event of lastUpDownMoveEvents) {\r\n      // enter\r\n      if (event.active && entity.active && this.entered(entity, event.pointerId)) {\r\n        entity.events.emit('pointerenter', event as any);\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragenter', event as any);\r\n        }\r\n        break;\r\n      }\r\n      if (event.active && entity.active &&\r\n          // leave can happen on move\r\n          (this.left(entity, event.pointerId) ||\r\n          // or leave can happen on pointer up\r\n          (this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === 'up'))) {\r\n        entity.events.emit('pointerleave', event as any);\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragleave', event as any);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processCancelAndEmit(entity: Entity) {\r\n    // cancel\r\n    for (const event of this._receiver.currentFrameCancel) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)){\r\n        entity.events.emit('pointercancel', event as any);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processWheelAndEmit(entity: Entity) {\r\n    // wheel\r\n    for (const event of this._receiver.currentFrameWheel) {\r\n      // Currently the wheel only fires under the primary pointer '0'\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) {\r\n        entity.events.emit('pointerwheel', event as any);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _dispatchEvents(entities: Entity[]) {\r\n    const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());\r\n    const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());\r\n    // Filter preserves z order\r\n    const entitiesWithEvents = entities.filter(e => lastFrameEntities.has(e.id) || currentFrameEntities.has(e.id));\r\n    let lastMovePerPointer: Map<number, PointerEvent>;\r\n    let lastUpPerPointer: Map<number, PointerEvent>;\r\n    let lastDownPerPointer: Map<number, PointerEvent>;\r\n    // Dispatch events in entity z order\r\n    for (const entity of entitiesWithEvents) {\r\n      lastDownPerPointer = this._processDownAndEmit(entity);\r\n\r\n      lastUpPerPointer = this._processUpAndEmit(entity);\r\n\r\n      lastMovePerPointer = this._processMoveAndEmit(entity);\r\n\r\n      const lastUpDownMoveEvents = [\r\n        ...lastMovePerPointer.values(),\r\n        ...lastDownPerPointer.values(),\r\n        ...lastUpPerPointer.values()\r\n      ];\r\n      this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);\r\n\r\n      this._processCancelAndEmit(entity);\r\n\r\n      this._processWheelAndEmit(entity);\r\n    }\r\n  }\r\n}","import { Entity } from '../EntityComponentSystem';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ActionsComponent } from './ActionsComponent';\r\n\r\n\r\nexport class ActionsSystem extends System<ActionsComponent> {\r\n  public readonly types = ['ex.actions'] as const;\r\n  systemType = SystemType.Update;\r\n  priority = -1;\r\n\r\n  private _actions: ActionsComponent[] = [];\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n      this._actions.push(action);\r\n    } else {\r\n      const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n      const index = this._actions.indexOf(action);\r\n      if (index > -1) {\r\n        this._actions.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  update(_entities: Entity[], delta: number): void {\r\n    for (const actions of this._actions) {\r\n      actions.update(delta);\r\n    }\r\n  }\r\n}","import { Component } from '../EntityComponentSystem/Component';\r\nimport { IsometricMap } from './IsometricMap';\r\n\r\nexport class IsometricEntityComponent extends Component<'ex.isometricentity'> {\r\n  public readonly type = 'ex.isometricentity';\r\n  /**\r\n   * Vertical \"height\" in the isometric world\r\n   */\r\n  public elevation: number = 0;\r\n\r\n  public map: IsometricMap;\r\n\r\n  /**\r\n   * Specify the isometric map to use to position this entity's z-index\r\n   * @param map\r\n   */\r\n  constructor(map: IsometricMap) {\r\n    super();\r\n    this.map = map;\r\n  }\r\n}","import { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { IsometricEntityComponent } from './IsometricEntityComponent';\r\n\r\n\r\nexport class IsometricEntitySystem extends System<TransformComponent | IsometricEntityComponent> {\r\n  public readonly types = ['ex.transform', 'ex.isometricentity'] as const;\r\n  public readonly systemType = SystemType.Update;\r\n  priority: number = 99;\r\n  update(entities: Entity[], _delta: number): void {\r\n    let transform: TransformComponent;\r\n    let iso: IsometricEntityComponent;\r\n    for (const entity of entities) {\r\n      transform = entity.get(TransformComponent);\r\n      iso = entity.get(IsometricEntityComponent);\r\n\r\n      const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);\r\n\r\n      const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;\r\n      transform.z = newZ;\r\n    }\r\n  }\r\n}","import { GraphicsComponent } from './GraphicsComponent';\r\nimport { EnterViewPortEvent, ExitViewPortEvent } from '../Events';\r\nimport { Scene } from '../Scene';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Camera } from '../Camera';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ParallaxComponent } from './ParallaxComponent';\r\nimport { Vector } from '../Math/vector';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\n\r\nexport class OffscreenSystem extends System<TransformComponent | GraphicsComponent> {\r\n  public readonly types = ['ex.transform', 'ex.graphics'] as const;\r\n  public systemType = SystemType.Draw;\r\n  priority: number = -1;\r\n  private _camera: Camera;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._camera = scene.camera;\r\n  }\r\n\r\n  update(entities: Entity[]): void {\r\n    let transform: TransformComponent;\r\n    let graphics: GraphicsComponent;\r\n    let maybeParallax: ParallaxComponent;\r\n\r\n    for (const entity of entities) {\r\n      graphics = entity.get(GraphicsComponent);\r\n      transform = entity.get(TransformComponent);\r\n      maybeParallax = entity.get(ParallaxComponent);\r\n\r\n      let parallaxOffset: Vector;\r\n      if (maybeParallax) {\r\n        // We use the Tiled formula\r\n        // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n        // cameraPos * (1 - parallaxFactor)\r\n        const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n        parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n      }\r\n\r\n      // Figure out if entities are offscreen\r\n      const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);\r\n      if (entityOffscreen && !entity.hasTag('ex.offscreen')) {\r\n        entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));\r\n        entity.addTag('ex.offscreen');\r\n      }\r\n\r\n      if (!entityOffscreen && entity.hasTag('ex.offscreen')) {\r\n        entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));\r\n        entity.removeTag('ex.offscreen');\r\n      }\r\n    }\r\n  }\r\n\r\n  private _isOffscreen(transform: TransformComponent, graphics: GraphicsComponent, parallaxOffset: Vector) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      let bounds = graphics.localBounds;\r\n      if (parallaxOffset) {\r\n        bounds = bounds.translate(parallaxOffset);\r\n      }\r\n      const transformedBounds = bounds.transform(transform.get().matrix);\r\n      const graphicsOffscreen = !this._camera.viewport.overlaps(transformedBounds);\r\n      return graphicsOffscreen;\r\n    } else {\r\n      // TODO screen coordinates\r\n      return false;\r\n    }\r\n  }\r\n\r\n}","import { isScreenElement, ScreenElement } from './ScreenElement';\r\nimport {\r\n  InitializeEvent,\r\n  ActivateEvent,\r\n  DeactivateEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  PreDebugDrawEvent,\r\n  PostDebugDrawEvent,\r\n  GameEvent\r\n} from './Events';\r\nimport { Logger } from './Util/Log';\r\nimport { Timer } from './Timer';\r\nimport { Engine } from './Engine';\r\nimport { TileMap } from './TileMap';\r\nimport { Camera } from './Camera';\r\nimport { Actor } from './Actor';\r\nimport { Class } from './Class';\r\nimport { CanInitialize, CanActivate, CanDeactivate, CanUpdate, CanDraw, SceneActivationContext } from './Interfaces/LifecycleEvents';\r\nimport * as Util from './Util/Util';\r\nimport * as Events from './Events';\r\nimport { Trigger } from './Trigger';\r\nimport { SystemType } from './EntityComponentSystem/System';\r\nimport { World } from './EntityComponentSystem/World';\r\nimport { MotionSystem } from './Collision/MotionSystem';\r\nimport { CollisionSystem } from './Collision/CollisionSystem';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { GraphicsSystem } from './Graphics/GraphicsSystem';\r\nimport { DebugSystem } from './Debug/DebugSystem';\r\nimport { PointerSystem } from './Input/PointerSystem';\r\nimport { ActionsSystem } from './Actions/ActionsSystem';\r\nimport { IsometricEntitySystem } from './TileMap/IsometricEntitySystem';\r\nimport { OffscreenSystem } from './Graphics/OffscreenSystem';\r\nimport { ExcaliburGraphicsContext } from './Graphics';\r\n/**\r\n * [[Actor|Actors]] are composed together into groupings called Scenes in\r\n * Excalibur. The metaphor models the same idea behind real world\r\n * actors in a scene. Only actors in scenes will be updated and drawn.\r\n *\r\n * Typical usages of a scene include: levels, menus, loading screens, etc.\r\n */\r\nexport class Scene<TActivationData = unknown>\r\n  extends Class\r\n  implements CanInitialize, CanActivate<TActivationData>, CanDeactivate, CanUpdate, CanDraw {\r\n  private _logger: Logger = Logger.getInstance();\r\n  /**\r\n   * Gets or sets the current camera for the scene\r\n   */\r\n  public camera: Camera = new Camera();\r\n\r\n  /**\r\n   * The ECS world for the scene\r\n   */\r\n  public world = new World(this);\r\n\r\n  /**\r\n   * The actors in the current scene\r\n   */\r\n  public get actors(): readonly Actor[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Actor;\r\n    }) as Actor[];\r\n  }\r\n\r\n  /**\r\n   * The entities in the current scene\r\n   */\r\n  public get entities(): readonly Entity[] {\r\n    return this.world.entityManager.entities;\r\n  }\r\n\r\n  /**\r\n   * The triggers in the current scene\r\n   */\r\n  public get triggers(): readonly Trigger[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Trigger;\r\n    }) as Trigger[];\r\n  }\r\n\r\n  /**\r\n   * The [[TileMap]]s in the scene, if any\r\n   */\r\n  public get tileMaps(): readonly TileMap[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof TileMap;\r\n    }) as TileMap[];\r\n  }\r\n\r\n  /**\r\n   * Access to the Excalibur engine\r\n   */\r\n  public engine: Engine;\r\n\r\n  private _isInitialized: boolean = false;\r\n  private _timers: Timer[] = [];\r\n  public get timers(): readonly Timer[] {\r\n    return this._timers;\r\n  }\r\n  private _cancelQueue: Timer[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n    // Initialize systems\r\n\r\n    // Update\r\n    this.world.add(new ActionsSystem());\r\n    this.world.add(new MotionSystem());\r\n    this.world.add(new CollisionSystem());\r\n    this.world.add(new PointerSystem());\r\n    this.world.add(new IsometricEntitySystem());\r\n    // Draw\r\n    this.world.add(new OffscreenSystem());\r\n    this.world.add(new GraphicsSystem());\r\n    this.world.add(new DebugSystem());\r\n  }\r\n\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public on(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public on(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public on(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public once(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public once(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public once(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.initialize, handler?: (event: InitializeEvent<Scene>) => void): void;\r\n  public off(eventName: Events.activate, handler?: (event: ActivateEvent) => void): void;\r\n  public off(eventName: Events.deactivate, handler?: (event: DeactivateEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: Events.predebugdraw, handler?: (event: PreDebugDrawEvent) => void): void;\r\n  public off(eventName: Events.postdebugdraw, handler?: (event: PostDebugDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made active and started. It is meant to be overridden,\r\n   * this is where you should setup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onActivate(_context: SceneActivationContext<TActivationData>): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,\r\n   * this is where you should cleanup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onDeactivate(_context: SceneActivationContext): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreDraw` is called directly before a scene is drawn.\r\n   *\r\n   */\r\n  public onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostDraw` is called directly after a scene is drawn.\r\n   *\r\n   */\r\n  public onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Initializes actors in the scene\r\n   */\r\n  private _initializeChildren(): void {\r\n    for (const child of this.entities) {\r\n      child._initialize(this.engine);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the [[Scene]] has been initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Initializes the scene before the first update, meant to be called by engine not by users of\r\n   * Excalibur\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.engine = engine;\r\n      // Initialize camera first\r\n      this.camera._initialize(engine);\r\n\r\n      this.world.systemManager.initialize();\r\n\r\n      // This order is important! we want to be sure any custom init that add actors\r\n      // fire before the actor init\r\n      this.onInitialize.call(this, engine);\r\n      this._initializeChildren();\r\n\r\n      this._logger.debug('Scene.onInitialize', this, engine);\r\n      this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.\r\n   * @internal\r\n   */\r\n  public _activate(context: SceneActivationContext<TActivationData>): void {\r\n    this._logger.debug('Scene.onActivate', this);\r\n    this.onActivate(context);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.\r\n   * @internal\r\n   */\r\n  public _deactivate(context: SceneActivationContext<never>): void {\r\n    this._logger.debug('Scene.onDeactivate', this);\r\n    this.onDeactivate(context);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(_engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));\r\n    this.onPreUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(_engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));\r\n    this.onPostUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _predraw handler for [[onPreDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));\r\n    this.onPreDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _postdraw handler for [[onPostDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));\r\n    this.onPostDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * Updates all the actors and timers in the scene. Called by the [[Engine]].\r\n   * @param engine  Reference to the current Engine\r\n   * @param delta   The number of milliseconds since the last update\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._preupdate(engine, delta);\r\n\r\n    // TODO differed entity removal for timers\r\n    let i: number, len: number;\r\n    // Remove timers in the cancel queue before updating them\r\n    for (i = 0, len = this._cancelQueue.length; i < len; i++) {\r\n      this.removeTimer(this._cancelQueue[i]);\r\n    }\r\n    this._cancelQueue.length = 0;\r\n\r\n    // Cycle through timers updating timers\r\n    for (const timer of this._timers) {\r\n      timer.update(delta);\r\n    }\r\n\r\n    this.world.update(SystemType.Update, delta);\r\n\r\n    // Camera last keeps renders smooth that are based on entity/actor\r\n    if (this.camera) {\r\n      this.camera.update(engine, delta);\r\n    }\r\n\r\n    this._collectActorStats(engine);\r\n\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors in the Scene. Called by the [[Engine]].\r\n   *\r\n   * @param ctx    The current rendering context\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this._predraw(ctx, delta);\r\n\r\n    this.world.update(SystemType.Draw, delta);\r\n\r\n    if (this.engine?.isDebug) {\r\n      this.debugDraw(ctx);\r\n    }\r\n    this._postdraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors' debug information in the Scene. Called by the [[Engine]].\r\n   * @param ctx  The current rendering context\r\n   */\r\n  /* istanbul ignore next */\r\n  public debugDraw(ctx: ExcaliburGraphicsContext) {\r\n    this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));\r\n    // pass\r\n    this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));\r\n  }\r\n\r\n  /**\r\n   * Checks whether an actor is contained in this scene or not\r\n   */\r\n  public contains(actor: Actor): boolean {\r\n    return this.actors.indexOf(actor) > -1;\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the current [[Scene]].\r\n   * @param timer  The timer to add to the current [[Scene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n\r\n  /**\r\n   * Adds a [[TileMap]] to the [[Scene]], once this is done the [[TileMap]] will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Adds a [[Trigger]] to the [[Scene]], once this is done the [[Trigger]] will listen for interactions with other actors.\r\n   * @param trigger\r\n   */\r\n  public add(trigger: Trigger): void;\r\n\r\n  /**\r\n   * Adds an actor to the scene, once this is done the [[Actor]] will be drawn and updated.\r\n   * @param actor  The actor to add to the current scene\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  public add(entity: Entity): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the scene.\r\n   * @param screenElement  The ScreenElement to add to the current scene\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    this.emit('entityadded', { target: entity } as any);\r\n    this.world.add(entity);\r\n    entity.scene = this;\r\n    if (entity instanceof Timer) {\r\n      if (!Util.contains(this._timers, entity)) {\r\n        this.addTimer(entity);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the current scene, it will no longer be updated.\r\n   * @param timer  The timer to remove to the current scene.\r\n   */\r\n  public remove(timer: Timer): void;\r\n\r\n  /**\r\n   * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.\r\n   * @param tileMap {TileMap}\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Removes an actor from the scene, it will no longer be drawn or updated.\r\n   * @param actor  The actor to remove from the current scene.\r\n   */\r\n  public remove(actor: Actor): void;\r\n\r\n  public remove(entity: Entity): void;\r\n\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the current scene\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.emit('entityremoved', { target: entity } as any);\r\n      this.world.remove(entity);\r\n    }\r\n    if (entity instanceof Timer) {\r\n      this.removeTimer(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.\r\n   *\r\n   * By default entities use deferred removal\r\n   * @param deferred\r\n   */\r\n  public clear(deferred: boolean = true): void {\r\n    for (const entity of this.entities) {\r\n      this.world.remove(entity, deferred);\r\n    }\r\n    for (const timer of this.timers) {\r\n      this.removeTimer(timer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the scene\r\n   * @param timer  The timer to add\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    this._timers.push(timer);\r\n    timer.scene = this;\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the scene.\r\n   * @warning Can be dangerous, use [[cancelTimer]] instead\r\n   * @param timer  The timer to remove\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    const i = this._timers.indexOf(timer);\r\n    if (i !== -1) {\r\n      this._timers.splice(i, 1);\r\n    }\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Cancels a [[Timer]], removing it from the scene nicely\r\n   * @param timer  The timer to cancel\r\n   */\r\n  public cancelTimer(timer: Timer): Timer {\r\n    this._cancelQueue.push(timer);\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Tests whether a [[Timer]] is active in the scene\r\n   */\r\n  public isTimerActive(timer: Timer): boolean {\r\n    return this._timers.indexOf(timer) > -1 && !timer.complete;\r\n  }\r\n\r\n  public isCurrentScene(): boolean {\r\n    if (this.engine) {\r\n      return this.engine.currentScene === this;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _collectActorStats(engine: Engine) {\r\n    const screenElements = this.actors.filter((a) => a instanceof ScreenElement) as ScreenElement[];\r\n    for (const _ui of screenElements) {\r\n      engine.stats.currFrame.actors.ui++;\r\n    }\r\n\r\n    for (const actor of this.actors) {\r\n      engine.stats.currFrame.actors.alive++;\r\n      for (const child of actor.children) {\r\n        if (isScreenElement(child as Actor)) {\r\n          // TODO not true\r\n          engine.stats.currFrame.actors.ui++;\r\n        } else {\r\n          engine.stats.currFrame.actors.alive++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","\r\n\r\nexport enum ColorBlindnessMode {\r\n  Protanope = 'Protanope',\r\n  Deuteranope = 'Deuteranope',\r\n  Tritanope = 'Tritanope'\r\n}\r\n","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n// our texture\\r\\nuniform sampler2D u_image;\\r\\n// the texCoords passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// color blind type\\r\\nuniform int u_type;\\r\\n\\r\\n// simulation?\\r\\nuniform bool u_simulate;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  vec4 o =  texture(u_image, v_texcoord);\\r\\n  // RGB to LMS matrix conversion\\r\\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\\r\\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\\r\\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\\r\\n  // Simulate color blindness\\r\\n  float l;\\r\\n  float m;\\r\\n  float s;\\r\\n  //MODE CODE//\\r\\n  if (u_type == 0) {\\r\\n    // Protanope\\r\\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\\r\\n  } else if (u_type == 1) {\\r\\n    // Deuteranope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\\r\\n  } else if (u_type == 2) {\\r\\n    // Tritanope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\\r\\n  }\\r\\n\\r\\n  // LMS to RGB matrix conversion\\r\\n  vec4 error; // simulate the colors\\r\\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\\r\\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\\r\\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\\r\\n  error.a = 1.0;\\r\\n  vec4 diff = o - error;\\r\\n  vec4 correction; // correct the colors\\r\\n  correction.r = 0.0;\\r\\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\\r\\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\\r\\n  correction = o + correction;\\r\\n  correction.a = o.a;\\r\\n  //SIMULATE//\\r\\n\\r\\n  // sim \\r\\n  if (u_simulate) {\\r\\n    fragColor = error.rgba;\\r\\n  } else {\\r\\n    fragColor = correction.rgba;\\r\\n  }\\r\\n}\";","import { Shader } from '../Context/shader';\r\nimport { VertexBuffer } from '../Context/vertex-buffer';\r\nimport { VertexLayout } from '../Context/vertex-layout';\r\n\r\n/**\r\n * Helper that defines a whole screen renderer, just provide a fragment source!\r\n *\r\n * Currently supports 1 varying\r\n * - vec2 a_texcoord between 0-1 which corresponds to screen position\r\n */\r\nexport class ScreenShader {\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  constructor(fragmentSource: string) {\r\n    this._shader = new Shader({\r\n      vertexSource: `#version 300 es\r\n      in vec2 a_position;\r\n      in vec2 a_texcoord;\r\n      out vec2 v_texcoord;\r\n\r\n      void main() {\r\n        gl_Position = vec4(a_position, 0.0, 1.0);\r\n        // Pass the texcoord to the fragment shader.\r\n        v_texcoord = a_texcoord;\r\n      }`,\r\n      fragmentSource: fragmentSource\r\n    });\r\n    this._shader.compile();\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      type: 'static',\r\n      // clip space quad + uv since we don't need a camera\r\n      data: new Float32Array([\r\n        -1, -1,          0, 0,\r\n        -1, 1,           0, 1,\r\n        1, -1,           1, 0,\r\n\r\n        1, -1,            1, 0,\r\n        -1, 1,           0, 1,\r\n        1, 1,            1, 1\r\n      ])\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_texcoord', 2]\r\n      ]\r\n    });\r\n    this._buffer.upload();\r\n  }\r\n\r\n  public getShader() {\r\n    return this._shader;\r\n  }\r\n  public getLayout() {\r\n    return this._layout;\r\n  }\r\n}","import colorBlindCorrectSource from './color-blind-fragment.glsl';\r\nimport { PostProcessor } from './PostProcessor';\r\nimport { ColorBlindnessMode } from './ColorBlindnessMode';\r\nimport { Shader } from '../Context/shader';\r\nimport { VertexLayout } from '../Context/vertex-layout';\r\nimport { ScreenShader } from './ScreenShader';\r\n\r\nexport class ColorBlindnessPostProcessor implements PostProcessor {\r\n  private _shader: ScreenShader;\r\n  private _simulate = false;\r\n  constructor(private _colorBlindnessMode: ColorBlindnessMode, simulate = false) {\r\n    this._simulate = simulate;\r\n  }\r\n\r\n  initialize(_gl: WebGLRenderingContext): void {\r\n    this._shader = new ScreenShader(colorBlindCorrectSource);\r\n    this.simulate = this._simulate;\r\n    this.colorBlindnessMode = this._colorBlindnessMode;\r\n  }\r\n\r\n  getShader(): Shader {\r\n    return this._shader.getShader();\r\n  }\r\n\r\n  getLayout(): VertexLayout {\r\n    return this._shader.getLayout();\r\n  }\r\n\r\n  set colorBlindnessMode(colorBlindMode: ColorBlindnessMode) {\r\n    this._colorBlindnessMode = colorBlindMode;\r\n    if (this._shader) {\r\n      const shader = this._shader.getShader();\r\n      shader.use();\r\n      if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {\r\n        shader.setUniformInt('u_type', 0);\r\n      } else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {\r\n        shader.setUniformInt('u_type', 1);\r\n      } else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {\r\n        shader.setUniformInt('u_type', 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  get colorBlindnessMode(): ColorBlindnessMode {\r\n    return this._colorBlindnessMode;\r\n  }\r\n\r\n  set simulate(value: boolean) {\r\n    this._simulate = value;\r\n    if (this._shader) {\r\n\r\n      const shader = this._shader.getShader();\r\n      shader.use();\r\n      shader.setUniformBoolean('u_simulate', value);\r\n    }\r\n  }\r\n\r\n  get simulate(): boolean {\r\n    return this._simulate;\r\n  }\r\n}\r\n","import { ColorBlindnessMode } from '../Graphics/PostProcessor/ColorBlindnessMode';\r\nimport { ColorBlindnessPostProcessor } from '../Graphics/PostProcessor/ColorBlindnessPostProcessor';\r\nimport { Engine } from '../Engine';\r\nimport { ExcaliburGraphicsContextWebGL } from '..';\r\n\r\nexport interface DebugFlags {\r\n  colorBlindMode: ColorBlindFlags;\r\n}\r\n\r\nexport class ColorBlindFlags {\r\n  private _engine: Engine;\r\n  private _colorBlindPostProcessor: ColorBlindnessPostProcessor;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n    this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);\r\n  }\r\n\r\n  /**\r\n   * Correct colors for a specified color blindness\r\n   * @param colorBlindness\r\n   */\r\n  public correct(colorBlindness: ColorBlindnessMode) {\r\n    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      this.clear();\r\n      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n      this._colorBlindPostProcessor.simulate = false;\r\n      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simulate colors for a specified color blindness\r\n   * @param colorBlindness\r\n   */\r\n  public simulate(colorBlindness: ColorBlindnessMode) {\r\n    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      this.clear();\r\n      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n      this._colorBlindPostProcessor.simulate = true;\r\n      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove color blindness post processor\r\n   */\r\n  public clear() {\r\n    this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);\r\n  }\r\n}\r\n","import { DebugFlags, ColorBlindFlags } from './DebugFlags';\r\nimport { Engine } from '../Engine';\r\nimport { Color } from '../Color';\r\nimport { CollisionContact } from '../Collision/Detection/CollisionContact';\r\nimport { StandardClock, TestClock } from '..';\r\n\r\n/**\r\n * Debug stats containing current and previous frame statistics\r\n */\r\nexport interface DebugStats {\r\n  currFrame: FrameStats;\r\n  prevFrame: FrameStats;\r\n}\r\n\r\n/**\r\n * Represents a frame's individual statistics\r\n */\r\nexport interface FrameStatistics {\r\n  /**\r\n   * The number of the frame\r\n   */\r\n  id: number;\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame scaled by [[Engine.timescale]]) (in ms)\r\n   */\r\n  delta: number;\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  fps: number;\r\n\r\n  /**\r\n   * Duration statistics (in ms)\r\n   */\r\n  duration: FrameDurationStats;\r\n\r\n  /**\r\n   * Actor statistics\r\n   */\r\n  actors: FrameActorStats;\r\n\r\n  /**\r\n   * Physics statistics\r\n   */\r\n  physics: PhysicsStatistics;\r\n\r\n  /**\r\n   * Graphics statistics\r\n   */\r\n  graphics: GraphicsStatistics;\r\n}\r\n\r\n/**\r\n * Represents actor stats for a frame\r\n */\r\nexport interface FrameActorStats {\r\n  /**\r\n   * Gets the frame's number of actors (alive)\r\n   */\r\n  alive: number;\r\n\r\n  /**\r\n   * Gets the frame's number of actors (killed)\r\n   */\r\n  killed: number;\r\n\r\n  /**\r\n   * Gets the frame's number of remaining actors (alive - killed)\r\n   */\r\n  remaining: number;\r\n\r\n  /**\r\n   * Gets the frame's number of UI actors\r\n   */\r\n  ui: number;\r\n\r\n  /**\r\n   * Gets the frame's number of total actors (remaining + UI)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents duration stats for a frame\r\n */\r\nexport interface FrameDurationStats {\r\n  /**\r\n   * Gets the frame's total time to run the update function (in ms)\r\n   */\r\n  update: number;\r\n\r\n  /**\r\n   * Gets the frame's total time to run the draw function (in ms)\r\n   */\r\n  draw: number;\r\n\r\n  /**\r\n   * Gets the frame's total render duration (update + draw duration) (in ms)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents physics stats for the current frame\r\n */\r\nexport interface PhysicsStatistics {\r\n  /**\r\n   * Gets the number of broadphase collision pairs which\r\n   */\r\n  pairs: number;\r\n\r\n  /**\r\n   * Gets the number of actual collisions\r\n   */\r\n  collisions: number;\r\n\r\n  /**\r\n   * Copy of the current frame contacts (only updated if debug is toggled on)\r\n   */\r\n  contacts: Map<string, CollisionContact>;\r\n\r\n  /**\r\n   * Gets the number of fast moving bodies using raycast continuous collisions in the scene\r\n   */\r\n  fastBodies: number;\r\n\r\n  /**\r\n   * Gets the number of bodies that had a fast body collision resolution\r\n   */\r\n  fastBodyCollisions: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the broadphase pairs\r\n   */\r\n  broadphase: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the narrowphase\r\n   */\r\n  narrowphase: number;\r\n}\r\n\r\nexport interface GraphicsStatistics {\r\n  drawCalls: number;\r\n  drawnImages: number;\r\n}\r\n\r\n/**\r\n * Debug statistics and flags for Excalibur. If polling these values, it would be\r\n * best to do so on the `postupdate` event for [[Engine]], after all values have been\r\n * updated during a frame.\r\n */\r\nexport class Debug implements DebugFlags {\r\n  private _engine: Engine;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n\r\n    this.colorBlindMode = new ColorBlindFlags(this._engine);\r\n  }\r\n\r\n  /**\r\n   * Switch the current excalibur clock with the [[TestClock]] and return\r\n   * it in the same running state.\r\n   *\r\n   * This is useful when you need to debug frame by frame.\r\n   */\r\n  public useTestClock(): TestClock {\r\n    const clock = this._engine.clock;\r\n    const wasRunning = clock.isRunning();\r\n    clock.stop();\r\n\r\n    const testClock = clock.toTestClock();\r\n    if (wasRunning) {\r\n      testClock.start();\r\n    }\r\n    this._engine.clock = testClock;\r\n    return testClock;\r\n  }\r\n\r\n  /**\r\n   * Switch the current excalibur clock with the [[StandardClock]] and\r\n   * return it in the same running state.\r\n   *\r\n   * This is useful when you need to switch back to normal mode after\r\n   * debugging.\r\n   */\r\n  public useStandardClock(): StandardClock {\r\n    const currentClock = this._engine.clock;\r\n    const wasRunning = currentClock.isRunning();\r\n    currentClock.stop();\r\n\r\n    const standardClock = currentClock.toStandardClock();\r\n    if (wasRunning) {\r\n      standardClock.start();\r\n    }\r\n    this._engine.clock = standardClock;\r\n    return standardClock;\r\n  }\r\n\r\n  /**\r\n   * Performance statistics\r\n   */\r\n  public stats: DebugStats = {\r\n    /**\r\n     * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[postframe]] event. See [[FrameStats]]\r\n     */\r\n    currFrame: new FrameStats(),\r\n\r\n    /**\r\n     * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]\r\n     */\r\n    prevFrame: new FrameStats()\r\n  };\r\n\r\n  /**\r\n   * Correct or simulate color blindness using [[ColorBlindnessPostProcessor]].\r\n   * @warning Will reduce FPS.\r\n   */\r\n  public colorBlindMode: ColorBlindFlags;\r\n\r\n  /**\r\n   * Filter debug context to named entities or entity ids\r\n   */\r\n  public filter: { useFilter: boolean; nameQuery: string; ids: number[] } = {\r\n    /**\r\n     * Toggle filter on or off (default off) must be on for DebugDraw to use filters\r\n     */\r\n    useFilter: false,\r\n    /**\r\n     * Query for entities by name, if the entity name contains `nameQuery` it will be included\r\n     */\r\n    nameQuery: '',\r\n    /**\r\n     * Query for Entity ids, if the id matches it will be included\r\n     */\r\n    ids: []\r\n  };\r\n\r\n  /**\r\n   * Entity debug settings\r\n   */\r\n  public entity = {\r\n    showAll: false,\r\n    showId: true,\r\n    showName: false\r\n  };\r\n\r\n  /**\r\n   * Transform component debug settings\r\n   */\r\n  public transform = {\r\n    showAll: false,\r\n\r\n    showPosition: false,\r\n    showPositionLabel: false,\r\n    positionColor: Color.Yellow,\r\n\r\n    showZIndex: false,\r\n\r\n    showScale: false,\r\n    scaleColor: Color.Green,\r\n\r\n    showRotation: false,\r\n    rotationColor: Color.Blue\r\n  };\r\n\r\n  /**\r\n   * Graphics component debug settings\r\n   */\r\n  public graphics = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Yellow\r\n  };\r\n\r\n  /**\r\n   * Collider component debug settings\r\n   */\r\n  public collider = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Blue,\r\n\r\n    showOwner: false,\r\n\r\n    showGeometry: true,\r\n    geometryColor: Color.Green\r\n  };\r\n\r\n  /**\r\n   * Physics simulation debug settings\r\n   */\r\n  public physics = {\r\n    showAll: false,\r\n\r\n    showBroadphaseSpacePartitionDebug: false,\r\n\r\n    showCollisionNormals: false,\r\n    collisionNormalColor: Color.Cyan,\r\n\r\n    showCollisionContacts: true,\r\n    collisionContactColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Motion component debug settings\r\n   */\r\n  public motion = {\r\n    showAll: false,\r\n\r\n    showVelocity: false,\r\n    velocityColor: Color.Yellow,\r\n\r\n    showAcceleration: false,\r\n    accelerationColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Body component debug settings\r\n   */\r\n  public body = {\r\n    showAll: false,\r\n\r\n    showCollisionGroup: false,\r\n    showCollisionType: false,\r\n    showSleeping: false,\r\n    showMotion: false,\r\n    showMass: false\r\n  };\r\n\r\n  /**\r\n   * Camera debug settings\r\n   */\r\n  public camera = {\r\n    showAll: false,\r\n\r\n    showFocus: false,\r\n    focusColor: Color.Red,\r\n\r\n    showZoom: false\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid\r\n * creating instances of this every frame.\r\n */\r\nexport class FrameStats implements FrameStatistics {\r\n  private _id: number = 0;\r\n  private _delta: number = 0;\r\n  private _fps: number = 0;\r\n  private _actorStats: FrameActorStats = {\r\n    alive: 0,\r\n    killed: 0,\r\n    ui: 0,\r\n    get remaining() {\r\n      return this.alive - this.killed;\r\n    },\r\n    get total() {\r\n      return this.remaining + this.ui;\r\n    }\r\n  };\r\n  private _durationStats: FrameDurationStats = {\r\n    update: 0,\r\n    draw: 0,\r\n    get total() {\r\n      return this.update + this.draw;\r\n    }\r\n  };\r\n\r\n  private _physicsStats: PhysicsStats = new PhysicsStats();\r\n\r\n  private _graphicsStats: GraphicsStatistics = {\r\n    drawCalls: 0,\r\n    drawnImages: 0\r\n  };\r\n\r\n  /**\r\n   * Zero out values or clone other IFrameStat stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: FrameStatistics) {\r\n    if (otherStats) {\r\n      this.id = otherStats.id;\r\n      this.delta = otherStats.delta;\r\n      this.fps = otherStats.fps;\r\n      this.actors.alive = otherStats.actors.alive;\r\n      this.actors.killed = otherStats.actors.killed;\r\n      this.actors.ui = otherStats.actors.ui;\r\n      this.duration.update = otherStats.duration.update;\r\n      this.duration.draw = otherStats.duration.draw;\r\n      this._physicsStats.reset(otherStats.physics);\r\n      this.graphics.drawCalls = otherStats.graphics.drawCalls;\r\n      this.graphics.drawnImages = otherStats.graphics.drawnImages;\r\n    } else {\r\n      this.id = this.delta = this.fps = 0;\r\n      this.actors.alive = this.actors.killed = this.actors.ui = 0;\r\n      this.duration.update = this.duration.draw = 0;\r\n      this._physicsStats.reset();\r\n      this.graphics.drawnImages = this.graphics.drawCalls = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): FrameStats {\r\n    const fs = new FrameStats();\r\n\r\n    fs.reset(this);\r\n\r\n    return fs;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's id\r\n   */\r\n  public get id() {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's id\r\n   */\r\n  public set id(value: number) {\r\n    this._id = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame)\r\n   */\r\n  public get delta() {\r\n    return this._delta;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's delta (time since last frame). Internal use only.\r\n   * @internal\r\n   */\r\n  public set delta(value: number) {\r\n    this._delta = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  public get fps() {\r\n    return this._fps;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's frames-per-second (FPS). Internal use only.\r\n   * @internal\r\n   */\r\n  public set fps(value: number) {\r\n    this._fps = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's actor statistics\r\n   */\r\n  public get actors() {\r\n    return this._actorStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's duration statistics\r\n   */\r\n  public get duration() {\r\n    return this._durationStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's physics statistics\r\n   */\r\n  public get physics() {\r\n    return this._physicsStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's graphics statistics\r\n   */\r\n  public get graphics() {\r\n    return this._graphicsStats;\r\n  }\r\n}\r\n\r\nexport class PhysicsStats implements PhysicsStatistics {\r\n  private _pairs: number = 0;\r\n  private _collisions: number = 0;\r\n  private _contacts: Map<string, CollisionContact> = new Map();\r\n  private _fastBodies: number = 0;\r\n  private _fastBodyCollisions: number = 0;\r\n  private _broadphase: number = 0;\r\n  private _narrowphase: number = 0;\r\n\r\n  /**\r\n   * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: PhysicsStatistics) {\r\n    if (otherStats) {\r\n      this.pairs = otherStats.pairs;\r\n      this.collisions = otherStats.collisions;\r\n      this.contacts = otherStats.contacts;\r\n      this.fastBodies = otherStats.fastBodies;\r\n      this.fastBodyCollisions = otherStats.fastBodyCollisions;\r\n      this.broadphase = otherStats.broadphase;\r\n      this.narrowphase = otherStats.narrowphase;\r\n    } else {\r\n      this.pairs = this.collisions = this.fastBodies = 0;\r\n      this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;\r\n      this.contacts.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): PhysicsStatistics {\r\n    const ps = new PhysicsStats();\r\n\r\n    ps.reset(this);\r\n\r\n    return ps;\r\n  }\r\n\r\n  public get pairs(): number {\r\n    return this._pairs;\r\n  }\r\n\r\n  public set pairs(value: number) {\r\n    this._pairs = value;\r\n  }\r\n\r\n  public get collisions(): number {\r\n    return this._collisions;\r\n  }\r\n\r\n  public set collisions(value: number) {\r\n    this._collisions = value;\r\n  }\r\n\r\n  public get contacts(): Map<string, CollisionContact> {\r\n    return this._contacts;\r\n  }\r\n\r\n  public set contacts(contacts: Map<string, CollisionContact>) {\r\n    this._contacts = contacts;\r\n  }\r\n\r\n  public get fastBodies(): number {\r\n    return this._fastBodies;\r\n  }\r\n\r\n  public set fastBodies(value: number) {\r\n    this._fastBodies = value;\r\n  }\r\n\r\n  public get fastBodyCollisions(): number {\r\n    return this._fastBodyCollisions;\r\n  }\r\n\r\n  public set fastBodyCollisions(value: number) {\r\n    this._fastBodyCollisions = value;\r\n  }\r\n\r\n  public get broadphase(): number {\r\n    return this._broadphase;\r\n  }\r\n\r\n  public set broadphase(value: number) {\r\n    this._broadphase = value;\r\n  }\r\n\r\n  public get narrowphase(): number {\r\n    return this._narrowphase;\r\n  }\r\n\r\n  public set narrowphase(value: number) {\r\n    this._narrowphase = value;\r\n  }\r\n}\r\n","/**\r\n * Determines the scope of handling mouse/touch events.\r\n */\r\n\r\nexport enum PointerScope {\r\n  /**\r\n   * Handle events on the `canvas` element only. Events originating outside the\r\n   * `canvas` will not be handled.\r\n   */\r\n  Canvas = 'Canvas',\r\n\r\n  /**\r\n   * Handles events on the entire document. All events will be handled by Excalibur.\r\n   */\r\n  Document = 'Document'\r\n}\r\n","import { Class } from './../Class';\r\nimport { GameEvent, GamepadConnectEvent, GamepadDisconnectEvent, GamepadButtonEvent, GamepadAxisEvent } from '../Events';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)\r\n * to provide controller support for your games.\r\n */\r\nexport class Gamepads extends Class {\r\n  /**\r\n   * Whether or not to poll for Gamepad input (default: `false`)\r\n   */\r\n  public enabled = false;\r\n\r\n  /**\r\n   * Whether or not Gamepad API is supported\r\n   */\r\n  public supported = !!(<any>navigator).getGamepads;\r\n\r\n  /**\r\n   * The minimum value an axis has to move before considering it a change\r\n   */\r\n  public static MinAxisMoveThreshold = 0.05;\r\n\r\n  private _gamePadTimeStamps = [0, 0, 0, 0];\r\n  private _oldPads: Gamepad[] = [];\r\n  private _pads: Gamepad[] = [];\r\n  private _initSuccess: boolean = false;\r\n  private _navigator: NavigatorGamepads = <any>navigator;\r\n  private _minimumConfiguration: GamepadConfiguration = null;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public init() {\r\n    if (!this.supported) {\r\n      return;\r\n    }\r\n    if (this._initSuccess) {\r\n      return;\r\n    }\r\n\r\n    // In Chrome, this will return 4 undefined items until a button is pressed\r\n    // In FF, this will not return any items until a button is pressed\r\n    this._oldPads = this._clonePads(this._navigator.getGamepads());\r\n    if (this._oldPads.length && this._oldPads[0]) {\r\n      this._initSuccess = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means\r\n   * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive\r\n   * all other controllers with more axis or buttons are valid as well. If no minimum\r\n   * configuration is set all pads are valid.\r\n   */\r\n  public setMinimumGamepadConfiguration(config: GamepadConfiguration): void {\r\n    this._enableAndUpdate(); // if config is used, implicitly enable\r\n    this._minimumConfiguration = config;\r\n  }\r\n\r\n  /**\r\n   * When implicitly enabled, set the enabled flag and run an update so information is updated\r\n   */\r\n  private _enableAndUpdate() {\r\n    if (!this.enabled) {\r\n      this.enabled = true;\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks a navigator gamepad against the minimum configuration if present.\r\n   */\r\n  private _isGamepadValid(pad: NavigatorGamepad): boolean {\r\n    if (!this._minimumConfiguration) {\r\n      return true;\r\n    }\r\n    if (!pad) {\r\n      return false;\r\n    }\r\n    const axesLength = pad.axes.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n\r\n    const buttonLength = pad.buttons.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n    return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;\r\n  }\r\n\r\n  public on(eventName: Events.connect, handler: (event: GamepadConnectEvent) => void): void;\r\n  public on(eventName: Events.disconnect, handler: (event: GamepadDisconnectEvent) => void): void;\r\n  public on(eventName: Events.button, handler: (event: GamepadButtonEvent) => void): void;\r\n  public on(eventName: Events.axis, handler: (event: GamepadAxisEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void) {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Updates Gamepad state and publishes Gamepad events\r\n   */\r\n  public update() {\r\n    if (!this.enabled || !this.supported) {\r\n      return;\r\n    }\r\n    this.init();\r\n\r\n    const gamepads = this._navigator.getGamepads();\r\n\r\n    for (let i = 0; i < gamepads.length; i++) {\r\n      if (!gamepads[i]) {\r\n        const gamepad = this.at(i);\r\n        // If was connected, but now isn't emit the disconnect event\r\n        if (gamepad.connected) {\r\n          this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));\r\n        }\r\n        // Reset connection status\r\n        gamepad.connected = false;\r\n        continue;\r\n      } else {\r\n        if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {\r\n          this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));\r\n        }\r\n        // Set connection status\r\n        this.at(i).connected = true;\r\n      }\r\n\r\n      // Only supported in Chrome\r\n      if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {\r\n        continue;\r\n      }\r\n\r\n      this._gamePadTimeStamps[i] = gamepads[i].timestamp;\r\n\r\n      // Add reference to navigator gamepad\r\n      this.at(i).navigatorGamepad = gamepads[i];\r\n\r\n      // Buttons\r\n      let b: string, bi: number, a: string, ai: number, value: number;\r\n\r\n      for (b in Buttons) {\r\n        bi = <any>Buttons[b];\r\n        if (typeof bi === 'number') {\r\n          if (gamepads[i].buttons[bi]) {\r\n            value = gamepads[i].buttons[bi].value;\r\n            if (value !== this._oldPads[i].getButton(bi)) {\r\n              if (gamepads[i].buttons[bi].pressed) {\r\n                this.at(i).updateButton(bi, value);\r\n                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));\r\n              } else {\r\n                this.at(i).updateButton(bi, 0);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Axes\r\n      for (a in Axes) {\r\n        ai = <any>Axes[a];\r\n        if (typeof ai === 'number') {\r\n          value = gamepads[i].axes[ai];\r\n          if (value !== this._oldPads[i].getAxes(ai)) {\r\n            this.at(i).updateAxes(ai, value);\r\n            this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));\r\n          }\r\n        }\r\n      }\r\n\r\n      this._oldPads[i] = this._clonePad(gamepads[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist\r\n   */\r\n  public at(index: number): Gamepad {\r\n    this._enableAndUpdate(); // implicitly enable gamepads when at() is called\r\n    if (index >= this._pads.length) {\r\n      // Ensure there is a pad to retrieve\r\n      for (let i = this._pads.length - 1, max = index; i < max; i++) {\r\n        this._pads.push(new Gamepad());\r\n        this._oldPads.push(new Gamepad());\r\n      }\r\n    }\r\n\r\n    return this._pads[index];\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all valid gamepads that meet the minimum configuration requirement.\r\n   */\r\n  public getValidGamepads(): Gamepad[] {\r\n    this._enableAndUpdate();\r\n    const result: Gamepad[] = [];\r\n    for (let i = 0; i < this._pads.length; i++) {\r\n      if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {\r\n        result.push(this.at(i));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets the number of connected gamepads\r\n   */\r\n  public count() {\r\n    return this._pads.filter((p) => p.connected).length;\r\n  }\r\n\r\n  private _clonePads(pads: NavigatorGamepad[]): Gamepad[] {\r\n    const arr = [];\r\n    for (let i = 0, len = pads.length; i < len; i++) {\r\n      arr.push(this._clonePad(pads[i]));\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Fastest way to clone a known object is to do it yourself\r\n   */\r\n  private _clonePad(pad: NavigatorGamepad): Gamepad {\r\n    let i, len;\r\n    const clonedPad = new Gamepad();\r\n\r\n    if (!pad) {\r\n      return clonedPad;\r\n    }\r\n\r\n    for (i = 0, len = pad.buttons.length; i < len; i++) {\r\n      if (pad.buttons[i]) {\r\n        clonedPad.updateButton(i, pad.buttons[i].value);\r\n      }\r\n    }\r\n    for (i = 0, len = pad.axes.length; i < len; i++) {\r\n      clonedPad.updateAxes(i, pad.axes[i]);\r\n    }\r\n\r\n    return clonedPad;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad holds state information for a connected controller. See [[Gamepads]]\r\n * for more information on handling controller input.\r\n */\r\nexport class Gamepad extends Class {\r\n  public connected = false;\r\n  public navigatorGamepad: NavigatorGamepad;\r\n  private _buttons: number[] = new Array(16);\r\n  private _axes: number[] = new Array(4);\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    for (let i = 0; i < this._buttons.length; i++) {\r\n      this._buttons[i] = 0;\r\n    }\r\n    for (let i = 0; i < this._axes.length; i++) {\r\n      this._axes[i] = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether or not the given button is pressed\r\n   * @param button     The button to query\r\n   * @param threshold  The threshold over which the button is considered to be pressed\r\n   */\r\n  public isButtonPressed(button: Buttons, threshold: number = 1) {\r\n    return this._buttons[button] >= threshold;\r\n  }\r\n\r\n  /**\r\n   * Gets the given button value between 0 and 1\r\n   */\r\n  public getButton(button: Buttons) {\r\n    return this._buttons[button];\r\n  }\r\n\r\n  /**\r\n   * Gets the given axis value between -1 and 1. Values below\r\n   * [[MinAxisMoveThreshold]] are considered 0.\r\n   */\r\n  public getAxes(axes: Axes) {\r\n    const value = this._axes[axes];\r\n\r\n    if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {\r\n      return 0;\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  public updateButton(buttonIndex: number, value: number) {\r\n    this._buttons[buttonIndex] = value;\r\n  }\r\n\r\n  public updateAxes(axesIndex: number, value: number) {\r\n    this._axes[axesIndex] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad Buttons enumeration\r\n */\r\nexport enum Buttons {\r\n  /**\r\n   * Face 1 button (e.g. A)\r\n   */\r\n  Face1 = 0,\r\n  /**\r\n   * Face 2 button (e.g. B)\r\n   */\r\n  Face2 = 1,\r\n  /**\r\n   * Face 3 button (e.g. X)\r\n   */\r\n  Face3 = 2,\r\n  /**\r\n   * Face 4 button (e.g. Y)\r\n   */\r\n  Face4 = 3,\r\n  /**\r\n   * Left bumper button\r\n   */\r\n  LeftBumper = 4,\r\n  /**\r\n   * Right bumper button\r\n   */\r\n  RightBumper = 5,\r\n  /**\r\n   * Left trigger button\r\n   */\r\n  LeftTrigger = 6,\r\n  /**\r\n   * Right trigger button\r\n   */\r\n  RightTrigger = 7,\r\n  /**\r\n   * Select button\r\n   */\r\n  Select = 8,\r\n  /**\r\n   * Start button\r\n   */\r\n  Start = 9,\r\n  /**\r\n   * Left analog stick press (e.g. L3)\r\n   */\r\n  LeftStick = 10,\r\n  /**\r\n   * Right analog stick press (e.g. R3)\r\n   */\r\n  RightStick = 11,\r\n  /**\r\n   * D-pad up\r\n   */\r\n  DpadUp = 12,\r\n  /**\r\n   * D-pad down\r\n   */\r\n  DpadDown = 13,\r\n  /**\r\n   * D-pad left\r\n   */\r\n  DpadLeft = 14,\r\n  /**\r\n   * D-pad right\r\n   */\r\n  DpadRight = 15\r\n}\r\n\r\n/**\r\n * Gamepad Axes enumeration\r\n */\r\nexport enum Axes {\r\n  /**\r\n   * Left analogue stick X direction\r\n   */\r\n  LeftStickX = 0,\r\n  /**\r\n   * Left analogue stick Y direction\r\n   */\r\n  LeftStickY = 1,\r\n  /**\r\n   * Right analogue stick X direction\r\n   */\r\n  RightStickX = 2,\r\n  /**\r\n   * Right analogue stick Y direction\r\n   */\r\n  RightStickY = 3\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepads {\r\n  getGamepads(): NavigatorGamepad[];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepad {\r\n  axes: number[];\r\n  buttons: NavigatorGamepadButton[];\r\n  connected: boolean;\r\n  id: string;\r\n  index: number;\r\n  mapping: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadButton {\r\n  pressed: boolean;\r\n  value: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadEvent {\r\n  gamepad: NavigatorGamepad;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface GamepadConfiguration {\r\n  axis: number;\r\n  buttons: number;\r\n}\r\n","export interface NativeEventable {\r\n  addEventListener(name: string, handler: (...any: any[]) => any): any;\r\n  removeEventListener(name: string, handler: (...any: any[]) => any): any;\r\n}\r\n\r\nexport class BrowserComponent<T extends NativeEventable> {\r\n  private _paused = false;\r\n  private _nativeHandlers: { [key: string]: (handler: any) => void } = {};\r\n\r\n  on(eventName: string, handler: (evt: any) => void): void {\r\n    if (this._nativeHandlers[eventName]) {\r\n      this.off(eventName, this._nativeHandlers[eventName]);\r\n    }\r\n    this._nativeHandlers[eventName] = this._decorate(handler);\r\n    this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);\r\n  }\r\n  off(eventName: string, handler?: (event: any) => void): void {\r\n    if (!handler) {\r\n      handler = this._nativeHandlers[eventName];\r\n    }\r\n    this.nativeComponent.removeEventListener(eventName, handler);\r\n    this._nativeHandlers[eventName] = null;\r\n  }\r\n\r\n  private _decorate(handler: (evt: any) => void): (evt: any) => void {\r\n    return (evt: any) => {\r\n      if (!this._paused) {\r\n        handler(evt);\r\n      }\r\n    };\r\n  }\r\n\r\n  public pause() {\r\n    this._paused = true;\r\n  }\r\n\r\n  public resume() {\r\n    this._paused = false;\r\n  }\r\n\r\n  public clear() {\r\n    for (const event in this._nativeHandlers) {\r\n      this.off(event);\r\n    }\r\n  }\r\n\r\n  constructor(public nativeComponent: T) {}\r\n}\r\n\r\nexport class BrowserEvents {\r\n  private _windowComponent: BrowserComponent<Window>;\r\n  private _documentComponent: BrowserComponent<Document>;\r\n  constructor(private _windowGlobal: Window, private _documentGlobal: Document) {\r\n    this._windowComponent = new BrowserComponent(this._windowGlobal);\r\n    this._documentComponent = new BrowserComponent(this._documentGlobal);\r\n  }\r\n\r\n  public get window(): BrowserComponent<Window> {\r\n    return this._windowComponent;\r\n  }\r\n\r\n  public get document(): BrowserComponent<Document> {\r\n    return this._documentComponent;\r\n  }\r\n\r\n  public pause() {\r\n    this.window.pause();\r\n    this.document.pause();\r\n  }\r\n\r\n  public resume() {\r\n    this.window.resume();\r\n    this.document.resume();\r\n  }\r\n\r\n  public clear() {\r\n    this.window.clear();\r\n    this.document.clear();\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Vector } from './vector';\r\n\r\nexport class GlobalCoordinates {\r\n  public static fromPagePosition(x: number, y: number, engine: Engine): GlobalCoordinates;\r\n  public static fromPagePosition(pos: Vector, engine: Engine): GlobalCoordinates;\r\n  public static fromPagePosition(xOrPos: number | Vector, yOrEngine: number | Engine, engineOrUndefined?: Engine): GlobalCoordinates {\r\n    let pageX: number;\r\n    let pageY: number;\r\n    let pagePos: Vector;\r\n    let engine: Engine;\r\n\r\n    if (arguments.length === 3) {\r\n      pageX = <number>xOrPos;\r\n      pageY = <number>yOrEngine;\r\n      pagePos = new Vector(pageX, pageY);\r\n      engine = engineOrUndefined;\r\n    } else {\r\n      pagePos = <Vector>xOrPos;\r\n      pageX = pagePos.x;\r\n      pageY = pagePos.y;\r\n      engine = <Engine>yOrEngine;\r\n    }\r\n\r\n    const screenPos = engine.screen.pageToScreenCoordinates(pagePos);\r\n    const worldPos = engine.screen.screenToWorldCoordinates(screenPos);\r\n\r\n    return new GlobalCoordinates(worldPos, pagePos, screenPos);\r\n  }\r\n\r\n  constructor(public worldPos: Vector, public pagePos: Vector, public screenPos: Vector) {}\r\n}\r\n","import { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { Vector } from '../Math/vector';\r\nimport { PointerButton } from './PointerButton';\r\nimport { PointerType } from './PointerType';\r\n\r\nexport class PointerEvent {\r\n  public active = true;\r\n  public cancel() {\r\n    this.active = false;\r\n  }\r\n\r\n  get pagePos(): Vector {\r\n    return this.coordinates.pagePos;\r\n  }\r\n\r\n  get screenPos(): Vector {\r\n    return this.coordinates.screenPos;\r\n  }\r\n\r\n  get worldPos(): Vector {\r\n    return this.coordinates.worldPos;\r\n  }\r\n\r\n  constructor(\r\n    public type: 'down' | 'up' | 'move' | 'cancel',\r\n    public pointerId: number,\r\n    public button: PointerButton,\r\n    public pointerType: PointerType,\r\n    public coordinates: GlobalCoordinates,\r\n    public nativeEvent: Event) { };\r\n}\r\n","import { WheelDeltaMode } from './WheelDeltaMode';\r\n\r\n\r\nexport class WheelEvent {\r\n  public active = true;\r\n  public cancel() {\r\n    this.active = false;\r\n  }\r\n  constructor(\r\n    public x: number,\r\n    public y: number,\r\n    public pageX: number,\r\n    public pageY: number,\r\n    public screenX: number,\r\n    public screenY: number,\r\n    public index: number,\r\n    public deltaX: number,\r\n    public deltaY: number,\r\n    public deltaZ: number,\r\n    public deltaMode: WheelDeltaMode,\r\n    public ev: Event\r\n  ) { }\r\n}\r\n","import { Class } from '../Class';\r\nimport { Vector } from '../Math/vector';\r\nimport { WheelEvent } from './WheelEvent';\r\nimport { PointerEvent } from './PointerEvent';\r\n\r\nexport class PointerAbstraction extends Class {\r\n\r\n  /**\r\n   * The last position on the document this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastPagePos: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The last position on the screen this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastScreenPos: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastWorldPos: Vector = Vector.Zero;\r\n\r\n  constructor() {\r\n    super();\r\n    this.on('move', this._onPointerMove);\r\n    this.on('down', this._onPointerDown);\r\n  }\r\n\r\n  on(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  on(event: string, handler: (event: any) => void): void {\r\n    super.on(event, handler);\r\n  }\r\n\r\n  once(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  once(event: string, handler: (event: any) => void): void {\r\n    super.once(event, handler);\r\n  }\r\n\r\n  off(event: 'move', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'down', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'up', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'wheel', handler?: (event: WheelEvent) => void): void;\r\n  off(event: string, handler?: (event: any) => void): void {\r\n    super.off(event, handler);\r\n  }\r\n\r\n  private _onPointerMove = (ev: PointerEvent): void => {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n  };\r\n\r\n  private _onPointerDown = (ev: PointerEvent): void => {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n  };\r\n}\r\n","\r\nexport enum WheelDeltaMode {\r\n  Pixel = 'Pixel',\r\n  Line = 'Line',\r\n  Page = 'Page'\r\n}\r\n","/**\r\n * Native browser button enumeration\r\n */\r\nexport enum NativePointerButton {\r\n  NoButton = -1,\r\n  Left = 0,\r\n  Middle = 1,\r\n  Right = 2,\r\n  Unknown = 3\r\n}\r\n","/**\r\n * The mouse button being pressed.\r\n */\r\nexport enum PointerButton {\r\n  Left = 'Left',\r\n  Middle = 'Middle',\r\n  Right = 'Right',\r\n  Unknown = 'Unknown',\r\n  NoButton = 'NoButton'\r\n}\r\n","/**\r\n * The type of pointer for a [[PointerEvent]].\r\n */\r\nexport enum PointerType {\r\n  Touch = 'Touch',\r\n  Mouse = 'Mouse',\r\n  Pen = 'Pen',\r\n  Unknown = 'Unknown'\r\n}\r\n","import { Class } from '../Class';\r\nimport { Engine, ScrollPreventionMode } from '../Engine';\r\nimport { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { PointerEvent } from './PointerEvent';\r\nimport { WheelEvent } from './WheelEvent';\r\nimport { PointerAbstraction } from './PointerAbstraction';\r\n\r\nimport { WheelDeltaMode } from './WheelDeltaMode';\r\nimport { PointerSystem } from './PointerSystem';\r\nimport { NativePointerButton } from './NativePointerButton';\r\nimport { PointerButton } from './PointerButton';\r\nimport { fail } from '../Util/Util';\r\nimport { PointerType } from './PointerType';\r\n\r\n\r\nexport type NativePointerEvent = globalThis.PointerEvent;\r\nexport type NativeMouseEvent = globalThis.MouseEvent;\r\nexport type NativeTouchEvent = globalThis.TouchEvent;\r\nexport type NativeWheelEvent = globalThis.WheelEvent;\r\n\r\n/**\r\n * Is this event a native touch event?\r\n */\r\nfunction isTouchEvent(value: any): value is NativeTouchEvent {\r\n  // Guard for Safari <= 13.1\r\n  return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;\r\n}\r\n\r\n/**\r\n * Is this event a native pointer event\r\n */\r\nfunction isPointerEvent(value: any): value is NativePointerEvent {\r\n  // Guard for Safari <= 13.1\r\n  return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;\r\n}\r\n\r\n/**\r\n * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates\r\n */\r\nexport class PointerEventReceiver extends Class {\r\n  public primary: PointerAbstraction = new PointerAbstraction();\r\n\r\n  private _activeNativePointerIdsToNormalized = new Map<number, number>();\r\n  public lastFramePointerCoords = new Map<number, GlobalCoordinates>();\r\n  public currentFramePointerCoords = new Map<number, GlobalCoordinates>();\r\n\r\n  public currentFramePointerDown = new Map<number, boolean>();\r\n  public lastFramePointerDown = new Map<number, boolean>();\r\n\r\n  public currentFrameDown: PointerEvent[] = [];\r\n  public currentFrameUp: PointerEvent[] = [];\r\n  public currentFrameMove: PointerEvent[] = [];\r\n  public currentFrameCancel: PointerEvent[] = [];\r\n  public currentFrameWheel: WheelEvent[] = [];\r\n\r\n  constructor(public readonly target: GlobalEventHandlers & EventTarget, public engine: Engine) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event\r\n   * handlers.\r\n   * @param target\r\n   * @param engine\r\n   */\r\n  public recreate(target: GlobalEventHandlers & EventTarget, engine: Engine) {\r\n    const eventReceiver = new PointerEventReceiver(target, engine);\r\n    eventReceiver.primary = this.primary;\r\n    eventReceiver._pointers = this._pointers;\r\n    return eventReceiver;\r\n  }\r\n\r\n  private _pointers: PointerAbstraction[] = [this.primary];\r\n  /**\r\n   * Locates a specific pointer by id, creates it if it doesn't exist\r\n   * @param index\r\n   */\r\n  public at(index: number): PointerAbstraction {\r\n    if (index >= this._pointers.length) {\r\n      // Ensure there is a pointer to retrieve\r\n      for (let i = this._pointers.length - 1, max = index; i < max; i++) {\r\n        this._pointers.push(new PointerAbstraction());\r\n      }\r\n    }\r\n    return this._pointers[index];\r\n  }\r\n\r\n  /**\r\n   * The number of pointers currently being tracked by excalibur\r\n   */\r\n  public count(): number {\r\n    return this._pointers.length;\r\n  }\r\n\r\n  /**\r\n   * Is the specified pointer id down this frame\r\n   * @param pointerId\r\n   */\r\n  public isDown(pointerId: number) {\r\n    return this.currentFramePointerDown.get(pointerId) ?? false;\r\n  }\r\n\r\n  /**\r\n   * Was the specified pointer id down last frame\r\n   * @param pointerId\r\n   */\r\n  public wasDown(pointerId: number) {\r\n    return this.lastFramePointerDown.get(pointerId) ?? false;\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer is currently dragging.\r\n   */\r\n  public isDragging(pointerId: number): boolean {\r\n    return this.isDown(pointerId);\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just started dragging.\r\n   */\r\n  public isDragStart(pointerId: number): boolean {\r\n    return this.isDown(pointerId) && !this.wasDown(pointerId);\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just ended dragging.\r\n   */\r\n  public isDragEnd(pointerId: number): boolean {\r\n    return !this.isDown(pointerId) && this.wasDown(pointerId);\r\n  }\r\n\r\n  on(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  on(event: string, handler: (event: any) => void): void {\r\n    super.on(event, handler);\r\n  }\r\n\r\n  once(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  once(event: string, handler: (event: any) => void): void {\r\n    super.once(event, handler);\r\n  }\r\n\r\n  off(event: 'move', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'down', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'up', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'wheel', handler?: (event: WheelEvent) => void): void;\r\n  off(event: string, handler?: (event: any) => void): void {\r\n    super.off(event, handler);\r\n  }\r\n\r\n  /**\r\n   * Called internally by excalibur\r\n   *\r\n   * Updates the current frame pointer info and emits raw pointer events\r\n   *\r\n   * This does not emit events to entities, see PointerSystem\r\n   */\r\n  public update() {\r\n    this.lastFramePointerDown = new Map(this.currentFramePointerDown);\r\n    this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);\r\n\r\n    for (const event of this.currentFrameDown) {\r\n      this.emit('down', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('down', event);\r\n      this.primary.emit('pointerdown', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameUp) {\r\n      this.emit('up', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('up', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameMove) {\r\n      this.emit('move', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('move', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameCancel) {\r\n      this.emit('cancel', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('cancel', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameWheel) {\r\n      this.emit('wheel', event);\r\n      this.primary.emit('pointerwheel', event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the current frame event and pointer data\r\n   */\r\n  public clear() {\r\n    for (const event of this.currentFrameUp) {\r\n      this.currentFramePointerCoords.delete(event.pointerId);\r\n      const ids = this._activeNativePointerIdsToNormalized.entries();\r\n      for (const [native, normalized] of ids) {\r\n        if (normalized === event.pointerId) {\r\n          this._activeNativePointerIdsToNormalized.delete(native);\r\n        }\r\n      }\r\n    }\r\n    this.currentFrameDown.length = 0;\r\n    this.currentFrameUp.length = 0;\r\n    this.currentFrameMove.length = 0;\r\n    this.currentFrameCancel.length = 0;\r\n    this.currentFrameWheel.length = 0;\r\n  }\r\n\r\n  private _boundHandle = this._handle.bind(this);\r\n  private _boundWheel = this._handleWheel.bind(this);\r\n  /**\r\n   * Initializes the pointer event receiver so that it can start listening to native\r\n   * browser events.\r\n   */\r\n  public init() {\r\n    // Disabling the touch action avoids browser/platform gestures from firing on the canvas\r\n    // It is important on mobile to have touch action 'none'\r\n    // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not\r\n    if (this.target === this.engine.canvas) {\r\n      this.engine.canvas.style.touchAction = 'none';\r\n    } else {\r\n      document.body.style.touchAction = 'none';\r\n    }\r\n    // Preferred pointer events\r\n    if (window.PointerEvent) {\r\n      this.target.addEventListener('pointerdown', this._boundHandle);\r\n      this.target.addEventListener('pointerup', this._boundHandle);\r\n      this.target.addEventListener('pointermove', this._boundHandle);\r\n      this.target.addEventListener('pointercancel', this._boundHandle);\r\n    } else {\r\n      // Touch Events\r\n      this.target.addEventListener('touchstart', this._boundHandle);\r\n      this.target.addEventListener('touchend', this._boundHandle);\r\n      this.target.addEventListener('touchmove', this._boundHandle);\r\n      this.target.addEventListener('touchcancel', this._boundHandle);\r\n\r\n      // Mouse Events\r\n      this.target.addEventListener('mousedown', this._boundHandle);\r\n      this.target.addEventListener('mouseup', this._boundHandle);\r\n      this.target.addEventListener('mousemove', this._boundHandle);\r\n    }\r\n\r\n    // MDN MouseWheelEvent\r\n    const wheelOptions = {\r\n      passive: !(\r\n        this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n        this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas\r\n      )\r\n    };\r\n    if ('onwheel' in document.createElement('div')) {\r\n      // Modern Browsers\r\n      this.target.addEventListener('wheel', this._boundWheel, wheelOptions);\r\n    } else if (document.onmousewheel !== undefined) {\r\n      // Webkit and IE\r\n      this.target.addEventListener('mousewheel', this._boundWheel, wheelOptions);\r\n    } else {\r\n      // Remaining browser and older Firefox\r\n      this.target.addEventListener('MozMousePixelScroll', this._boundWheel, wheelOptions);\r\n    }\r\n  }\r\n\r\n  public detach() {\r\n    // Preferred pointer events\r\n    if (window.PointerEvent) {\r\n      this.target.removeEventListener('pointerdown', this._boundHandle);\r\n      this.target.removeEventListener('pointerup', this._boundHandle);\r\n      this.target.removeEventListener('pointermove', this._boundHandle);\r\n      this.target.removeEventListener('pointercancel', this._boundHandle);\r\n    } else {\r\n      // Touch Events\r\n      this.target.removeEventListener('touchstart', this._boundHandle);\r\n      this.target.removeEventListener('touchend', this._boundHandle);\r\n      this.target.removeEventListener('touchmove', this._boundHandle);\r\n      this.target.removeEventListener('touchcancel', this._boundHandle);\r\n\r\n      // Mouse Events\r\n      this.target.removeEventListener('mousedown', this._boundHandle);\r\n      this.target.removeEventListener('mouseup', this._boundHandle);\r\n      this.target.removeEventListener('mousemove', this._boundHandle);\r\n    }\r\n\r\n    if ('onwheel' in document.createElement('div')) {\r\n      // Modern Browsers\r\n      this.target.removeEventListener('wheel', this._boundWheel);\r\n    } else if (document.onmousewheel !== undefined) {\r\n      // Webkit and IE\r\n      this.target.addEventListener('mousewheel', this._boundWheel);\r\n    } else {\r\n      // Remaining browser and older Firefox\r\n      this.target.addEventListener('MozMousePixelScroll', this._boundWheel);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Take native pointer id and map it to index in active pointers\r\n   * @param nativePointerId\r\n   */\r\n  private _normalizePointerId(nativePointerId: number) {\r\n    // Add to the the native pointer set id\r\n    this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);\r\n\r\n    // Native pointer ids in ascending order\r\n    const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);\r\n\r\n    // The index into sorted ids will be the new id, will always have an id\r\n    const id = currentPointerIds.findIndex(p => p === nativePointerId);\r\n\r\n    // Save the mapping so we can reverse it later\r\n    this._activeNativePointerIdsToNormalized.set(nativePointerId, id);\r\n\r\n    // ignore pointer because game isn't watching\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Responsible for handling and parsing pointer events\r\n   */\r\n  private _handle(ev: NativeTouchEvent | NativePointerEvent | NativeMouseEvent) {\r\n    ev.preventDefault();\r\n    const eventCoords = new Map<number, GlobalCoordinates>();\r\n    let button: PointerButton;\r\n    let pointerType: PointerType;\r\n    if (isTouchEvent(ev)) {\r\n      button = PointerButton.Unknown;\r\n      pointerType = PointerType.Touch;\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\r\n      for (let i = 0; i < ev.changedTouches.length; i++) {\r\n        const touch = ev.changedTouches[i];\r\n        const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);\r\n        const nativePointerId = i + 1;\r\n        const pointerId = this._normalizePointerId(nativePointerId);\r\n        this.currentFramePointerCoords.set(pointerId, coordinates);\r\n        eventCoords.set(pointerId, coordinates);\r\n      }\r\n    } else {\r\n      button = this._nativeButtonToPointerButton(ev.button);\r\n      pointerType = PointerType.Mouse;\r\n      const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);\r\n      let nativePointerId = 1;\r\n      if (isPointerEvent(ev)) {\r\n        nativePointerId = ev.pointerId;\r\n        pointerType = this._stringToPointerType(ev.pointerType);\r\n      }\r\n      const pointerId = this._normalizePointerId(nativePointerId);\r\n      this.currentFramePointerCoords.set(pointerId, coordinates);\r\n      eventCoords.set(pointerId, coordinates);\r\n    }\r\n\r\n    for (const [pointerId, coord] of eventCoords.entries()) {\r\n      switch (ev.type) {\r\n        case 'mousedown':\r\n        case 'pointerdown':\r\n        case 'touchstart':\r\n          this.currentFrameDown.push(new PointerEvent('down', pointerId, button, pointerType, coord, ev));\r\n          this.currentFramePointerDown.set(pointerId, true);\r\n          break;\r\n        case 'mouseup':\r\n        case 'pointerup':\r\n        case 'touchend':\r\n          this.currentFrameUp.push(new PointerEvent('up', pointerId, button, pointerType, coord, ev));\r\n          this.currentFramePointerDown.set(pointerId, false);\r\n          break;\r\n        case 'mousemove':\r\n        case 'pointermove':\r\n        case 'touchmove':\r\n          this.currentFrameMove.push(new PointerEvent('move', pointerId, button, pointerType, coord, ev));\r\n          break;\r\n        case 'touchcancel':\r\n        case 'pointercancel':\r\n          this.currentFrameCancel.push(new PointerEvent('cancel', pointerId, button, pointerType, coord, ev));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _handleWheel(ev: NativeWheelEvent) {\r\n    // Should we prevent page scroll because of this event\r\n    if (\r\n      this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n      (this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas)\r\n    ) {\r\n      ev.preventDefault();\r\n    }\r\n    const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));\r\n    const world = this.engine.screen.screenToWorldCoordinates(screen);\r\n\r\n    /**\r\n     * A constant used to normalize wheel events across different browsers\r\n     *\r\n     * This normalization factor is pulled from\r\n     * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser\r\n     */\r\n    const ScrollWheelNormalizationFactor = -1 / 40;\r\n\r\n    const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;\r\n    const deltaY =\r\n        ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;\r\n    const deltaZ = ev.deltaZ || 0;\r\n    let deltaMode = WheelDeltaMode.Pixel;\r\n\r\n    if (ev.deltaMode) {\r\n      if (ev.deltaMode === 1) {\r\n        deltaMode = WheelDeltaMode.Line;\r\n      } else if (ev.deltaMode === 2) {\r\n        deltaMode = WheelDeltaMode.Page;\r\n      }\r\n    }\r\n\r\n    const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);\r\n    this.currentFrameWheel.push(we);\r\n  }\r\n\r\n  /**\r\n   * Triggers an excalibur pointer event in a world space pos\r\n   *\r\n   * Useful for testing pointers in excalibur\r\n   * @param type\r\n   * @param pos\r\n   */\r\n  public triggerEvent(type: 'down' | 'up' | 'move' | 'cancel', pos: Vector) {\r\n    const page = this.engine.screen.worldToPageCoordinates(pos);\r\n    // Send an event to the event receiver\r\n    if (window.PointerEvent) {\r\n      this._handle(new window.PointerEvent('pointer' + type, {\r\n        pointerId: 0,\r\n        clientX: page.x,\r\n        clientY: page.y\r\n      }));\r\n    } else {\r\n      // Safari hack\r\n      this._handle(new window.MouseEvent('mouse' + type, {\r\n        clientX: page.x,\r\n        clientY: page.y\r\n      }));\r\n    }\r\n\r\n    // Force update pointer system\r\n    const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);\r\n    const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);\r\n    pointerSystem.preupdate();\r\n    pointerSystem.update(transformEntities.getEntities());\r\n  }\r\n\r\n  private _nativeButtonToPointerButton(s: NativePointerButton): PointerButton {\r\n    switch (s) {\r\n      case NativePointerButton.NoButton:\r\n        return PointerButton.NoButton;\r\n      case NativePointerButton.Left:\r\n        return PointerButton.Left;\r\n      case NativePointerButton.Middle:\r\n        return PointerButton.Middle;\r\n      case NativePointerButton.Right:\r\n        return PointerButton.Right;\r\n      case NativePointerButton.Unknown:\r\n        return PointerButton.Unknown;\r\n      default:\r\n        return fail(s);\r\n    }\r\n  }\r\n\r\n  private _stringToPointerType(s: string) {\r\n    switch (s) {\r\n      case 'touch':\r\n        return PointerType.Touch;\r\n      case 'mouse':\r\n        return PointerType.Mouse;\r\n      case 'pen':\r\n        return PointerType.Pen;\r\n      default:\r\n        return PointerType.Unknown;\r\n    }\r\n  }\r\n}","export interface FpsSamplerOptions {\r\n  /**\r\n   * Specify the sampling period in milliseconds (default 100)\r\n   */\r\n  samplePeriod?: number;\r\n  /**\r\n   * Specify the initial FPS\r\n   */\r\n  initialFps: number;\r\n\r\n  /**\r\n   * Specify the function used to return the current time (in milliseconds)\r\n   */\r\n  nowFn: () => number;\r\n}\r\n\r\nexport class FpsSampler {\r\n  private _fps: number;\r\n  private _samplePeriod: number = 100;\r\n  private _currentFrameTime: number = 0;\r\n  private _frames: number = 0;\r\n  private _previousSampleTime: number = 0;\r\n  private _beginFrameTime: number = 0;\r\n  private _nowFn: () => number;\r\n\r\n  constructor(options: FpsSamplerOptions) {\r\n    this._fps = options.initialFps;\r\n    this._samplePeriod = options.samplePeriod ?? this._samplePeriod;\r\n    this._currentFrameTime = 1000/options.initialFps;\r\n    this._nowFn = options.nowFn;\r\n    this._previousSampleTime = this._nowFn();\r\n  }\r\n\r\n  /**\r\n   * Start of code block to sample FPS for\r\n   */\r\n  start() {\r\n    this._beginFrameTime = this._nowFn();\r\n  }\r\n\r\n  /**\r\n   * End of code block to sample FPS for\r\n   */\r\n  end() {\r\n    this._frames++;\r\n    const time = this._nowFn();\r\n\r\n    this._currentFrameTime = time - this._beginFrameTime;\r\n\r\n    if (time >= this._previousSampleTime + this._samplePeriod) {\r\n      this._fps = (this._frames * 1000) / (time - this._previousSampleTime);\r\n      this._previousSampleTime = time;\r\n      this._frames = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the currently sampled fps over the last sample period, by default every 100ms\r\n   */\r\n  get fps() {\r\n    return this._fps;\r\n  }\r\n\r\n  /**\r\n   * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time\r\n   */\r\n  get instant() {\r\n    return 1000 / this._currentFrameTime;\r\n  }\r\n}","import { Logger } from '..';\r\nimport { FpsSampler } from './Fps';\r\n\r\nexport interface ClockOptions {\r\n  /**\r\n   * Define the function you'd like the clock to tick when it is started\r\n   */\r\n  tick: (elapsedMs: number) => any;\r\n  /**\r\n   * Optionally define the fatal exception handler, used if an error is thrown in tick\r\n   */\r\n  onFatalException?: (e: unknown) => any;\r\n  /**\r\n   * Optionally limit the maximum FPS of the clock\r\n   */\r\n  maxFps?: number;\r\n}\r\n\r\n\r\n/**\r\n * Abstract Clock is the base type of all Clocks\r\n *\r\n * It has a few opinions\r\n * 1. It manages the calculation of what \"elapsed\" time means and thus maximum fps\r\n * 2. The default timing api is implemented in now()\r\n *\r\n * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever\r\n * method is unique to your clock implementation.\r\n */\r\nexport abstract class Clock {\r\n  protected tick: (elapsedMs: number) => any;\r\n  private _onFatalException: (e: unknown) => any = () => { /* default nothing */ };\r\n  private _maxFps: number = Infinity;\r\n  private _lastTime: number = 0;\r\n  public fpsSampler: FpsSampler;\r\n  private _options: ClockOptions;\r\n  private _elapsed: number = 1;\r\n  private _scheduledCbs: [cb: () => any, scheduledTime: number][] = [];\r\n  private _totalElapsed: number = 0;\r\n  constructor(options: ClockOptions) {\r\n    this._options = options;\r\n    this.tick = options.tick;\r\n    this._lastTime = this.now() ?? 0;\r\n    this._maxFps = options.maxFps ?? this._maxFps;\r\n    this._onFatalException = options.onFatalException ?? this._onFatalException;\r\n    this.fpsSampler = new FpsSampler({\r\n      initialFps: 60,\r\n      nowFn: () => this.now()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the elapsed time for the last completed frame\r\n   */\r\n  public elapsed(): number {\r\n    return this._elapsed;\r\n  }\r\n\r\n  /**\r\n   * Get the current time in milliseconds\r\n   */\r\n  public now(): number {\r\n    return performance.now();\r\n  }\r\n\r\n  public toTestClock() {\r\n    const testClock = new TestClock({\r\n      ...this._options,\r\n      defaultUpdateMs: 16.6\r\n    });\r\n    return testClock;\r\n  }\r\n\r\n  public toStandardClock() {\r\n    const clock = new StandardClock({\r\n      ...this._options\r\n    });\r\n    return clock;\r\n  }\r\n\r\n  public setFatalExceptionHandler(handler: (e: unknown) => any) {\r\n    this._onFatalException = handler;\r\n  }\r\n\r\n  /**\r\n   * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]\r\n   *\r\n   * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the\r\n   * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is\r\n   * stopped or paused.\r\n   *\r\n   * @param cb callback to fire\r\n   * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick\r\n   */\r\n  public schedule(cb: () => any, timeoutMs: number = 0) {\r\n    // Scheduled based on internal elapsed time\r\n    const scheduledTime = this._totalElapsed + timeoutMs;\r\n    this._scheduledCbs.push([cb, scheduledTime]);\r\n  }\r\n\r\n  private _runScheduledCbs() {\r\n    // walk backwards to delete items as we loop\r\n    for (let i = this._scheduledCbs.length - 1; i > -1; i--) {\r\n      if (this._scheduledCbs[i][1] <= this._totalElapsed) {\r\n        this._scheduledCbs[i][0]();\r\n        this._scheduledCbs.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected update(overrideUpdateMs?: number): void {\r\n    try {\r\n      this.fpsSampler.start();\r\n      // Get the time to calculate time-elapsed\r\n      const now = this.now();\r\n      let elapsed = now - this._lastTime || 1; // first frame\r\n\r\n      // Constrain fps\r\n      const fpsInterval = (1000 / this._maxFps);\r\n\r\n      // only run frame if enough time has elapsed\r\n      if (elapsed >= fpsInterval) {\r\n        let leftover = 0;\r\n        if (fpsInterval !== 0) {\r\n          leftover = (elapsed % fpsInterval);\r\n          elapsed = elapsed - leftover; // shift elapsed to be \"in phase\" with the current loop fps\r\n        }\r\n\r\n        // Resolves issue #138 if the game has been paused, or blurred for\r\n        // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability\r\n        // and provides more expected behavior when the engine comes back\r\n        // into focus\r\n        if (elapsed > 200) {\r\n          elapsed = 1;\r\n        }\r\n\r\n        // tick the mainloop and run scheduled callbacks\r\n        this._elapsed = overrideUpdateMs || elapsed;\r\n        this._totalElapsed += this._elapsed;\r\n        this._runScheduledCbs();\r\n        this.tick(overrideUpdateMs || elapsed);\r\n\r\n        if (fpsInterval !== 0) {\r\n          this._lastTime = now - leftover;\r\n        } else {\r\n          this._lastTime = now;\r\n        }\r\n        this.fpsSampler.end();\r\n      }\r\n    } catch (e) {\r\n      this._onFatalException(e);\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns if the clock is currently running\r\n   */\r\n  public abstract isRunning(): boolean;\r\n\r\n  /**\r\n   * Start the clock, it will then periodically call the tick(elapsedMilliseconds) since the last tick\r\n   */\r\n  public abstract start(): void;\r\n\r\n  /**\r\n   * Stop the clock, tick() is no longer called\r\n   */\r\n  public abstract stop(): void;\r\n}\r\n\r\n\r\n/**\r\n * The [[StandardClock]] implements the requestAnimationFrame browser api to run the tick()\r\n */\r\nexport class StandardClock extends Clock {\r\n\r\n  private _running = false;\r\n  private _requestId: number;\r\n  constructor(options: ClockOptions) {\r\n    super(options);\r\n  }\r\n\r\n  public isRunning(): boolean {\r\n    return this._running;\r\n  }\r\n\r\n  public start(): void {\r\n    if (this._running) {\r\n      return;\r\n    }\r\n    this._running = true;\r\n    const mainloop = () => {\r\n      // stop the loop\r\n      if (!this._running) {\r\n        return;\r\n      }\r\n      try {\r\n        // request next loop\r\n        this._requestId = window.requestAnimationFrame(mainloop);\r\n        this.update();\r\n      } catch (e) {\r\n        window.cancelAnimationFrame(this._requestId);\r\n        throw e;\r\n      }\r\n    };\r\n\r\n    // begin the first frame\r\n    mainloop();\r\n  }\r\n\r\n  public stop(): void {\r\n    this._running = false;\r\n  }\r\n}\r\n\r\nexport interface TestClockOptions {\r\n  /**\r\n   * Specify the update milliseconds to use for each manual step()\r\n   */\r\n  defaultUpdateMs: number;\r\n}\r\n\r\n/**\r\n * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test\r\n */\r\nexport class TestClock extends Clock {\r\n  private _logger = Logger.getInstance();\r\n  private _updateMs: number;\r\n  private _running: boolean = false;\r\n  private _currentTime = 0;\r\n  constructor(options: ClockOptions & TestClockOptions) {\r\n    super({\r\n      ...options\r\n    });\r\n    this._updateMs = options.defaultUpdateMs;\r\n  }\r\n\r\n  /**\r\n   * Get the current time in milliseconds\r\n   */\r\n  public override now() {\r\n    return this._currentTime ?? 0;\r\n  }\r\n\r\n  public isRunning(): boolean {\r\n    return this._running;\r\n  }\r\n  public start(): void {\r\n    this._running = true;\r\n  }\r\n  public stop(): void {\r\n    this._running = false;\r\n  }\r\n\r\n  /**\r\n   * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds\r\n   * @param overrideUpdateMs\r\n   */\r\n  step(overrideUpdateMs?: number): void {\r\n    const time = overrideUpdateMs ?? this._updateMs;\r\n\r\n    if (this._running) {\r\n      // to be comparable to RAF this needs to be a full blown Task\r\n      // For example, images cannot decode synchronously in a single step\r\n      this.update(time);\r\n      this._currentTime += time;\r\n    } else {\r\n      this._logger.warn('The clock is not running, no step will be performed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds\r\n   * @param numberOfSteps\r\n   * @param overrideUpdateMs\r\n   */\r\n  run(numberOfSteps: number, overrideUpdateMs?: number): void {\r\n    for (let i = 0; i < numberOfSteps; i++) {\r\n      this.step(overrideUpdateMs ?? this._updateMs);\r\n    }\r\n  }\r\n}","import toasterCss from './Toaster.css';\r\n\r\n/**\r\n * The Toaster is only meant to be called from inside Excalibur to display messages to players\r\n */\r\nexport class Toaster {\r\n  private _styleBlock: HTMLStyleElement;\r\n  private _container: HTMLDivElement;\r\n  private _toasterCss: string = toasterCss.toString();\r\n\r\n  private _isInitialized = false;\r\n  private _initialize() {\r\n    if (!this._isInitialized) {\r\n      this._container = document.createElement('div');\r\n      this._container.id = 'ex-toast-container';\r\n      document.body.appendChild(this._container);\r\n      this._isInitialized = true;\r\n\r\n      this._styleBlock = document.createElement('style');\r\n      this._styleBlock.textContent = this._toasterCss;\r\n      document.head.appendChild(this._styleBlock);\r\n    }\r\n  }\r\n\r\n  public dispose() {\r\n    this._container.parentElement.removeChild(this._container);\r\n\r\n    this._styleBlock.parentElement.removeChild(this._styleBlock);\r\n\r\n    this._isInitialized = false;\r\n  }\r\n\r\n  private _createFragment(message: string) {\r\n    const toastMessage = document.createElement('span');\r\n    toastMessage.innerText = message;\r\n    return toastMessage;\r\n  }\r\n\r\n  /**\r\n   * Display a toast message to a player\r\n   * @param message Text of the message, messages may have a single \"[LINK]\" to influence placement\r\n   * @param linkTarget Optionally specify a link location\r\n   * @param linkName Optionally specify a name for that link location\r\n   */\r\n  public toast(message: string, linkTarget?: string, linkName?: string) {\r\n    this._initialize();\r\n    const toast = document.createElement('div');\r\n    toast.className = 'ex-toast-message';\r\n\r\n    const messageFragments: HTMLElement[] = message.split('[LINK]').map(message => this._createFragment(message));\r\n\r\n    if (linkTarget) {\r\n      const link = document.createElement('a');\r\n      link.href = linkTarget;\r\n      if (linkName) {\r\n        link.innerText = linkName;\r\n      } else {\r\n        link.innerText = linkTarget;\r\n      }\r\n      messageFragments.splice(1, 0, link);\r\n    }\r\n\r\n    // Assembly message\r\n    const finalMessage = document.createElement('div');\r\n    messageFragments.forEach(message => {\r\n      finalMessage.appendChild(message);\r\n    });\r\n    toast.appendChild(finalMessage);\r\n\r\n    // Dismiss button\r\n    const dismissBtn = document.createElement('button');\r\n    dismissBtn.innerText = 'x';\r\n    dismissBtn.addEventListener('click', () => {\r\n      this._container.removeChild(toast);\r\n    });\r\n    toast.appendChild(dismissBtn);\r\n\r\n    // Escape to dismiss\r\n    const keydownHandler = (evt: KeyboardEvent) => {\r\n      if (evt.key === 'Escape') {\r\n        try {\r\n          this._container.removeChild(toast);\r\n        } catch {\r\n          // pass\r\n        }\r\n      }\r\n      document.removeEventListener('keydown', keydownHandler);\r\n    };\r\n    document.addEventListener('keydown', keydownHandler);\r\n\r\n    // Insert into container\r\n    const first = this._container.firstChild;\r\n    this._container.insertBefore(toast, first);\r\n  }\r\n}","import { EX_VERSION } from './';\r\nimport { Flags } from './Flags';\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\nimport { CanUpdate, CanDraw, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Vector } from './Math/vector';\r\nimport { Screen, DisplayMode, ScreenDimension, Resolution } from './Screen';\r\nimport { ScreenElement } from './ScreenElement';\r\nimport { Actor } from './Actor';\r\nimport { Timer } from './Timer';\r\nimport { TileMap } from './TileMap';\r\nimport { Loader } from './Loader';\r\nimport { Detector } from './Util/Detector';\r\nimport {\r\n  VisibleEvent,\r\n  HiddenEvent,\r\n  GameStartEvent,\r\n  GameStopEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreFrameEvent,\r\n  PostFrameEvent,\r\n  GameEvent,\r\n  DeactivateEvent,\r\n  ActivateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  InitializeEvent\r\n} from './Events';\r\nimport { Logger, LogLevel } from './Util/Log';\r\nimport { Color } from './Color';\r\nimport { Scene } from './Scene';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { Debug, DebugStats } from './Debug/Debug';\r\nimport { Class } from './Class';\r\nimport * as Input from './Input/Index';\r\nimport * as Events from './Events';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { ExcaliburGraphicsContext, ExcaliburGraphicsContext2DCanvas, ExcaliburGraphicsContextWebGL, TextureLoader } from './Graphics';\r\nimport { PointerEventReceiver } from './Input/PointerEventReceiver';\r\nimport { Clock, StandardClock } from './Util/Clock';\r\nimport { ImageFiltering } from './Graphics/Filtering';\r\nimport { GraphicsDiagnostics } from './Graphics/GraphicsDiagnostics';\r\nimport { Toaster } from './Util/Toaster';\r\n\r\n/**\r\n * Enum representing the different mousewheel event bubble prevention\r\n */\r\nexport enum ScrollPreventionMode {\r\n  /**\r\n   * Do not prevent any page scrolling\r\n   */\r\n  None,\r\n  /**\r\n   * Prevent page scroll if mouse is over the game canvas\r\n   */\r\n  Canvas,\r\n  /**\r\n   * Prevent all page scrolling via mouse wheel\r\n   */\r\n  All\r\n}\r\n\r\n/**\r\n * Defines the available options to configure the Excalibur engine at constructor time.\r\n */\r\nexport interface EngineOptions {\r\n  /**\r\n   * Optionally configure the width of the viewport in css pixels\r\n   */\r\n  width?: number;\r\n\r\n  /**\r\n   * Optionally configure the height of the viewport in css pixels\r\n   */\r\n  height?: number;\r\n\r\n  /**\r\n   * Optionally configure the width & height of the viewport in css pixels.\r\n   * Use `viewport` instead of [[EngineOptions.width]] and [[EngineOptions.height]], or vice versa.\r\n   */\r\n  viewport?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify the size the logical pixel resolution, if not specified it will be width x height.\r\n   * See [[Resolution]] for common presets.\r\n   */\r\n  resolution?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify antialiasing (smoothing), by default true (smooth pixels)\r\n   *\r\n   *  * `true` - useful for high resolution art work you would like smoothed, this also hints excalibur to load images\r\n   * with [[ImageFiltering.Blended]]\r\n   *\r\n   *  * `false` - useful for pixel art style art work you would like sharp, this also hints excalibur to load images\r\n   * with [[ImageFiltering.Pixel]]\r\n   */\r\n  antialiasing?: boolean;\r\n\r\n  /**\r\n   * Optionally upscale the number of pixels in the canvas. Normally only useful if you need a smoother look to your assets, especially\r\n   * [[Text]].\r\n   *\r\n   * **WARNING** It is recommended you try using `antialiasing: true` before adjusting pixel ratio. Pixel ratio will consume more memory\r\n   * and on mobile may break if the internal size of the canvas exceeds 4k pixels in width or height.\r\n   *\r\n   * Default is based the display's pixel ratio, for example a HiDPI screen might have the value 2;\r\n   */\r\n  pixelRatio?: number;\r\n\r\n  /**\r\n   * Optionally configure the native canvas transparent backdrop\r\n   */\r\n  enableCanvasTransparency?: boolean;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element to render the game in\r\n   */\r\n  canvasElementId?: string;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element directly\r\n   */\r\n  canvasElement?: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Optionally snap graphics to nearest pixel, default is false\r\n   */\r\n  snapToPixel?: boolean;\r\n\r\n  /**\r\n   * The [[DisplayMode]] of the game, by default [[DisplayMode.FitScreen]] with aspect ratio 4:3 (800x600).\r\n   * Depending on this value, [[width]] and [[height]] may be ignored.\r\n   */\r\n  displayMode?: DisplayMode;\r\n\r\n  /**\r\n   * Configures the pointer scope. Pointers scoped to the 'Canvas' can only fire events within the canvas viewport; whereas, 'Document'\r\n   * (default) scoped will fire anywhere on the page.\r\n   */\r\n  pointerScope?: Input.PointerScope;\r\n\r\n  /**\r\n   * Suppress boot up console message, which contains the \"powered by Excalibur message\"\r\n   */\r\n  suppressConsoleBootMessage?: boolean;\r\n\r\n  /**\r\n   * Suppress minimum browser feature detection, it is not recommended users of excalibur switch this off. This feature ensures that\r\n   * the currently running browser meets the minimum requirements for running excalibur. This can be useful if running on non-standard\r\n   * browsers or if there is a bug in excalibur preventing execution.\r\n   */\r\n  suppressMinimumBrowserFeatureDetection?: boolean;\r\n\r\n  /**\r\n   * Suppress HiDPI auto detection and scaling, it is not recommended users of excalibur switch off this feature. This feature detects\r\n   * and scales the drawing canvas appropriately to accommodate HiDPI screens.\r\n   */\r\n  suppressHiDPIScaling?: boolean;\r\n\r\n  /**\r\n   * Suppress play button, it is not recommended users of excalibur switch this feature. Some browsers require a user gesture (like a click)\r\n   * for certain browser features to work like web audio.\r\n   */\r\n  suppressPlayButton?: boolean;\r\n\r\n  /**\r\n   * Scroll prevention method.\r\n   */\r\n  scrollPreventionMode?: ScrollPreventionMode;\r\n\r\n  /**\r\n   * Optionally set the background color\r\n   */\r\n  backgroundColor?: Color;\r\n\r\n  /**\r\n   * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n   *\r\n   * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n   * one that bounces between 30fps and 60fps\r\n   */\r\n  maxFps?: number;\r\n\r\n  /**\r\n   * Optionally configure a fixed update fps, this can be desireable if you need the physics simulation to be very stable. When set\r\n   * the update step and physics will use the same elapsed time for each tick even if the graphical framerate drops. In order for the\r\n   * simulation to be correct, excalibur will run multiple updates in a row (at the configured update elapsed) to catch up, for example\r\n   * there could be X updates and 1 draw each clock step.\r\n   *\r\n   * **NOTE:** This does come at a potential perf cost because each catch-up update will need to be run if the fixed rate is greater than\r\n   * the current instantaneous framerate, or perf gain if the fixed rate is less than the current framerate.\r\n   *\r\n   * By default is unset and updates will use the current instantaneous framerate with 1 update and 1 draw each clock step.\r\n   */\r\n  fixedUpdateFps?: number\r\n\r\n  /**\r\n   * Default `true`, optionally configure excalibur to use optimal draw call sorting, to opt out set this to `false`.\r\n   *\r\n   * Excalibur will automatically sort draw calls by z and priority into renderer batches for maximal draw performance,\r\n   * this can disrupt a specific desired painter order.\r\n   */\r\n  useDrawSorting?: boolean;\r\n\r\n  /**\r\n   * Optionally configure how excalibur handles poor performance on a player's browser\r\n   */\r\n  configurePerformanceCanvas2DFallback?: {\r\n    /**\r\n     * By default `true`, this will switch the internal graphics context to Canvas2D which can improve performance on non hardware\r\n     * accelerated browsers.\r\n     */\r\n    allow: boolean;\r\n    /**\r\n     * By default `false`, if set to `true` a dialogue will be presented to the player about their browser and how to potentially\r\n     * address any issues.\r\n     */\r\n    showPlayerMessage?: boolean;\r\n    /**\r\n     * Default `{ numberOfFrames: 100, fps: 20 }`, optionally configure excalibur to fallback to the 2D Canvas renderer\r\n     * if bad performance is detected.\r\n     *\r\n     * In this example of the default if excalibur is running at 20fps or less for 100 frames it will trigger the fallback to the 2D\r\n     * Canvas renderer.\r\n     */\r\n    threshold?: { numberOfFrames: number, fps: number };\r\n  }\r\n}\r\n\r\n/**\r\n * The Excalibur Engine\r\n *\r\n * The [[Engine]] is the main driver for a game. It is responsible for\r\n * starting/stopping the game, maintaining state, transmitting events,\r\n * loading resources, and managing the scene.\r\n */\r\nexport class Engine extends Class implements CanInitialize, CanUpdate, CanDraw {\r\n  /**\r\n   * Excalibur browser events abstraction used for wiring to native browser events safely\r\n   */\r\n  public browser: BrowserEvents;\r\n\r\n  /**\r\n   * Screen abstraction\r\n   */\r\n  public screen: Screen;\r\n\r\n  /**\r\n   * Direct access to the engine's canvas element\r\n   */\r\n  public canvas: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Direct access to the ExcaliburGraphicsContext used for drawing things to the screen\r\n   */\r\n  public graphicsContext: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Direct access to the canvas element ID, if an ID exists\r\n   */\r\n  public canvasElementId: string;\r\n\r\n  /**\r\n   * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n   *\r\n   * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n   * one that bounces between 30fps and 60fps\r\n   */\r\n  public maxFps: number = Number.POSITIVE_INFINITY;\r\n\r\n  /**\r\n   * Optionally configure a fixed update fps, this can be desireable if you need the physics simulation to be very stable. When set\r\n   * the update step and physics will use the same elapsed time for each tick even if the graphical framerate drops. In order for the\r\n   * simulation to be correct, excalibur will run multiple updates in a row (at the configured update elapsed) to catch up, for example\r\n   * there could be X updates and 1 draw each clock step.\r\n   *\r\n   * **NOTE:** This does come at a potential perf cost because each catch-up update will need to be run if the fixed rate is greater than\r\n   * the current instantaneous framerate, or perf gain if the fixed rate is less than the current framerate.\r\n   *\r\n   * By default is unset and updates will use the current instantaneous framerate with 1 update and 1 draw each clock step.\r\n   */\r\n  public fixedUpdateFps?: number;\r\n\r\n  /**\r\n   * Direct access to the excalibur clock\r\n   */\r\n  public clock: Clock;\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.screen.canvasWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.screen.halfCanvasWidth;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.screen.canvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.screen.halfCanvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    return this.screen.drawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.screen.halfDrawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    return this.screen.drawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.screen.halfDrawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns whether excalibur detects the current screen to be HiDPI\r\n   */\r\n  public get isHiDpi(): boolean {\r\n    return this.screen.isHiDpi;\r\n  }\r\n\r\n  /**\r\n   * Access engine input like pointer, keyboard, or gamepad\r\n   */\r\n  public input: Input.EngineInput;\r\n\r\n  /**\r\n   * Access Excalibur debugging functionality.\r\n   *\r\n   * Useful when you want to debug different aspects of built in engine features like\r\n   *   * Transform\r\n   *   * Graphics\r\n   *   * Colliders\r\n   */\r\n  public debug: Debug;\r\n\r\n  /**\r\n   * Access [[stats]] that holds frame statistics.\r\n   */\r\n  public get stats(): DebugStats {\r\n    return this.debug.stats;\r\n  }\r\n\r\n  /**\r\n   * The current [[Scene]] being drawn and updated on screen\r\n   */\r\n  public currentScene: Scene;\r\n\r\n  /**\r\n   * The default [[Scene]] of the game, use [[Engine.goToScene]] to transition to different scenes.\r\n   */\r\n  public readonly rootScene: Scene;\r\n\r\n  /**\r\n   * Contains all the scenes currently registered with Excalibur\r\n   */\r\n  public readonly scenes: { [key: string]: Scene } = {};\r\n\r\n  /**\r\n   * Indicates whether the engine is set to fullscreen or not\r\n   */\r\n  public get isFullscreen(): boolean {\r\n    return this.screen.isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Indicates the current [[DisplayMode]] of the engine.\r\n   */\r\n  public get displayMode(): DisplayMode {\r\n    return this.screen.displayMode;\r\n  }\r\n\r\n  private _suppressPlayButton: boolean = false;\r\n  /**\r\n   * Returns the calculated pixel ration for use in rendering\r\n   */\r\n  public get pixelRatio(): number {\r\n    return this.screen.pixelRatio;\r\n  }\r\n\r\n  /**\r\n   * Indicates whether audio should be paused when the game is no longer visible.\r\n   */\r\n  public pauseAudioWhenHidden: boolean = true;\r\n\r\n  /**\r\n   * Indicates whether the engine should draw with debug information\r\n   */\r\n  private _isDebug: boolean = false;\r\n  public get isDebug(): boolean {\r\n    return this._isDebug;\r\n  }\r\n\r\n  /**\r\n   * Sets the background color for the engine.\r\n   */\r\n  public backgroundColor: Color;\r\n\r\n  /**\r\n   * Sets the Transparency for the engine.\r\n   */\r\n  public enableCanvasTransparency: boolean = true;\r\n\r\n  /**\r\n   * Hints the graphics context to truncate fractional world space coordinates\r\n   */\r\n  public get snapToPixel(): boolean {\r\n    return this.graphicsContext.snapToPixel;\r\n  };\r\n\r\n  public set snapToPixel(shouldSnapToPixel: boolean) {\r\n    this.graphicsContext.snapToPixel = shouldSnapToPixel;\r\n  };\r\n\r\n  /**\r\n   * The action to take when a fatal exception is thrown\r\n   */\r\n  public onFatalException = (e: any) => {\r\n    Logger.getInstance().fatal(e);\r\n  };\r\n\r\n  /**\r\n   * The mouse wheel scroll prevention mode\r\n   */\r\n  public pageScrollPreventionMode: ScrollPreventionMode;\r\n\r\n  private _logger: Logger;\r\n\r\n  private _toaster: Toaster = new Toaster();\r\n\r\n  // this determines whether excalibur is compatible with your browser\r\n  private _compatible: boolean;\r\n\r\n  private _timescale: number = 1.0;\r\n\r\n  // loading\r\n  private _loader: Loader;\r\n\r\n  private _isInitialized: boolean = false;\r\n\r\n  private _deferredGoTo: string = null;\r\n\r\n  public on(eventName: 'fallbackgraphicscontext', handler: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public on(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public on(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public on(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public on(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public on(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: 'fallbackgraphicscontext', handler: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public once(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public once(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public once(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public once(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public once(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: 'fallbackgraphicscontext', handler?: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public off(eventName: Events.visible, handler?: (event: VisibleEvent) => void): void;\r\n  public off(eventName: Events.hidden, handler?: (event: HiddenEvent) => void): void;\r\n  public off(eventName: Events.start, handler?: (event: GameStartEvent) => void): void;\r\n  public off(eventName: Events.stop, handler?: (event: GameStopEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.preframe, handler?: (event: PreFrameEvent) => void): void;\r\n  public off(eventName: Events.postframe, handler?: (event: PostFrameEvent) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Default [[EngineOptions]]\r\n   */\r\n  private static _DEFAULT_ENGINE_OPTIONS: EngineOptions = {\r\n    width: 0,\r\n    height: 0,\r\n    enableCanvasTransparency: true,\r\n    useDrawSorting: true,\r\n    configurePerformanceCanvas2DFallback: {\r\n      allow: true,\r\n      showPlayerMessage: false,\r\n      threshold: { fps: 20, numberOfFrames: 100 }\r\n    },\r\n    canvasElementId: '',\r\n    canvasElement: undefined,\r\n    snapToPixel: false,\r\n    pointerScope: Input.PointerScope.Canvas,\r\n    suppressConsoleBootMessage: null,\r\n    suppressMinimumBrowserFeatureDetection: null,\r\n    suppressHiDPIScaling: null,\r\n    suppressPlayButton: null,\r\n    scrollPreventionMode: ScrollPreventionMode.Canvas,\r\n    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue\r\n  };\r\n\r\n  private _originalOptions: EngineOptions = {};\r\n  public readonly _originalDisplayMode: DisplayMode;\r\n\r\n  /**\r\n   * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,\r\n   * the game will be rendered full screen (taking up all available browser window space).\r\n   * You can customize the game rendering through [[EngineOptions]].\r\n   *\r\n   * Example:\r\n   *\r\n   * ```js\r\n   * var game = new ex.Engine({\r\n   *   width: 0, // the width of the canvas\r\n   *   height: 0, // the height of the canvas\r\n   *   enableCanvasTransparency: true, // the transparencySection of the canvas\r\n   *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own\r\n   *   displayMode: ex.DisplayMode.FullScreen, // the display mode\r\n   *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events\r\n   *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine\r\n   * });\r\n   *\r\n   * // call game.start, which is a Promise\r\n   * game.start().then(function () {\r\n   *   // ready, set, go!\r\n   * });\r\n   * ```\r\n   */\r\n  constructor(options?: EngineOptions) {\r\n    super();\r\n\r\n    options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };\r\n    this._originalOptions = options;\r\n\r\n    Flags.freeze();\r\n\r\n    // Initialize browser events facade\r\n    this.browser = new BrowserEvents(window, document);\r\n\r\n    // Check compatibility\r\n    const detector = new Detector();\r\n    if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {\r\n      const message = document.createElement('div');\r\n      message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';\r\n      document.body.appendChild(message);\r\n\r\n      detector.failedTests.forEach(function (test) {\r\n        const testMessage = document.createElement('div');\r\n        testMessage.innerText = 'Browser feature missing ' + test;\r\n        document.body.appendChild(testMessage);\r\n      });\r\n\r\n      if (options.canvasElementId) {\r\n        const canvas = document.getElementById(options.canvasElementId);\r\n        if (canvas) {\r\n          canvas.parentElement.removeChild(canvas);\r\n        }\r\n      }\r\n\r\n      return;\r\n    } else {\r\n      this._compatible = true;\r\n    }\r\n\r\n    // Use native console API for color fun\r\n    // eslint-disable-next-line no-console\r\n    if (console.log && !options.suppressConsoleBootMessage) {\r\n      // eslint-disable-next-line no-console\r\n      console.log(\r\n        `%cPowered by Excalibur.js (v${EX_VERSION})`,\r\n        'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;'\r\n      );\r\n      // eslint-disable-next-line no-console\r\n      console.log('\\n\\\r\n      /| ________________\\n\\\r\nO|===|* >________________>\\n\\\r\n      \\\\|');\r\n      // eslint-disable-next-line no-console\r\n      console.log('Visit', 'http://excaliburjs.com', 'for more information');\r\n    }\r\n\r\n    // Suppress play button\r\n    if (options.suppressPlayButton) {\r\n      this._suppressPlayButton = true;\r\n    }\r\n\r\n    this._logger = Logger.getInstance();\r\n\r\n    // If debug is enabled, let's log browser features to the console.\r\n    if (this._logger.defaultLevel === LogLevel.Debug) {\r\n      detector.logBrowserFeatures();\r\n    }\r\n\r\n    this._logger.debug('Building engine...');\r\n\r\n    this.canvasElementId = options.canvasElementId;\r\n\r\n    if (options.canvasElementId) {\r\n      this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);\r\n      this.canvas = <HTMLCanvasElement>document.getElementById(options.canvasElementId);\r\n    } else if (options.canvasElement) {\r\n      this._logger.debug('Using Canvas element specified:', options.canvasElement);\r\n      this.canvas = options.canvasElement;\r\n    } else {\r\n      this._logger.debug('Using generated canvas element');\r\n      this.canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    }\r\n\r\n    let displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    if ((options.width && options.height) || options.viewport) {\r\n      if (options.displayMode === undefined) {\r\n        displayMode = DisplayMode.Fixed;\r\n      }\r\n      this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);\r\n    } else if (!options.displayMode) {\r\n      this._logger.debug('Engine viewport is fit');\r\n      displayMode = DisplayMode.FitScreen;\r\n    }\r\n\r\n    this._originalDisplayMode = displayMode;\r\n\r\n    // Canvas 2D fallback can be flagged on\r\n    let useCanvasGraphicsContext = Flags.isEnabled('use-canvas-context');\r\n    if (!useCanvasGraphicsContext) {\r\n      // Attempt webgl first\r\n      try {\r\n        this.graphicsContext = new ExcaliburGraphicsContextWebGL({\r\n          canvasElement: this.canvas,\r\n          enableTransparency: this.enableCanvasTransparency,\r\n          smoothing: options.antialiasing,\r\n          backgroundColor: options.backgroundColor,\r\n          snapToPixel: options.snapToPixel,\r\n          useDrawSorting: options.useDrawSorting\r\n        });\r\n      } catch (e) {\r\n        this._logger.warn(\r\n          `Excalibur could not load webgl for some reason (${(e as Error).message}) and loaded a Canvas 2D fallback. ` +\r\n          `Some features of Excalibur will not work in this mode. \\n\\n` +\r\n          'Read more about this issue at https://excaliburjs.com/docs/webgl'\r\n        );\r\n        // fallback to canvas in case of failure\r\n        useCanvasGraphicsContext = true;\r\n      }\r\n    }\r\n\r\n    if (useCanvasGraphicsContext) {\r\n      this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n        canvasElement: this.canvas,\r\n        enableTransparency: this.enableCanvasTransparency,\r\n        smoothing: options.antialiasing,\r\n        backgroundColor: options.backgroundColor,\r\n        snapToPixel: options.snapToPixel,\r\n        useDrawSorting: options.useDrawSorting\r\n      });\r\n    }\r\n\r\n    this.screen = new Screen({\r\n      canvas: this.canvas,\r\n      context: this.graphicsContext,\r\n      antialiasing: options.antialiasing ?? true,\r\n      browser: this.browser,\r\n      viewport: options.viewport ?? (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n      resolution: options.resolution,\r\n      displayMode,\r\n      pixelRatio: options.suppressHiDPIScaling ? 1 : (options.pixelRatio ?? null)\r\n    });\r\n\r\n    // Set default filtering based on antialiasing\r\n    TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;\r\n\r\n    if (options.backgroundColor) {\r\n      this.backgroundColor = options.backgroundColor.clone();\r\n    }\r\n\r\n    this.maxFps = options.maxFps ?? this.maxFps;\r\n    this.fixedUpdateFps = options.fixedUpdateFps ?? this.fixedUpdateFps;\r\n\r\n    this.clock = new StandardClock({\r\n      maxFps: this.maxFps,\r\n      tick: this._mainloop.bind(this),\r\n      onFatalException: (e) => this.onFatalException(e)\r\n    });\r\n\r\n    this.enableCanvasTransparency = options.enableCanvasTransparency;\r\n\r\n    this._loader = new Loader();\r\n    this._loader.wireEngine(this);\r\n    this.debug = new Debug(this);\r\n\r\n    this._initialize(options);\r\n\r\n    this.rootScene = this.currentScene = new Scene();\r\n\r\n    this.addScene('root', this.rootScene);\r\n    (window as any).___EXCALIBUR_DEVTOOL = this;\r\n  }\r\n\r\n  private _performanceThresholdTriggered = false;\r\n  private _fpsSamples: number[] = [];\r\n  private _monitorPerformanceThresholdAndTriggerFallback() {\r\n    const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;\r\n    let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;\r\n    if (threshold === undefined) {\r\n      threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;\r\n    }\r\n    if (showPlayerMessage === undefined) {\r\n      showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;\r\n    }\r\n    if (!Flags.isEnabled('use-canvas-context') && allow && this.ready && !this._performanceThresholdTriggered) {\r\n      // Calculate Average fps for last X number of frames after start\r\n      if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n        this._fpsSamples.splice(0, 1);\r\n      }\r\n      this._fpsSamples.push(this.clock.fpsSampler.fps);\r\n      let total = 0;\r\n      for (let i = 0; i < this._fpsSamples.length; i++) {\r\n        total += this._fpsSamples[i];\r\n      }\r\n      const average = total / this._fpsSamples.length;\r\n\r\n      if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n        if (average <= threshold.fps) {\r\n          this._performanceThresholdTriggered = true;\r\n          this._logger.warn(\r\n            `Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\\n` +\r\n            'this might mean your browser doesn\\'t have webgl enabled or hardware acceleration is unavailable.\\n\\n' +\r\n            'If in Chrome:\\n' +\r\n            '  * Visit Settings > Advanced > System, and ensure \"Use Hardware Acceleration\" is checked.\\n'+\r\n            '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure \"Override software rendering list\" is \"enabled\"\\n' +\r\n            'If in Firefox, visit about:config\\n' +\r\n            '  * Ensure webgl.disabled = false\\n' +\r\n            '  * Ensure webgl.force-enabled = true\\n' +\r\n            '  * Ensure layers.acceleration.force-enabled = true\\n\\n' +\r\n            'Read more about this issue at https://excaliburjs.com/docs/performance'\r\n          );\r\n\r\n          if (showPlayerMessage) {\r\n            this._toaster.toast(\r\n              'Excalibur is encountering performance issues. '+\r\n              'It\\'s possible that your browser doesn\\'t have hardware acceleration enabled. ' +\r\n              'Visit [LINK] for more information and potential solutions.',\r\n              'https://excaliburjs.com/docs/performance'\r\n            );\r\n          }\r\n          this.useCanvas2DFallback();\r\n          this.emit('fallbackgraphicscontext', this.graphicsContext);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Switches the engine's graphics context to the 2D Canvas.\r\n   * @warning Some features of Excalibur will not work in this mode.\r\n   */\r\n  public useCanvas2DFallback() {\r\n    // Swap out the canvas\r\n    const newCanvas = this.canvas.cloneNode(false) as HTMLCanvasElement;\r\n    this.canvas.parentNode.replaceChild(newCanvas, this.canvas);\r\n    this.canvas = newCanvas;\r\n\r\n    const options = this._originalOptions;\r\n    const displayMode = this._originalDisplayMode;\r\n\r\n    // New graphics context\r\n    this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n      canvasElement: this.canvas,\r\n      enableTransparency: this.enableCanvasTransparency,\r\n      smoothing: options.antialiasing,\r\n      backgroundColor: options.backgroundColor,\r\n      snapToPixel: options.snapToPixel,\r\n      useDrawSorting: options.useDrawSorting\r\n    });\r\n\r\n    // Reset screen\r\n    if (this.screen) {\r\n      this.screen.dispose();\r\n    }\r\n\r\n    this.screen = new Screen({\r\n      canvas: this.canvas,\r\n      context: this.graphicsContext,\r\n      antialiasing: options.antialiasing ?? true,\r\n      browser: this.browser,\r\n      viewport: options.viewport ?? (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n      resolution: options.resolution,\r\n      displayMode,\r\n      pixelRatio: options.suppressHiDPIScaling ? 1 : (options.pixelRatio ?? null)\r\n    });\r\n    this.screen.setCurrentCamera(this.currentScene.camera);\r\n\r\n    // Reset pointers\r\n    this.input.pointers.detach();\r\n    const pointerTarget = options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas;\r\n    this.input.pointers = this.input.pointers.recreate(pointerTarget, this);\r\n    this.input.pointers.init();\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   */\r\n  public getWorldBounds() {\r\n    return this.screen.getWorldBounds();\r\n  }\r\n\r\n  /**\r\n   * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)\r\n   */\r\n  public get timescale() {\r\n    return this._timescale;\r\n  }\r\n\r\n  /**\r\n   * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects\r\n   * when using time-based movement.\r\n   */\r\n  public set timescale(value: number) {\r\n    if (value <= 0) {\r\n      Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');\r\n      return;\r\n    }\r\n\r\n    this._timescale = value;\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    return this.currentScene.addTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    return this.currentScene.removeTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   *\r\n   * @param key  The name of the scene, must be unique\r\n   * @param scene The scene to add to the engine\r\n   */\r\n  public addScene(key: string, scene: Scene) {\r\n    if (this.scenes[key]) {\r\n      this._logger.warn('Scene', key, 'already exists overwriting');\r\n    }\r\n    this.scenes[key] = scene;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Scene]] instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public removeScene(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param key  The scene key to remove\r\n   */\r\n  public removeScene(key: string): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  public removeScene(entity: any): void {\r\n    if (entity instanceof Scene) {\r\n      // remove scene\r\n      for (const key in this.scenes) {\r\n        if (this.scenes.hasOwnProperty(key)) {\r\n          if (this.scenes[key] === entity) {\r\n            delete this.scenes[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      // remove scene\r\n      delete this.scenes[entity];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   * @param sceneKey  The key of the scene, must be unique\r\n   * @param scene     The scene to add to the engine\r\n   */\r\n  public add(sceneKey: string, scene: Scene): void;\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n  /**\r\n   * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap\r\n   * will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n  /**\r\n   * Adds an actor to the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.add(actor)`.\r\n   *\r\n   * Actors can only be drawn if they are a member of a scene, and only\r\n   * the [[currentScene]] may be drawn or updated.\r\n   *\r\n   * @param actor  The actor to add to the [[currentScene]]\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  public add(entity: Entity): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the [[currentScene]] of the game,\r\n   * ScreenElements do not participate in collisions, instead the\r\n   * remain in the same place on the screen.\r\n   * @param screenElement  The ScreenElement to add to the [[currentScene]]\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    if (arguments.length === 2) {\r\n      this.addScene(<string>arguments[0], <Scene>arguments[1]);\r\n      return;\r\n    }\r\n    if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {\r\n      this.scenes[this._deferredGoTo].add(entity);\r\n    } else {\r\n      this.currentScene.add(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a scene instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public remove(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param sceneKey  The scene to remove\r\n   */\r\n  public remove(sceneKey: string): void;\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public remove(timer: Timer): void;\r\n  /**\r\n   * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n  /**\r\n   * Removes an actor from the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.removeChild(actor)`.\r\n   * Actors that are removed from a scene will no longer be drawn or updated.\r\n   *\r\n   * @param actor  The actor to remove from the [[currentScene]].\r\n   */\r\n  public remove(actor: Actor): void;\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the [[currentScene]]\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.currentScene.remove(entity);\r\n    }\r\n\r\n    if (entity instanceof Scene) {\r\n      this.removeScene(entity);\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      this.removeScene(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Changes the currently updating and drawing scene to a different,\r\n   * named scene. Calls the [[Scene]] lifecycle events.\r\n   * @param key  The key of the scene to transition to.\r\n   * @param data Optional data to send to the scene's onActivate method\r\n   */\r\n  public goToScene<TData = undefined>(key: string, data?: TData): void {\r\n    // if not yet initialized defer goToScene\r\n    if (!this.isInitialized) {\r\n      this._deferredGoTo = key;\r\n      return;\r\n    }\r\n\r\n    if (this.scenes[key]) {\r\n      const previousScene = this.currentScene;\r\n      const nextScene = this.scenes[key];\r\n\r\n      this._logger.debug('Going to scene:', key);\r\n\r\n      // only deactivate when initialized\r\n      if (this.currentScene.isInitialized) {\r\n        const context = { engine: this, previousScene, nextScene };\r\n        this.currentScene._deactivate.apply(this.currentScene, [context, nextScene]);\r\n        this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(context, this.currentScene));\r\n      }\r\n\r\n      // set current scene to new one\r\n      this.currentScene = nextScene;\r\n      this.screen.setCurrentCamera(nextScene.camera);\r\n\r\n      // initialize the current scene if has not been already\r\n      this.currentScene._initialize(this);\r\n\r\n      const context = { engine: this, previousScene, nextScene, data };\r\n      this.currentScene._activate.apply(this.currentScene, [context, nextScene]);\r\n      this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(context, this.currentScene));\r\n    } else {\r\n      this._logger.error('Scene', key, 'does not exist!');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transforms the current x, y from screen coordinates to world coordinates\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    return this.screen.screenToWorldCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Transforms a world coordinate, to a screen coordinate\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    return this.screen.worldToScreenCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Initializes the internal canvas, rendering context, display mode, and native event listeners\r\n   */\r\n  private _initialize(options?: EngineOptions) {\r\n    this.pageScrollPreventionMode = options.scrollPreventionMode;\r\n\r\n    // initialize inputs\r\n    const pointerTarget = options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas;\r\n    this.input = {\r\n      keyboard: new Input.Keyboard(),\r\n      pointers: new PointerEventReceiver(pointerTarget, this),\r\n      gamepads: new Input.Gamepads()\r\n    };\r\n    this.input.keyboard.init();\r\n    this.input.pointers.init();\r\n    this.input.gamepads.init();\r\n\r\n    // Issue #385 make use of the visibility api\r\n    // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\r\n\r\n    let hidden: keyof HTMLDocument, visibilityChange: string;\r\n    if (typeof document.hidden !== 'undefined') {\r\n      // Opera 12.10 and Firefox 18 and later support\r\n      hidden = 'hidden';\r\n      visibilityChange = 'visibilitychange';\r\n    } else if ('msHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'msHidden';\r\n      visibilityChange = 'msvisibilitychange';\r\n    } else if ('webkitHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'webkitHidden';\r\n      visibilityChange = 'webkitvisibilitychange';\r\n    }\r\n\r\n    this.browser.document.on(visibilityChange, () => {\r\n      if (document[hidden]) {\r\n        this.eventDispatcher.emit('hidden', new HiddenEvent(this));\r\n        this._logger.debug('Window hidden');\r\n      } else {\r\n        this.eventDispatcher.emit('visible', new VisibleEvent(this));\r\n        this._logger.debug('Window visible');\r\n      }\r\n    });\r\n\r\n    if (!this.canvasElementId && !options.canvasElement) {\r\n      document.body.appendChild(this.canvas);\r\n    }\r\n  }\r\n\r\n  public onInitialize(_engine: Engine) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If supported by the browser, this will set the antialiasing flag on the\r\n   * canvas. Set this to `false` if you want a 'jagged' pixel art look to your\r\n   * image resources.\r\n   * @param isSmooth  Set smoothing to true or false\r\n   */\r\n  public setAntialiasing(isSmooth: boolean) {\r\n    this.screen.antialiasing = isSmooth;\r\n  }\r\n\r\n  /**\r\n   * Return the current smoothing status of the canvas\r\n   */\r\n  public getAntialiasing(): boolean {\r\n    return this.screen.antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  private _overrideInitialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n      if (this._deferredGoTo) {\r\n        const deferredScene = this._deferredGoTo;\r\n        this._deferredGoTo = null;\r\n        this.goToScene(deferredScene);\r\n      } else {\r\n        this.goToScene('root');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the entire state of the game\r\n   * @param delta  Number of milliseconds elapsed since the last update.\r\n   */\r\n  private _update(delta: number) {\r\n    if (!this.ready) {\r\n      // suspend updates until loading is finished\r\n      this._loader.update(this, delta);\r\n      // Update input listeners\r\n      this.input.keyboard.update();\r\n      this.input.gamepads.update();\r\n      return;\r\n    }\r\n\r\n\r\n    // Publish preupdate events\r\n    this._preupdate(delta);\r\n\r\n    // process engine level events\r\n    this.currentScene.update(this, delta);\r\n\r\n    // Publish update event\r\n    this._postupdate(delta);\r\n\r\n    // Update input listeners\r\n    this.input.keyboard.update();\r\n    this.input.gamepads.update();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _preupdate(delta: number) {\r\n    this.emit('preupdate', new PreUpdateEvent(this, delta, this));\r\n    this.onPreUpdate(this, delta);\r\n  }\r\n\r\n  public onPreUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postupdate(delta: number) {\r\n    this.emit('postupdate', new PostUpdateEvent(this, delta, this));\r\n    this.onPostUpdate(this, delta);\r\n  }\r\n\r\n  public onPostUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Draws the entire game\r\n   * @param delta  Number of milliseconds elapsed since the last draw.\r\n   */\r\n  private _draw(delta: number) {\r\n    this.graphicsContext.beginDrawLifecycle();\r\n    this.graphicsContext.clear();\r\n    this._predraw(this.graphicsContext, delta);\r\n\r\n    // Drawing nothing else while loading\r\n    if (!this._isReady) {\r\n      this._loader.canvas.draw(this.graphicsContext, 0, 0);\r\n      this.graphicsContext.flush();\r\n      return;\r\n    }\r\n\r\n    this.graphicsContext.backgroundColor = this.backgroundColor;\r\n\r\n    this.currentScene.draw(this.graphicsContext, delta);\r\n\r\n    this._postdraw(this.graphicsContext, delta);\r\n\r\n    // Flush any pending drawings\r\n    this.graphicsContext.flush();\r\n    this.graphicsContext.endDrawLifecycle();\r\n\r\n    this._checkForScreenShots();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, delta, this));\r\n    this.onPreDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));\r\n    this.onPostDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Enable or disable Excalibur debugging functionality.\r\n   * @param toggle a value that debug drawing will be changed to\r\n   */\r\n  public showDebug(toggle: boolean): void {\r\n    this._isDebug = toggle;\r\n  }\r\n\r\n  /**\r\n   * Toggle Excalibur debugging functionality.\r\n   */\r\n  public toggleDebug(): boolean {\r\n    this._isDebug = !this._isDebug;\r\n    return this._isDebug;\r\n  }\r\n\r\n  private _loadingComplete: boolean = false;\r\n\r\n  /**\r\n   * Returns true when loading is totally complete and the player has clicked start\r\n   */\r\n  public get loadingComplete() {\r\n    return this._loadingComplete;\r\n  }\r\n\r\n  private _isReady = false;\r\n  public get ready() {\r\n    return this._isReady;\r\n  }\r\n  private _isReadyResolve: () => any;\r\n  private _isReadyPromise = new Promise<void>(resolve => {\r\n    this._isReadyResolve = resolve;\r\n  });\r\n  public isReady(): Promise<void> {\r\n    return this._isReadyPromise;\r\n  }\r\n\r\n\r\n  /**\r\n   * Starts the internal game loop for Excalibur after loading\r\n   * any provided assets.\r\n   * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own\r\n   * custom loader.\r\n   *\r\n   * Note: start() only resolves AFTER the user has clicked the play button\r\n   */\r\n  public async start(loader?: Loader): Promise<void> {\r\n    if (!this._compatible) {\r\n      throw new Error('Excalibur is incompatible with your browser');\r\n    }\r\n\r\n    // Wire loader if we have it\r\n    if (loader) {\r\n      // Push the current user entered resolution/viewport\r\n      this.screen.pushResolutionAndViewport();\r\n\r\n      // Configure resolution for loader, it expects resolution === viewport\r\n      this.screen.resolution = this.screen.viewport;\r\n      this.screen.applyResolutionAndViewport();\r\n      this._loader = loader;\r\n      this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;\r\n      this._loader.wireEngine(this);\r\n    }\r\n\r\n    // Start the excalibur clock which drives the mainloop\r\n    // has started is a slight misnomer, it's really mainloop started\r\n    this._logger.debug('Starting game clock...');\r\n    this.browser.resume();\r\n    this.clock.start();\r\n    this._logger.debug('Game clock started');\r\n\r\n    if (loader) {\r\n      await this.load(this._loader);\r\n      this._loadingComplete = true;\r\n\r\n      // reset back to previous user resolution/viewport\r\n      this.screen.popResolutionAndViewport();\r\n      this.screen.applyResolutionAndViewport();\r\n    }\r\n\r\n    this._loadingComplete = true;\r\n\r\n    // Initialize before ready\r\n    this._overrideInitialize(this);\r\n\r\n    this._isReady = true;\r\n\r\n    this._isReadyResolve();\r\n    this.emit('start', new GameStartEvent(this));\r\n    return this._isReadyPromise;\r\n  }\r\n\r\n  /**\r\n   * Returns the current frames elapsed milliseconds\r\n   */\r\n  public currentFrameElapsedMs = 0;\r\n\r\n  /**\r\n   * Returns the current frame lag when in fixed update mode\r\n   */\r\n  public currentFrameLagMs = 0;\r\n\r\n  private _lagMs = 0;\r\n  private _mainloop(elapsed: number) {\r\n    this.emit('preframe', new PreFrameEvent(this, this.stats.prevFrame));\r\n    const delta = elapsed * this.timescale;\r\n    this.currentFrameElapsedMs = delta;\r\n\r\n    // reset frame stats (reuse existing instances)\r\n    const frameId = this.stats.prevFrame.id + 1;\r\n    this.stats.currFrame.reset();\r\n    this.stats.currFrame.id = frameId;\r\n    this.stats.currFrame.delta = delta;\r\n    this.stats.currFrame.fps = this.clock.fpsSampler.fps;\r\n    GraphicsDiagnostics.clear();\r\n\r\n    const beforeUpdate = this.clock.now();\r\n    const fixedTimestepMs = 1000 / this.fixedUpdateFps;\r\n    if (this.fixedUpdateFps) {\r\n      this._lagMs += delta;\r\n      while (this._lagMs >= fixedTimestepMs) {\r\n        this._update(fixedTimestepMs);\r\n        this._lagMs -= fixedTimestepMs;\r\n      }\r\n    } else {\r\n      this._update(delta);\r\n    }\r\n    const afterUpdate = this.clock.now();\r\n    this.currentFrameLagMs = this._lagMs;\r\n    this._draw(delta);\r\n    const afterDraw = this.clock.now();\r\n\r\n    this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;\r\n    this.stats.currFrame.duration.draw = afterDraw - afterUpdate;\r\n    this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;\r\n    this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;\r\n\r\n    this.emit('postframe', new PostFrameEvent(this, this.stats.currFrame));\r\n    this.stats.prevFrame.reset(this.stats.currFrame);\r\n\r\n    this._monitorPerformanceThresholdAndTriggerFallback();\r\n  }\r\n\r\n  /**\r\n   * Stops Excalibur's main loop, useful for pausing the game.\r\n   */\r\n  public stop() {\r\n    if (this.clock.isRunning()) {\r\n      this.emit('stop', new GameStopEvent(this));\r\n      this.browser.pause();\r\n      this.clock.stop();\r\n      this._logger.debug('Game stopped');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the Engine's running status, Useful for checking whether engine is running or paused.\r\n   */\r\n  public isRunning() {\r\n    return this.clock.isRunning();\r\n  }\r\n\r\n\r\n  private _screenShotRequests: { preserveHiDPIResolution: boolean, resolve: (image: HTMLImageElement) => void }[] = [];\r\n  /**\r\n   * Takes a screen shot of the current viewport and returns it as an\r\n   * HTML Image Element.\r\n   * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false\r\n   */\r\n  public screenshot(preserveHiDPIResolution = false): Promise<HTMLImageElement> {\r\n    const screenShotPromise = new Promise<HTMLImageElement>((resolve) => {\r\n      this._screenShotRequests.push({preserveHiDPIResolution, resolve});\r\n    });\r\n    return screenShotPromise;\r\n  }\r\n\r\n  private _checkForScreenShots() {\r\n    // We must grab the draw buffer before we yield to the browser\r\n    // the draw buffer is cleared after compositing\r\n    // the reason for the asynchrony is setting `preserveDrawingBuffer: true`\r\n    // forces the browser to copy buffers which can have a mass perf impact on mobile\r\n    for (const request of this._screenShotRequests) {\r\n      const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;\r\n      const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;\r\n      const screenshot = document.createElement('canvas');\r\n      screenshot.width = finalWidth;\r\n      screenshot.height = finalHeight;\r\n      const ctx = screenshot.getContext('2d');\r\n      ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);\r\n\r\n      const result = new Image();\r\n      const raw = screenshot.toDataURL('image/png');\r\n      result.src = raw;\r\n      request.resolve(result);\r\n    }\r\n    // Reset state\r\n    this._screenShotRequests.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Another option available to you to load resources into the game.\r\n   * Immediately after calling this the game will pause and the loading screen\r\n   * will appear.\r\n   * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].\r\n   */\r\n  public async load(loader: Loadable<any>): Promise<void> {\r\n    try {\r\n      await loader.load();\r\n    } catch (e) {\r\n      this._logger.error('Error loading resources, things may not behave properly', e);\r\n      await Promise.resolve();\r\n    }\r\n  }\r\n}","import { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { vec, Vector } from './Math/vector';\r\nimport { Text } from './Graphics/Text';\r\nimport { GraphicsComponent, SpriteFont } from './Graphics';\r\nimport { Font } from './Graphics/Font';\r\nimport { Actor } from './Actor';\r\nimport { ActorArgs } from '.';\r\n\r\n/**\r\n * Option for creating a label\r\n */\r\nexport interface LabelOptions {\r\n  /**\r\n   * Specify the label text\r\n   */\r\n  text?: string;\r\n  /**\r\n   * Specify the color of the text (does not apply to SpriteFonts)\r\n   */\r\n  color?: Color;\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally specify a sprite font, will take precedence over any other [[Font]]\r\n   */\r\n  spriteFont?: SpriteFont;\r\n  /**\r\n   * Specify a custom font\r\n   */\r\n  font?: Font\r\n}\r\n\r\n/**\r\n * Labels are the way to draw small amounts of text to the screen. They are\r\n * actors and inherit all of the benefits and capabilities.\r\n */\r\nexport class Label extends Actor {\r\n  private _font: Font = new Font();\r\n  private _text: Text = new Text({ text: '', font: this._font });\r\n\r\n  public get font(): Font {\r\n    return this._font;\r\n  }\r\n\r\n  public set font(newFont: Font) {\r\n    this._font = newFont;\r\n    this._text.font = newFont;\r\n  }\r\n\r\n  /**\r\n   * The text to draw.\r\n   */\r\n  public get text(): string {\r\n    return this._text.text;\r\n  }\r\n\r\n  public set text(text: string) {\r\n    this._text.text = text;\r\n  }\r\n\r\n  public override get color(): Color {\r\n    return this._text.color;\r\n  }\r\n\r\n  public override set color(color: Color) {\r\n    if (this._text) {\r\n      this._text.color = color;\r\n    }\r\n  }\r\n\r\n  public get opacity(): number {\r\n    return this._text.opacity;\r\n  }\r\n\r\n  public set opacity(opacity: number) {\r\n    this._text.opacity = opacity;\r\n  }\r\n\r\n  private _spriteFont: SpriteFont;\r\n  /**\r\n   * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.\r\n   */\r\n  public get spriteFont(): SpriteFont {\r\n    return this._spriteFont;\r\n  }\r\n\r\n  public set spriteFont(sf: SpriteFont) {\r\n    if (sf) {\r\n      this._spriteFont = sf;\r\n      this._text.font = this._spriteFont;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build a new label\r\n   * @param options\r\n   */\r\n  constructor(options?: LabelOptions & ActorArgs) {\r\n    super(options);\r\n    const {text, pos, x, y, spriteFont, font, color} = options;\r\n\r\n    this.pos = pos ?? (x && y ? vec(x, y) : this.pos);\r\n    this.text = text ?? this.text;\r\n    this.font = font ?? this.font;\r\n    this.spriteFont = spriteFont ?? this.spriteFont;\r\n    this._text.color = color ?? this.color;\r\n    const gfx = this.get(GraphicsComponent);\r\n    gfx.anchor = Vector.Zero;\r\n    gfx.use(this._text);\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the text in the label (in pixels);\r\n   */\r\n  public getTextWidth(): number {\r\n    return this._text.width;\r\n  }\r\n}\r\n","import { BodyComponent, BoundingBox, Collider, ColliderComponent, CollisionType, Color, CompositeCollider, vec, Vector } from '..';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { DebugGraphicsComponent, ExcaliburGraphicsContext, Graphic, GraphicsComponent } from '../Graphics';\r\nimport { IsometricEntityComponent } from './IsometricEntityComponent';\r\n\r\nexport class IsometricTile extends Entity {\r\n  /**\r\n   * Indicates whether this tile is solid\r\n   */\r\n  public solid: boolean = false;\r\n\r\n  private _gfx: GraphicsComponent;\r\n  private _tileBounds = new BoundingBox();\r\n  private _graphics: Graphic[] = [];\r\n  public getGraphics(): readonly Graphic[] {\r\n    return this._graphics;\r\n  }\r\n  /**\r\n   * Tile graphics\r\n   */\r\n  public addGraphic(graphic: Graphic) {\r\n    this._graphics.push(graphic);\r\n    this._gfx.visible = true;\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  private _recalculateBounds(): BoundingBox {\r\n    let bounds = this._tileBounds.clone();\r\n    for (const graphic of this._graphics) {\r\n      const offset = vec(\r\n        this.map.graphicsOffset.x - this.map.tileWidth / 2,\r\n        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n      bounds = bounds.combine(graphic.localBounds.translate(offset));\r\n    }\r\n    return bounds;\r\n  }\r\n\r\n  public removeGraphic(graphic: Graphic) {\r\n    const index = this._graphics.indexOf(graphic);\r\n    if (index > -1) {\r\n      this._graphics.splice(index, 1);\r\n    }\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  public clearGraphics() {\r\n    this._graphics.length = 0;\r\n    this._gfx.visible = false;\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  /**\r\n   * Tile colliders\r\n   */\r\n  private _colliders: Collider[] = [];\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Adds a collider to the IsometricTile\r\n   *\r\n   * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n   * @param collider\r\n   */\r\n  public addCollider(collider: Collider) {\r\n    this._colliders.push(collider);\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Removes a collider from the IsometricTile\r\n   * @param collider\r\n   */\r\n  public removeCollider(collider: Collider) {\r\n    const index = this._colliders.indexOf(collider);\r\n    if (index > -1) {\r\n      this._colliders.splice(index, 1);\r\n    }\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Clears all colliders from the IsometricTile\r\n   */\r\n  public clearColliders(): void {\r\n    this._colliders.length = 0;\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Integer tile x coordinate\r\n   */\r\n  public readonly x: number;\r\n  /**\r\n   * Integer tile y coordinate\r\n   */\r\n  public readonly y: number;\r\n  /**\r\n   * Reference to the [[IsometricMap]] this tile is part of\r\n   */\r\n  public readonly map: IsometricMap;\r\n\r\n  private _transform: TransformComponent;\r\n  private _isometricEntityComponent: IsometricEntityComponent;\r\n\r\n  /**\r\n   * Returns the top left corner of the [[IsometricTile]] in world space\r\n   */\r\n  public get pos(): Vector {\r\n    return this.map.tileToWorld(vec(this.x, this.y));\r\n  }\r\n\r\n  /**\r\n   * Returns the center of the [[IsometricTile]]\r\n   */\r\n  public get center(): Vector {\r\n    return this.pos.add(vec(0, this.map.tileHeight / 2));\r\n  }\r\n\r\n  /**\r\n   * Construct a new IsometricTile\r\n   * @param x tile coordinate in x (not world position)\r\n   * @param y tile coordinate in y (not world position)\r\n   * @param graphicsOffset offset that tile should be shifted by (default (0, 0))\r\n   * @param map reference to owning IsometricMap\r\n   */\r\n  constructor(x: number, y: number, graphicsOffset: Vector | null, map: IsometricMap) {\r\n    super([\r\n      new TransformComponent(),\r\n      new GraphicsComponent({\r\n        offset: graphicsOffset ?? Vector.Zero,\r\n        onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)\r\n      }),\r\n      new IsometricEntityComponent(map)\r\n    ]);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.map = map;\r\n    this._transform = this.get(TransformComponent);\r\n    this._isometricEntityComponent = this.get(IsometricEntityComponent);\r\n\r\n    const halfTileWidth = this.map.tileWidth / 2;\r\n    const halfTileHeight = this.map.tileHeight / 2;\r\n    // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n    // The x position shifts left with every y step\r\n    const xPos = (this.x - this.y) * halfTileWidth;\r\n    // The y position needs to go down with every x step\r\n    const yPos = (this.x + this.y) * halfTileHeight;\r\n    this._transform.pos = vec(xPos, yPos);\r\n    this._isometricEntityComponent.elevation = 0;\r\n\r\n    this._gfx = this.get(GraphicsComponent);\r\n    this._gfx.visible = false; // start not visible\r\n    const totalWidth = this.map.tileWidth;\r\n    const totalHeight = this.map.tileHeight;\r\n\r\n    // initial guess at gfx bounds based on the tile\r\n    const offset = vec(0, (this.map.renderFromTopOfGraphic ? totalHeight : 0));\r\n    this._gfx.localBounds = this._tileBounds = new BoundingBox({\r\n      left: -totalWidth / 2,\r\n      top: -totalHeight,\r\n      right: totalWidth / 2,\r\n      bottom: totalHeight\r\n    }).translate(offset);\r\n  }\r\n\r\n  draw(gfx: ExcaliburGraphicsContext, _elapsed: number) {\r\n    const halfTileWidth = this.map.tileWidth / 2;\r\n    gfx.save();\r\n    // shift left origin to corner of map, not the left corner of the first sprite\r\n    gfx.translate(-halfTileWidth, 0);\r\n    for (const graphic of this._graphics) {\r\n      graphic.draw(\r\n        gfx,\r\n        this.map.graphicsOffset.x,\r\n        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n    }\r\n    gfx.restore();\r\n  }\r\n}\r\n\r\nexport interface IsometricMapOptions {\r\n  /**\r\n   * Optionally name the isometric tile map\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally specify the position of the isometric tile map\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally render from the top of the graphic, by default tiles are rendered from the bottom\r\n   */\r\n  renderFromTopOfGraphic?: boolean;\r\n  /**\r\n   * Optionally present a graphics offset, this can be useful depending on your tile graphics\r\n   */\r\n  graphicsOffset?: Vector;\r\n  /**\r\n   * Width of an individual tile in pixels, this should be the width of the parallelogram of the base of the tile art asset.\r\n   */\r\n  tileWidth: number;\r\n  /**\r\n   * Height of an individual tile in pixels, this should be the height of the parallelogram of the base of the tile art asset.\r\n   */\r\n  tileHeight: number;\r\n  /**\r\n   * The number of tile columns, or the number of tiles wide\r\n   */\r\n  columns: number;\r\n  /**\r\n   * The number of tile  rows, or the number of tiles high\r\n   */\r\n  rows: number;\r\n}\r\n\r\n/**\r\n * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur\r\n *\r\n * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.\r\n * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.\r\n *\r\n * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given\r\n * your art assets.\r\n */\r\nexport class IsometricMap extends Entity {\r\n  /**\r\n   * Width of individual tile in pixels\r\n   */\r\n  public readonly tileWidth: number;\r\n  /**\r\n   * Height of individual tile in pixels\r\n   */\r\n  public readonly tileHeight: number;\r\n  /**\r\n   * Number of tiles wide\r\n   */\r\n  public readonly columns: number;\r\n  /**\r\n   * Number of tiles high\r\n   */\r\n  public readonly rows: number;\r\n  /**\r\n   * List containing all of the tiles in IsometricMap\r\n   */\r\n  public readonly tiles: IsometricTile[];\r\n\r\n  /**\r\n   * Render the tile graphic from the top instead of the bottom\r\n   *\r\n   * default is `false` meaning rendering from the bottom\r\n   */\r\n  public renderFromTopOfGraphic: boolean = false;\r\n  public graphicsOffset: Vector = vec(0, 0);\r\n\r\n  /**\r\n   * Isometric map [[TransformComponent]]\r\n   */\r\n  public transform: TransformComponent;\r\n\r\n  /**\r\n   * Isometric map [[ColliderComponent]]\r\n   */\r\n  public collider: ColliderComponent;\r\n\r\n  private _composite: CompositeCollider;\r\n\r\n  constructor(options: IsometricMapOptions) {\r\n    super([\r\n      new TransformComponent(),\r\n      new BodyComponent({\r\n        type: CollisionType.Fixed\r\n      }),\r\n      new ColliderComponent(),\r\n      new DebugGraphicsComponent((ctx) => this.debug(ctx), false)\r\n    ], options.name);\r\n    const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset } = options;\r\n\r\n    this.transform = this.get(TransformComponent);\r\n    if (pos) {\r\n      this.transform.pos = pos;\r\n    }\r\n\r\n    this.collider = this.get(ColliderComponent);\r\n    if (this.collider) {\r\n      this.collider.set(this._composite = new CompositeCollider([]));\r\n    }\r\n\r\n\r\n    this.renderFromTopOfGraphic = renderFromTopOfGraphic ?? this.renderFromTopOfGraphic;\r\n    this.graphicsOffset = graphicsOffset ?? this.graphicsOffset;\r\n\r\n    this.tileWidth = tileWidth;\r\n    this.tileHeight = tileHeight;\r\n    this.columns = width;\r\n    this.rows = height;\r\n\r\n    this.tiles = new Array(width * height);\r\n\r\n    // build up tile representation\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        const tile = new IsometricTile(x, y, this.graphicsOffset, this);\r\n        this.tiles[x + y * width] = tile;\r\n        this.addChild(tile);\r\n        // TODO row/columns helpers\r\n      }\r\n    }\r\n  }\r\n\r\n  public update(): void {\r\n    if (this._collidersDirty) {\r\n      this.updateColliders();\r\n      this._collidersDirty = false;\r\n    }\r\n  }\r\n\r\n  private _collidersDirty = false;\r\n  public flagCollidersDirty() {\r\n    this._collidersDirty = true;\r\n  }\r\n\r\n  private _originalOffsets = new WeakMap<Collider, Vector>();\r\n  private _getOrSetColliderOriginalOffset(collider: Collider): Vector {\r\n    if (!this._originalOffsets.has(collider)) {\r\n      const originalOffset = collider.offset;\r\n      this._originalOffsets.set(collider, originalOffset);\r\n      return originalOffset;\r\n    } else {\r\n      return this._originalOffsets.get(collider);\r\n    }\r\n  }\r\n  public updateColliders() {\r\n    this._composite.clearColliders();\r\n    const pos = this.get(TransformComponent).pos;\r\n    for (const tile of this.tiles) {\r\n      if (tile.solid) {\r\n        for (const collider of tile.getColliders()) {\r\n          const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n          collider.offset = this.tileToWorld(vec(tile.x, tile.y))\r\n            .sub(pos)\r\n            .add(originalOffset)\r\n            .sub(vec(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing\r\n          collider.owner = this;\r\n          this._composite.addCollider(collider);\r\n        }\r\n      }\r\n    }\r\n    this.collider.update();\r\n  }\r\n\r\n  /**\r\n   * Convert world space coordinates to the tile x, y coordinate\r\n   * @param worldCoordinate\r\n   */\r\n  public worldToTile(worldCoordinate: Vector): Vector {\r\n    worldCoordinate = worldCoordinate.sub(this.transform.globalPos);\r\n\r\n    const halfTileWidth = this.tileWidth / 2;\r\n    const halfTileHeight = this.tileHeight / 2;\r\n    // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n    return vec(\r\n      ~~((worldCoordinate.x / halfTileWidth + (worldCoordinate.y / halfTileHeight)) / 2),\r\n      ~~((worldCoordinate.y / halfTileHeight - (worldCoordinate.x / halfTileWidth)) / 2));\r\n  }\r\n\r\n  /**\r\n   * Given a tile coordinate, return the top left corner in world space\r\n   * @param tileCoordinate\r\n   */\r\n  public tileToWorld(tileCoordinate: Vector): Vector {\r\n    const halfTileWidth = this.tileWidth / 2;\r\n    const halfTileHeight = this.tileHeight / 2;\r\n    // The x position shifts left with every y step\r\n    const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;\r\n    // The y position needs to go down with every x step\r\n    const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;\r\n    return vec(xPos, yPos).add(this.transform.pos);\r\n  }\r\n\r\n  /**\r\n   * Returns the [[IsometricTile]] by its x and y coordinates\r\n   */\r\n  public getTile(x: number, y: number): IsometricTile | null {\r\n    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n      return null;\r\n    }\r\n    return this.tiles[x + y * this.columns];\r\n  }\r\n\r\n  /**\r\n   * Returns the [[IsometricTile]] by testing a point in world coordinates,\r\n   * returns `null` if no Tile was found.\r\n   */\r\n  public getTileByPoint(point: Vector): IsometricTile | null {\r\n    const tileCoord = this.worldToTile(point);\r\n    const tile = this.getTile(tileCoord.x, tileCoord.y);\r\n    return tile;\r\n  }\r\n\r\n  private _getMaxZIndex(): number {\r\n    let maxZ = Number.NEGATIVE_INFINITY;\r\n    for (const tile of this.tiles) {\r\n      const currentZ = tile.get(TransformComponent).z;\r\n      if (currentZ > maxZ) {\r\n        maxZ =  currentZ;\r\n      }\r\n    }\r\n    return maxZ;\r\n  }\r\n\r\n  /**\r\n   * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on\r\n   * @param gfx\r\n   */\r\n  public debug(gfx: ExcaliburGraphicsContext) {\r\n    gfx.save();\r\n    gfx.z = this._getMaxZIndex() + 0.5;\r\n    for (let y = 0; y < this.rows + 1; y++) {\r\n      const left = this.tileToWorld(vec(0, y));\r\n      const right = this.tileToWorld(vec(this.columns, y));\r\n      gfx.drawLine(left, right, Color.Red, 2);\r\n    }\r\n\r\n    for (let x = 0; x < this.columns + 1; x++) {\r\n      const top = this.tileToWorld(vec(x, 0));\r\n      const bottom = this.tileToWorld(vec(x, this.rows));\r\n      gfx.drawLine(top, bottom, Color.Red, 2);\r\n    }\r\n\r\n    for (const tile of this.tiles) {\r\n      gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);\r\n    }\r\n    gfx.restore();\r\n  }\r\n}","import { Entity } from '../../EntityComponentSystem';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\n/**\r\n * Action that can represent a sequence of actions, this can be useful in conjunction with\r\n * [[ParallelActions]] to run multiple sequences in parallel.\r\n */\r\nexport class ActionSequence implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _stopped: boolean = false;\r\n  private _sequenceContext: ActionContext;\r\n  private _sequenceBuilder: (actionContext: ActionContext) => any;\r\n  constructor(entity: Entity, actionBuilder: (actionContext: ActionContext) => any) {\r\n    this._sequenceBuilder = actionBuilder;\r\n    this._sequenceContext = new ActionContext(entity);\r\n    this._actionQueue = this._sequenceContext.getQueue();\r\n    this._sequenceBuilder(this._sequenceContext);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._actionQueue.isComplete();\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._stopped = false;\r\n    this._actionQueue.reset();\r\n  }\r\n\r\n  public clone(entity: Entity) {\r\n    return new ActionSequence(entity, this._sequenceBuilder);\r\n  }\r\n}","import { Entity } from '../../EntityComponentSystem';\r\nimport { Action } from '../Action';\r\n\r\n\r\n/**\r\n * Action that can run multiple [[Action]]s or [[ActionSequence]]s at the same time\r\n */\r\nexport class ParallelActions implements Action {\r\n  private _actions: Action[];\r\n\r\n  constructor(parallelActions: Action[]) {\r\n    this._actions = parallelActions;\r\n  }\r\n\r\n  update(delta: number): void {\r\n    for (let i = 0; i < this._actions.length; i++) {\r\n      this._actions[i].update(delta);\r\n    }\r\n  }\r\n  isComplete(entity: Entity): boolean {\r\n    return this._actions.every(a => a.isComplete(entity));\r\n  }\r\n  reset(): void {\r\n    this._actions.forEach(a => a.reset());\r\n  }\r\n  stop(): void {\r\n    this._actions.forEach(a => a.stop());\r\n  }\r\n}","import { CollisionGroup } from './CollisionGroup';\r\n\r\n/**\r\n * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur\r\n */\r\nexport class CollisionGroupManager {\r\n  // using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.\r\n  private static _STARTING_BIT = 0b1 | 0;\r\n  private static _MAX_GROUPS = 32;\r\n  private static _CURRENT_GROUP = 1;\r\n  private static _CURRENT_BIT = CollisionGroupManager._STARTING_BIT;\r\n  private static _GROUPS: Map<string, CollisionGroup> = new Map<string, CollisionGroup>();\r\n\r\n  /**\r\n   * Create a new named collision group up to a max of 32.\r\n   * @param name Name for the collision group\r\n   * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one\r\n   */\r\n  public static create(name: string, mask?: number) {\r\n    if (this._CURRENT_GROUP > this._MAX_GROUPS) {\r\n      throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);\r\n    }\r\n    if (this._GROUPS.get(name)) {\r\n      throw new Error(`Collision group ${name} already exists`);\r\n    }\r\n    const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);\r\n    this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;\r\n    this._CURRENT_GROUP++;\r\n    this._GROUPS.set(name, group);\r\n    return group;\r\n  }\r\n\r\n  /**\r\n   * Get all collision groups currently tracked by excalibur\r\n   */\r\n  public static get groups(): CollisionGroup[] {\r\n    return Array.from(this._GROUPS.values());\r\n  }\r\n\r\n  /**\r\n   * Get a collision group by it's name\r\n   * @param name\r\n   */\r\n  public static groupByName(name: string) {\r\n    return this._GROUPS.get(name);\r\n  }\r\n\r\n  /**\r\n   * Resets the managers internal group management state\r\n   */\r\n  public static reset() {\r\n    this._GROUPS = new Map<string, CollisionGroup>();\r\n    this._CURRENT_BIT = this._STARTING_BIT;\r\n    this._CURRENT_GROUP = 1;\r\n  }\r\n}\r\n","import { Engine } from './../Engine';\r\nimport * as Events from './../Events';\r\nimport { Scene } from '../Scene';\r\nimport { ExcaliburGraphicsContext } from '../Graphics';\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _initialize {\r\n  _initialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n * Type guard checking for internal initialize method\r\n * @internal\r\n * @param a\r\n */\r\nexport function has_initialize(a: any): a is _initialize {\r\n  return !!a._initialize;\r\n}\r\n\r\nexport interface OnInitialize {\r\n  onInitialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnInitialize(a: any): a is OnInitialize {\r\n  return !!a.onInitialize;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _preupdate {\r\n  _preupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_preupdate(a: any): a is _preupdate {\r\n  return !!a._preupdate;\r\n}\r\n\r\nexport interface OnPreUpdate {\r\n  onPreUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPreUpdate(a: any): a is OnPreUpdate {\r\n  return !!a.onPreUpdate;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _postupdate {\r\n  _postupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_postupdate(a: any): a is _postupdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface OnPostUpdate {\r\n  onPostUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPostUpdate(a: any): a is OnPostUpdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface CanInitialize {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onInitialize(_engine: Engine): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<any>) => void): void;\r\n}\r\n\r\nexport interface SceneActivationContext<TData = undefined> {\r\n  data?: TData;\r\n  previousScene: Scene;\r\n  nextScene: Scene;\r\n  engine: Engine;\r\n}\r\n\r\nexport interface CanActivate<TData = undefined> {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onActivate(context: SceneActivationContext<TData>): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  once(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  off(eventName: Events.activate, handler?: (event: Events.ActivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanDeactivate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onDeactivate(context: SceneActivationContext<never>): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  once(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  off(eventName: Events.deactivate, handler?: (event: Events.DeactivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanUpdate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<any>) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<any>) => void): void;\r\n}\r\n\r\nexport interface OnPreDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n}\r\n\r\nexport interface OnPostDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\nexport interface CanDraw extends OnPreDraw, OnPostDraw {\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPreDraw(a: any): a is OnPreDraw {\r\n  return !!a.onPreDraw;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPostDraw(a: any): a is OnPostDraw {\r\n  return !!a.onPostDraw;\r\n}\r\n\r\nexport interface CanBeKilled {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  once(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  off(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  once(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  off(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n}\r\n","import { Resource } from './Resource';\r\nimport { Sprite } from '../Graphics/Sprite';\r\nimport { Color } from '../Color';\r\nimport { SpriteSheet } from '../Graphics/SpriteSheet';\r\nimport { Animation } from '../Graphics/Animation';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { ImageSource } from '../Graphics/ImageSource';\r\nimport { range } from '../Math/util';\r\n/**\r\n * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]\r\n * to pre-load before starting a level or game.\r\n */\r\nexport class Gif implements Loadable<ImageSource[]> {\r\n  private _resource: Resource<ArrayBuffer>;\r\n\r\n  /**\r\n   * The width of the texture in pixels\r\n   */\r\n  public width: number;\r\n\r\n  /**\r\n   * The height of the texture in pixels\r\n   */\r\n  public height: number;\r\n\r\n\r\n  private _stream: Stream = null;\r\n  private _gif: ParseGif = null;\r\n  private _textures: ImageSource[] = [];\r\n  private _animation: Animation = null;\r\n  private _transparentColor: Color = null;\r\n\r\n  public data: ImageSource[];\r\n\r\n  /**\r\n   * @param path       Path to the image resource\r\n   * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]\r\n   * @param bustCache  Optionally load texture with cache busting\r\n   */\r\n  constructor(public path: string, public color: Color = Color.Magenta, public bustCache = true) {\r\n    this._resource = new Resource(path, 'arraybuffer', bustCache);\r\n    this._transparentColor = color;\r\n  }\r\n\r\n  /**\r\n   * Begins loading the texture and returns a promise to be resolved on completion\r\n   */\r\n  public async load(): Promise<ImageSource[]> {\r\n    const arraybuffer = await this._resource.load();\r\n    this._stream = new Stream(arraybuffer);\r\n    this._gif = new ParseGif(this._stream, this._transparentColor);\r\n    const images = this._gif.images.map(i => new ImageSource(i.src, false));\r\n\r\n    // Load all textures\r\n    await Promise.all(images.map(t => t.load()));\r\n    return this.data = this._textures = images;\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  /**\r\n   * Return a frame of the gif as a sprite by id\r\n   * @param id\r\n   */\r\n  public toSprite(id: number = 0): Sprite {\r\n    const sprite = this._textures[id].toSprite();\r\n    return sprite;\r\n  }\r\n\r\n  /**\r\n   * Return the gif as a spritesheet\r\n   */\r\n  public toSpriteSheet(): SpriteSheet {\r\n    const sprites: Sprite[] = this._textures.map((image) => {\r\n      return image.toSprite();\r\n    });\r\n    return new SpriteSheet({ sprites });\r\n  }\r\n\r\n  /**\r\n   * Transform the GIF into an animation with duration per frame\r\n   */\r\n  public toAnimation(durationPerFrameMs: number): Animation {\r\n    const spriteSheet: SpriteSheet = this.toSpriteSheet();\r\n    const length = spriteSheet.sprites.length;\r\n    this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);\r\n    return this._animation;\r\n  }\r\n\r\n  public get readCheckBytes(): number[] {\r\n    return this._gif.checkBytes;\r\n  }\r\n}\r\n\r\nexport interface GifFrame {\r\n  sentinel: number;\r\n  type: string;\r\n  leftPos: number;\r\n  topPos: number;\r\n  width: number;\r\n  height: number;\r\n  lctFlag: boolean;\r\n  interlaced: boolean;\r\n  sorted: boolean;\r\n  reserved: boolean[];\r\n  lctSize: number;\r\n  lzwMinCodeSize: number;\r\n  pixels: number[];\r\n}\r\n\r\nconst bitsToNum = (ba: any) => {\r\n  return ba.reduce(function (s: number, n: number) {\r\n    return s * 2 + n;\r\n  }, 0);\r\n};\r\n\r\nconst byteToBitArr = (bite: any) => {\r\n  const a = [];\r\n  for (let i = 7; i >= 0; i--) {\r\n    a.push(!!(bite & (1 << i)));\r\n  }\r\n  return a;\r\n};\r\n\r\nexport class Stream {\r\n  data: any = null;\r\n  len: number = 0;\r\n  position: number = 0;\r\n\r\n  constructor(dataArray: ArrayBuffer) {\r\n    this.data = new Uint8Array(dataArray);\r\n    this.len = this.data.byteLength;\r\n    if (this.len === 0) {\r\n      throw new Error('No data loaded from file');\r\n    }\r\n  }\r\n\r\n  public readByte = () => {\r\n    if (this.position >= this.data.byteLength) {\r\n      throw new Error('Attempted to read past end of stream.');\r\n    }\r\n    return this.data[this.position++];\r\n  };\r\n\r\n  public readBytes = (n: number) => {\r\n    const bytes = [];\r\n    for (let i = 0; i < n; i++) {\r\n      bytes.push(this.readByte());\r\n    }\r\n    return bytes;\r\n  };\r\n\r\n  public read = (n: number) => {\r\n    let s = '';\r\n    for (let i = 0; i < n; i++) {\r\n      s += String.fromCharCode(this.readByte());\r\n    }\r\n    return s;\r\n  };\r\n\r\n  public readUnsigned = () => {\r\n    // Little-endian.\r\n    const a = this.readBytes(2);\r\n    return (a[1] << 8) + a[0];\r\n  };\r\n}\r\n\r\nconst lzwDecode = function (minCodeSize: number, data: any) {\r\n  // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\r\n  let pos = 0; // Maybe this streaming thing should be merged with the Stream?\r\n\r\n  const readCode = function (size: number) {\r\n    let code = 0;\r\n    for (let i = 0; i < size; i++) {\r\n      if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {\r\n        code |= 1 << i;\r\n      }\r\n      pos++;\r\n    }\r\n    return code;\r\n  };\r\n\r\n  const output: any[] = [];\r\n\r\n  const clearCode = 1 << minCodeSize;\r\n  const eoiCode = clearCode + 1;\r\n\r\n  let codeSize = minCodeSize + 1;\r\n\r\n  let dict: any[] = [];\r\n\r\n  const clear = function () {\r\n    dict = [];\r\n    codeSize = minCodeSize + 1;\r\n    for (let i = 0; i < clearCode; i++) {\r\n      dict[i] = [i];\r\n    }\r\n    dict[clearCode] = [];\r\n    dict[eoiCode] = null;\r\n  };\r\n\r\n  let code;\r\n  let last;\r\n\r\n  while (true) {\r\n    last = code;\r\n    code = readCode(codeSize);\r\n    if (code === clearCode) {\r\n      clear();\r\n      continue;\r\n    }\r\n    if (code === eoiCode) {\r\n      break;\r\n    }\r\n\r\n    if (code < dict.length) {\r\n      if (last !== clearCode) {\r\n        dict.push(dict[last].concat(dict[code][0]));\r\n      }\r\n    } else {\r\n      if (code !== dict.length) {\r\n        throw new Error('Invalid LZW code.');\r\n      }\r\n      dict.push(dict[last].concat(dict[last][0]));\r\n    }\r\n    output.push.apply(output, dict[code]);\r\n\r\n    if (dict.length === 1 << codeSize && codeSize < 12) {\r\n      // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\r\n      codeSize++;\r\n    }\r\n  }\r\n\r\n  // I don't know if this is technically an error, but some GIFs do it.\r\n  //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\r\n  return output;\r\n};\r\n\r\n// The actual parsing; returns an object with properties.\r\nexport class ParseGif {\r\n  private _st: Stream = null;\r\n  private _handler: any = {};\r\n  private _transparentColor: Color = null;\r\n  public frames: GifFrame[] = [];\r\n  public images: HTMLImageElement[] = [];\r\n  public globalColorTable: any[] = [];\r\n  public checkBytes: number[] = [];\r\n\r\n  constructor(stream: Stream, color: Color = Color.Magenta) {\r\n    this._st = stream;\r\n    this._handler = {};\r\n    this._transparentColor = color;\r\n    this.parseHeader();\r\n    this.parseBlock();\r\n  }\r\n\r\n  // LZW (GIF-specific)\r\n  parseColorTable = (entries: any) => {\r\n    // Each entry is 3 bytes, for RGB.\r\n    const ct = [];\r\n    for (let i = 0; i < entries; i++) {\r\n      const rgb: number[] = this._st.readBytes(3);\r\n      const rgba =\r\n        '#' +\r\n        rgb\r\n          .map((x: any) => {\r\n            const hex = x.toString(16);\r\n            return hex.length === 1 ? '0' + hex : hex;\r\n          })\r\n          .join('');\r\n      ct.push(rgba);\r\n    }\r\n    return ct;\r\n  };\r\n\r\n  readSubBlocks = () => {\r\n    let size, data;\r\n    data = '';\r\n    do {\r\n      size = this._st.readByte();\r\n      data += this._st.read(size);\r\n    } while (size !== 0);\r\n    return data;\r\n  };\r\n\r\n  parseHeader = () => {\r\n    const hdr: any = {\r\n      sig: null,\r\n      ver: null,\r\n      width: null,\r\n      height: null,\r\n      colorRes: null,\r\n      globalColorTableSize: null,\r\n      gctFlag: null,\r\n      sorted: null,\r\n      globalColorTable: [],\r\n      bgColor: null,\r\n      pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n    };\r\n\r\n    hdr.sig = this._st.read(3);\r\n    hdr.ver = this._st.read(3);\r\n    if (hdr.sig !== 'GIF') {\r\n      throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.\r\n    }\r\n\r\n    hdr.width = this._st.readUnsigned();\r\n    hdr.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    hdr.gctFlag = bits.shift();\r\n    hdr.colorRes = bitsToNum(bits.splice(0, 3));\r\n    hdr.sorted = bits.shift();\r\n    hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    hdr.bgColor = this._st.readByte();\r\n    hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n\r\n    if (hdr.gctFlag) {\r\n      hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));\r\n      this.globalColorTable = hdr.globalColorTable;\r\n    }\r\n    if (this._handler.hdr && this._handler.hdr(hdr)) {\r\n      this.checkBytes.push(this._handler.hdr);\r\n    }\r\n  };\r\n\r\n  parseExt = (block: any) => {\r\n    const parseGCExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 4\r\n\r\n      const bits = byteToBitArr(this._st.readByte());\r\n      block.reserved = bits.splice(0, 3); // Reserved; should be 000.\r\n      block.disposalMethod = bitsToNum(bits.splice(0, 3));\r\n      block.userInput = bits.shift();\r\n      block.transparencyGiven = bits.shift();\r\n\r\n      block.delayTime = this._st.readUnsigned();\r\n\r\n      block.transparencyIndex = this._st.readByte();\r\n\r\n      block.terminator = this._st.readByte();\r\n\r\n      if (this._handler.gce && this._handler.gce(block)) {\r\n        this.checkBytes.push(this._handler.gce);\r\n      }\r\n    };\r\n\r\n    const parseComExt = (block: any) => {\r\n      block.comment = this.readSubBlocks();\r\n      if (this._handler.com && this._handler.com(block)) {\r\n        this.checkBytes.push(this._handler.com);\r\n      }\r\n    };\r\n\r\n    const parsePTExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 12\r\n      block.ptHeader = this._st.readBytes(12);\r\n      block.ptData = this.readSubBlocks();\r\n      if (this._handler.pte && this._handler.pte(block)) {\r\n        this.checkBytes.push(this._handler.pte);\r\n      }\r\n    };\r\n\r\n    const parseAppExt = (block: any) => {\r\n      const parseNetscapeExt = (block: any) => {\r\n        this.checkBytes.push(this._st.readByte()); // Always 3\r\n        block.unknown = this._st.readByte(); // Q: Always 1? What is this?\r\n        block.iterations = this._st.readUnsigned();\r\n        block.terminator = this._st.readByte();\r\n        if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {\r\n          this.checkBytes.push(this._handler.app);\r\n        }\r\n      };\r\n\r\n      const parseUnknownAppExt = (block: any) => {\r\n        block.appData = this.readSubBlocks();\r\n        // FIXME: This won't work if a handler wants to match on any identifier.\r\n        if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {\r\n          this.checkBytes.push(this._handler.app[block.identifier]);\r\n        }\r\n      };\r\n\r\n      this.checkBytes.push(this._st.readByte()); // Always 11\r\n      block.identifier = this._st.read(8);\r\n      block.authCode = this._st.read(3);\r\n      switch (block.identifier) {\r\n        case 'NETSCAPE':\r\n          parseNetscapeExt(block);\r\n          break;\r\n        default:\r\n          parseUnknownAppExt(block);\r\n          break;\r\n      }\r\n    };\r\n\r\n    const parseUnknownExt = (block: any) => {\r\n      block.data = this.readSubBlocks();\r\n      if (this._handler.unknown && this._handler.unknown(block)) {\r\n        this.checkBytes.push(this._handler.unknown);\r\n      }\r\n    };\r\n\r\n    block.label = this._st.readByte();\r\n    switch (block.label) {\r\n      case 0xf9:\r\n        block.extType = 'gce';\r\n        parseGCExt(block);\r\n        break;\r\n      case 0xfe:\r\n        block.extType = 'com';\r\n        parseComExt(block);\r\n        break;\r\n      case 0x01:\r\n        block.extType = 'pte';\r\n        parsePTExt(block);\r\n        break;\r\n      case 0xff:\r\n        block.extType = 'app';\r\n        parseAppExt(block);\r\n        break;\r\n      default:\r\n        block.extType = 'unknown';\r\n        parseUnknownExt(block);\r\n        break;\r\n    }\r\n  };\r\n\r\n  parseImg = (img: any) => {\r\n    const deinterlace = (pixels: any, width: any) => {\r\n      // Of course this defeats the purpose of interlacing. And it's *probably*\r\n      // the least efficient way it's ever been implemented. But nevertheless...\r\n\r\n      const newPixels = new Array(pixels.length);\r\n      const rows = pixels.length / width;\r\n      const cpRow = (toRow: any, fromRow: any) => {\r\n        const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\r\n        newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\r\n      };\r\n\r\n      const offsets = [0, 4, 2, 1];\r\n      const steps = [8, 8, 4, 2];\r\n\r\n      let fromRow = 0;\r\n      for (let pass = 0; pass < 4; pass++) {\r\n        for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\r\n          cpRow(toRow, fromRow);\r\n          fromRow++;\r\n        }\r\n      }\r\n\r\n      return newPixels;\r\n    };\r\n\r\n    img.leftPos = this._st.readUnsigned();\r\n    img.topPos = this._st.readUnsigned();\r\n    img.width = this._st.readUnsigned();\r\n    img.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    img.lctFlag = bits.shift();\r\n    img.interlaced = bits.shift();\r\n    img.sorted = bits.shift();\r\n    img.reserved = bits.splice(0, 2);\r\n    img.lctSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    if (img.lctFlag) {\r\n      img.lct = this.parseColorTable(1 << (img.lctSize + 1));\r\n    }\r\n\r\n    img.lzwMinCodeSize = this._st.readByte();\r\n\r\n    const lzwData = this.readSubBlocks();\r\n\r\n    img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\r\n\r\n    if (img.interlaced) {\r\n      // Move\r\n      img.pixels = deinterlace(img.pixels, img.width);\r\n    }\r\n\r\n    this.frames.push(img);\r\n    this.arrayToImage(img);\r\n    if (this._handler.img && this._handler.img(img)) {\r\n      this.checkBytes.push(this._handler);\r\n    }\r\n  };\r\n\r\n  public parseBlock = () => {\r\n    const block = {\r\n      sentinel: this._st.readByte(),\r\n      type: ''\r\n    };\r\n    const blockChar = String.fromCharCode(block.sentinel);\r\n    switch (blockChar) {\r\n      case '!':\r\n        block.type = 'ext';\r\n        this.parseExt(block);\r\n        break;\r\n      case ',':\r\n        block.type = 'img';\r\n        this.parseImg(block);\r\n        break;\r\n      case ';':\r\n        block.type = 'eof';\r\n        if (this._handler.eof && this._handler.eof(block)) {\r\n          this.checkBytes.push(this._handler.eof);\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('Unknown block: 0x' + block.sentinel.toString(16));\r\n    }\r\n\r\n    if (block.type !== 'eof') {\r\n      this.parseBlock();\r\n    }\r\n  };\r\n\r\n  arrayToImage = (frame: GifFrame) => {\r\n    let count = 0;\r\n    const c = document.createElement('canvas');\r\n    c.id = count.toString();\r\n    c.width = frame.width;\r\n    c.height = frame.height;\r\n    count++;\r\n    const context = c.getContext('2d');\r\n    const pixSize = 1;\r\n    let y = 0;\r\n    let x = 0;\r\n    for (let i = 0; i < frame.pixels.length; i++) {\r\n      if (x % frame.width === 0) {\r\n        y++;\r\n        x = 0;\r\n      }\r\n      if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {\r\n        context.fillStyle = `rgba(0, 0, 0, 0)`;\r\n      } else {\r\n        context.fillStyle = this.globalColorTable[frame.pixels[i]];\r\n      }\r\n\r\n      context.fillRect(x, y, pixSize, pixSize);\r\n      x++;\r\n    }\r\n    const img = new Image();\r\n    img.src = c.toDataURL();\r\n    this.images.push(img);\r\n  };\r\n}\r\n","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Graphic } from './Graphic';\r\n\r\nexport interface LineOptions {\r\n  start: Vector;\r\n  end: Vector;\r\n  color?: Color;\r\n  thickness?: number;\r\n}\r\nexport class Line extends Graphic {\r\n  readonly start: Vector;\r\n  readonly end: Vector;\r\n  color: Color = Color.Black;\r\n  thickness: number = 1;\r\n  constructor(options: LineOptions) {\r\n    super();\r\n    const { start, end, color, thickness } = options;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.color = color ?? this.color;\r\n    this.thickness = thickness ?? this.thickness;\r\n    const { width, height } = BoundingBox.fromPoints([start, end]);\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n\r\n  protected _drawImage(ctx: ExcaliburGraphicsContext, _x: number, _y: number): void {\r\n    ctx.drawLine(this.start, this.end, this.color, this.thickness);\r\n  }\r\n\r\n  clone(): Line {\r\n    return new Line({\r\n      start: this.start,\r\n      end: this.end,\r\n      color: this.color,\r\n      thickness: this.thickness\r\n    });\r\n  }\r\n}","import { ImageFiltering } from '.';\r\nimport { Vector, vec } from '../Math/vector';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface PolygonOptions {\r\n  points: Vector[];\r\n}\r\n\r\n/**\r\n * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Polygons default to [[ImageFiltering.Blended]]\r\n */\r\nexport class Polygon extends Raster {\r\n  private _points: Vector[];\r\n  public get points(): Vector[] {\r\n    return this._points;\r\n  }\r\n  public set points(points: Vector[]) {\r\n    this._points = points;\r\n    const min = this.minPoint;\r\n    this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;\r\n    this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;\r\n    this.flagDirty();\r\n  }\r\n\r\n  public get minPoint() {\r\n    const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);\r\n    const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);\r\n    return vec(minX, minY);\r\n  }\r\n\r\n  constructor(options: RasterOptions & PolygonOptions) {\r\n    super(options);\r\n    this.points = options.points;\r\n    this.filtering = ImageFiltering.Blended;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Polygon {\r\n    return new Polygon({\r\n      points: this.points.map((p) => p.clone()),\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.points && this.points.length) {\r\n      ctx.beginPath();\r\n      // Iterate through the supplied points and construct a 'polygon'\r\n      const min = this.minPoint.negate();\r\n      const firstPoint = this.points[0].add(min);\r\n      ctx.moveTo(firstPoint.x, firstPoint.y);\r\n      this.points.forEach((point) => {\r\n        ctx.lineTo(point.x + min.x, point.y + min.y);\r\n      });\r\n      ctx.lineTo(firstPoint.x, firstPoint.y);\r\n      ctx.closePath();\r\n      if (this.color) {\r\n        ctx.fill();\r\n      }\r\n      if (this.strokeColor) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Future } from './Future';\r\n\r\nclass AsyncWaitQueue<T> {\r\n  // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e\r\n  private _queue: Future<T>[] = [];\r\n\r\n  public get length(): number {\r\n    return this._queue.length;\r\n  }\r\n\r\n  public enqueue(): Promise<T> {\r\n    const future = new Future<T>();\r\n    this._queue.push(future);\r\n    return future.promise;\r\n  }\r\n\r\n  public dequeue(value: T): void {\r\n    const future = this._queue.shift();\r\n    future.resolve(value);\r\n  }\r\n}\r\n\r\n/**\r\n * Semaphore allows you to limit the amount of async calls happening between `enter()` and `exit()`\r\n *\r\n * This can be useful when limiting the number of http calls, browser api calls, etc either for performance or to work\r\n * around browser limitations like max Image.decode() calls in chromium being 256.\r\n */\r\nexport class Semaphore {\r\n  private _waitQueue = new AsyncWaitQueue();\r\n  constructor(private _count: number) { }\r\n\r\n  public get count() {\r\n    return this._count;\r\n  }\r\n\r\n  public get waiting() {\r\n    return this._waitQueue.length;\r\n  }\r\n\r\n  public async enter() {\r\n    if (this._count !== 0) {\r\n      this._count--;\r\n      return Promise.resolve();\r\n    }\r\n    return this._waitQueue.enqueue();\r\n  }\r\n\r\n  public exit(count: number = 1) {\r\n    if (count === 0) {\r\n      return;\r\n    }\r\n    while (count !== 0 && this._waitQueue.length !== 0) {\r\n      this._waitQueue.dequeue(null);\r\n      count--;\r\n    }\r\n    this._count += count;\r\n  }\r\n}","/**\r\n * The current Excalibur version string\r\n * @description `process.env.__EX_VERSION` gets replaced by Webpack on build\r\n */\r\nexport const EX_VERSION = process.env.__EX_VERSION;\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\n\r\n// This file is used as the bundle entry point and exports everything\r\n// that will be exposed as the `ex` global variable.\r\nexport * from './Flags';\r\nexport * from './Id';\r\nexport * from './Engine';\r\nexport * from './Screen';\r\nexport { Actor, ActorArgs } from './Actor';\r\nexport * from './Math/Index';\r\nexport * from './Camera';\r\nexport * from './Class';\r\nexport * from './Configurable';\r\nexport * from './Debug/index';\r\nexport * from './EventDispatcher';\r\nexport * from './Events/MediaEvents';\r\nexport * from './Events';\r\nexport * from './Label';\r\nexport { FontStyle, FontUnit, TextAlign, BaseAlign } from './Graphics/FontCommon';\r\nexport * from './Loader';\r\nexport { Particle, ParticleEmitter, ParticleArgs, ParticleEmitterArgs, EmitterType } from './Particles';\r\nexport * from './Collision/Physics';\r\nexport * from './Scene';\r\n\r\nexport * from './TileMap/index';\r\n\r\nexport * from './Timer';\r\nexport * from './Trigger';\r\nexport * from './ScreenElement';\r\n\r\nexport * from './Actions/Index';\r\nexport * from './Collision/Index';\r\n\r\nexport * from './Interfaces/Index';\r\nexport * from './Resources/Index';\r\n\r\nexport * from './EntityComponentSystem/index';\r\n\r\nexport * from './Color';\r\n\r\nexport * from './Graphics/index';\r\n\r\n// ex.Events namespace\r\nimport * as events from './Events';\r\nexport { events as Events };\r\n\r\n// ex.Input namespace\r\nimport * as input from './Input/Index';\r\nexport { input as Input };\r\nexport { PointerComponent } from './Input/Index';\r\nexport { PointerSystem } from './Input/PointerSystem';\r\n\r\n// ex.Util namespaces\r\nimport * as util from './Util/Index';\r\nexport { util as Util };\r\n\r\nexport * from './Util/Browser';\r\nexport * from './Util/Decorators';\r\nexport * from './Util/Detector';\r\nexport * from './Util/EasingFunctions';\r\nexport * from './Util/Observable';\r\nexport * from './Util/Log';\r\nexport * from './Util/Pool';\r\nexport * from './Util/Fps';\r\nexport * from './Util/Clock';\r\nexport * from './Util/WebAudio';\r\nexport * from './Util/Toaster';\r\nexport * from './Util/StateMachine';\r\nexport * from './Util/Future';\r\nexport * from './Util/Semaphore';\r\n\r\n// ex.Deprecated\r\n// import * as deprecated from './Deprecated';\r\n// export { deprecated as Deprecated };\r\n// export * from './Deprecated';\r\n","import {\n  Actor,\n  CollisionType,\n  Color,\n  Engine,\n  vec,\n  ImageSource,\n  Sprite,\n  Animation,\n  Loader,\n} from \"excalibur\";\n\nconst imageSources = [\n  new ImageSource(require(\"./zombie/zombie1.png\")),\n  new ImageSource(require(\"./zombie/zombie2.png\")),\n  new ImageSource(require(\"./zombie/zombie3.png\")),\n  new ImageSource(require(\"./zombie/zombie4.png\")),\n  new ImageSource(require(\"./zombie/zombie5.png\")),\n  new ImageSource(require(\"./zombie/zombie6.png\")),\n];\n\nexport const loader = new Loader(imageSources);\n\nconst sprites = imageSources.map((imageSource) => {\n  return new Sprite({\n    image: imageSource,\n    sourceView: {\n      x: 0,\n      y: 0,\n      width: 500,\n      height: 500,\n    },\n    destSize: {\n      width: 100,\n      height: 100,\n    },\n  });\n});\n\nexport const zombieAnimation = new Animation({\n  frames: sprites.map((sprite) => {\n    return {\n      graphic: sprite,\n      duration: 100,\n    };\n  }),\n});\n","import {\n  Actor,\n  CollisionType,\n  Color,\n  Engine,\n  vec,\n  ImageSource,\n  Sprite,\n  Animation,\n  Loader,\n  RotationType,\n} from \"excalibur\";\nconst { loader, zombieAnimation } = require(\"./loader\");\n\nconst game = new Engine({});\nconst paddle = new Actor({\n  x: 450,\n  y: game.drawHeight - 50,\n  width: 200,\n  height: 20,\n  color: Color.Chartreuse,\n});\n\npaddle.body.collisionType = CollisionType.Fixed;\n\ngame.add(paddle);\n\ngame.input.pointers.primary.on(\"move\", (evt) => {\n  paddle.pos.x = evt.worldPos.x;\n});\n\nconst ball = new Actor({\n  x: 100,\n  y: 300,\n  // Use a circle collider with radius 10\n  radius: 10,\n  // Set the color\n  color: Color.Red,\n});\n// Start the serve after a second\nconst ballSpeed = vec(100, 100);\nsetTimeout(() => {\n  // Set the velocity in pixels per second\n  ball.vel = ballSpeed;\n}, 1000);\n\nball.graphics.use(zombieAnimation, {\n  anchor: vec(0.5, 0),\n});\n\n// Set the collision Type to passive\n// This means \"tell me when I collide with an emitted event, but don't let excalibur do anything automatically\"\nball.body.collisionType = CollisionType.Passive;\n// Other possible collision types:\n// \"ex.CollisionType.PreventCollision - this means do not participate in any collision notification at all\"\n// \"ex.CollisionType.Active - this means participate and let excalibur resolve the positions/velocities of actors after collision\"\n// \"ex.CollisionType.Fixed - this means participate, but this object is unmovable\"\n\n// Add the ball to the current scene\ngame.add(ball);\n// end-snippet{create-ball}\n\n// start-snippet{screen-collision}\n// Wire up to the postupdate event\nball.on(\"postupdate\", () => {\n  // If the ball collides with the left side\n  // of the screen reverse the x velocity\n  if (ball.pos.x < ball.width / 2) {\n    ball.vel.x = ballSpeed.x;\n    // rotate the ball\n    ball.actions.rotateTo(\n      Math.sin(ball.vel.x / ball.vel.y),\n      Math.PI,\n      RotationType.Clockwise\n    );\n  }\n\n  // If the ball collides with the right side\n  // of the screen reverse the x velocity\n  if (ball.pos.x + ball.width / 2 > game.drawWidth) {\n    ball.vel.x = ballSpeed.x * -1;\n    ball.actions.rotateTo(\n      Math.sin(ball.vel.x / ball.vel.y),\n      Math.PI,\n      RotationType.Clockwise\n    );\n  }\n\n  // If the ball collides with the top\n  // of the screen reverse the y velocity\n  if (ball.pos.y < ball.height / 2) {\n    ball.vel.y = ballSpeed.y;\n    ball.actions.rotateTo(\n      Math.sin(ball.vel.x / ball.vel.y),\n      Math.PI,\n      RotationType.Clockwise\n    );\n  }\n});\n// end-snippet{screen-collision}\n\n// start-snippet{create-bricks}\n// Build Bricks\n\n// Padding between bricks\nconst padding = 20; // px\nconst xoffset = 65; // x-offset\nconst yoffset = 20; // y-offset\nconst columns = 5;\nconst rows = 3;\n\nconst brickColor = [Color.Violet, Color.Orange, Color.Yellow];\n\n// Individual brick width with padding factored in\nconst brickWidth = game.drawWidth / columns - padding - padding / columns; // px\nconst brickHeight = 30; // px\nconst bricks: Actor[] = [];\nfor (let j = 0; j < rows; j++) {\n  for (let i = 0; i < columns; i++) {\n    bricks.push(\n      new Actor({\n        x: xoffset + i * (brickWidth + padding) + padding,\n        y: yoffset + j * (brickHeight + padding) + padding,\n        width: brickWidth,\n        height: brickHeight,\n        color: brickColor[j % brickColor.length],\n      })\n    );\n  }\n}\n\nbricks.forEach(function (brick) {\n  // Make sure that bricks can participate in collisions\n  brick.body.collisionType = CollisionType.Active;\n\n  // Add the brick to the current scene to be drawn\n  game.add(brick);\n});\n// end-snippet{create-bricks}\n\n// start-snippet{ball-brick-collision}\n// On collision remove the brick, bounce the ball\nlet colliding = false;\nball.on(\"collisionstart\", function (ev) {\n  if (bricks.indexOf(ev.other) > -1) {\n    // kill removes an actor from the current scene\n    // therefore it will no longer be drawn or updated\n    ev.other.kill();\n  }\n\n  // reverse course after any collision\n  // intersections are the direction body A has to move to not be clipping body B\n  // `ev.content.mtv` \"minimum translation vector\" is a vector `normalize()` will make the length of it 1\n  // `negate()` flips the direction of the vector\n  var intersection = ev.contact.mtv.normalize();\n\n  // Only reverse direction when the collision starts\n  // Object could be colliding for multiple frames\n  if (!colliding) {\n    colliding = true;\n    // The largest component of intersection is our axis to flip\n    if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\n      ball.vel.x *= -1;\n    } else {\n      ball.vel.y *= -1;\n    }\n\n    ball.actions.rotateTo(\n      Math.sin(ball.vel.x / ball.vel.y),\n      Math.PI,\n      RotationType.Clockwise\n    );\n  }\n});\n\nball.on(\"collisionend\", () => {\n  // ball has separated from whatever object it was colliding with\n  colliding = false;\n});\n\n// end-snippet{ball-brick-collision}\n\n// start-snippet{lose-condition}\n// Loss condition\nball.on(\"exitviewport\", () => {\n  alert(\"You lose!\");\n});\n// end-snippet{lose-condition}\n\n// start-snippet{start-game}\n// Start the engine to begin the game.\ngame.start(loader);\n// end-snippet{start-game}\n"],"names":["$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","module","exports","URL","parcelRequire","resolve","import","meta","url","toString","register","JSON","parse","__webpack_require__","entryUnbind","path","isCallable","tryToString","$TypeError","TypeError","argument","isObject","$String","String","toIndexedObject","toAbsoluteIndex","lengthOfArrayLike","createMethod","IS_INCLUDES","$this","el","fromIndex","value","O","index","includes","indexOf","fails","METHOD_NAME","method","call","createProperty","$Array","Array","max","Math","start","end","k","fin","undefined","result","n","arraySlice","floor","mergeSort","array","comparefn","middle","insertionSort","merge","element","j","left","right","llength","rlength","lindex","rindex","uncurryThis","stringSlice","slice","it","TO_STRING_TAG_SUPPORT","classofRaw","TO_STRING_TAG","wellKnownSymbol","$Object","CORRECT_ARGUMENTS","arguments","tag","key","error","tryGet","callee","hasOwn","ownKeys","getOwnPropertyDescriptorModule","definePropertyModule","target","source","exceptions","defineProperty","f","getOwnPropertyDescriptor","DESCRIPTORS","createPropertyDescriptor","object","bitmap","enumerable","configurable","writable","toPropertyKey","propertyKey","makeBuiltIn","defineGlobalProperty","options","simple","name","global","unsafe","nonConfigurable","nonWritable","P","get","document1","document","EXISTS","createElement","firefox","match","UA","test","getBuiltIn","version","userAgent","process","Deno","versions","v8","split","webkit","CONSTRUCTOR","METHOD","prototype","createNonEnumerableProperty","defineBuiltIn","copyConstructorProperties","isForced","targetProperty","sourceProperty","descriptor","TARGET","GLOBAL","STATIC","stat","dontCallGetSet","forced","sham","exec","bind","hasOwnProperty","NATIVE_BIND","Function","apply","FunctionPrototype","getDescriptor","PROPER","CONFIGURABLE","fn","aFunction","namespace","aCallable","V","func","check","globalThis","window","self","g","this","toObject","a","classof","propertyIsEnumerable","store","functionToString","inspectSource","set","has","NATIVE_WEAK_MAP","shared","sharedKey","hiddenKeys","OBJECT_ALREADY_INITIALIZED","TypeError1","WeakMap1","WeakMap","state","wmget","wmhas","wmset","metadata","facade","STATE","enforce","getterFor","TYPE","type","replacement","feature","detection","data","normalize","POLYFILL","NATIVE","string","replace","toLowerCase","isPrototypeOf","USE_SYMBOL_AS_UID","$Symbol","toLength","obj","CONFIGURABLE_FUNCTION_NAME","InternalStateModule","enforceInternalState","getInternalState","CONFIGURABLE_LENGTH","TEMPLATE","getter","setter","arity","constructor","join","ceil","trunc","x","V8_VERSION","getOwnPropertySymbols","symbol","Symbol","IE8_DOM_DEFINE","V8_PROTOTYPE_DEFINE_BUG","anObject","$defineProperty","$getOwnPropertyDescriptor","ENUMERABLE","WRITABLE","Attributes","current","propertyIsEnumerableModule","internalObjectKeys","concat","getOwnPropertyNames","push","names","enumBugKeys","$propertyIsEnumerable","NASHORN_BUG","input","pref","val","valueOf","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","uid","SHARED","IS_PURE","mode","copyright","license","toIntegerOrInfinity","min","integer","IndexedObject","requireObjectCoercible","number","isSymbol","getMethod","ordinaryToPrimitive","TO_PRIMITIVE","exoticToPrim","toPrimitive","postfix","random","NATIVE_SYMBOL","iterator","WellKnownSymbolsStore","Symbol1","symbolFor","createWellKnownSymbol","withoutSetter","description","$","deletePropertyOrThrow","internalSort","arrayMethodIsStrict","FF","IE_OR_EDGE","V8","WEBKIT","un$Sort","sort","FAILS_ON_UNDEFINED","FAILS_ON_NULL","STRICT_METHOD","STABLE_SORT","code","chr","fromCharCode","v","b","charAt","proto","itemsLength","items","arrayLength","y","getSortCompare","nativeKeys","___CSS_LOADER_EXPORT___","_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default","_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default","sources","mappings","sourcesContent","sourceRoot","__WEBPACK_DEFAULT_EXPORT__","cssWithMappingToString","list","map","item","content","needLayer","modules","media","dedupe","supports","layer","alreadyImportedModules","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","stringify","sourceMapping","sourceURLs","$2c23f148d58cd887$var$__webpack_module_cache__","$2c23f148d58cd887$var$__webpack_require__","moduleId","cachedModule","$2c23f148d58cd887$var$__webpack_modules__","__esModule","d","definition","o","e","prop","r","toStringTag","polyfill","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setInterval","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","AudioContext","webkitAudioContext","replaceMe","decodeAudioData","arrayBuffer","Promise","reject","mozAudioContext","msAudioContext","oAudioContext","devicePixelRatio","Flags","enable","_FROZEN","_FLAGS","flagName","createId","seed","_lowerMask","_upperMask","_w","_n","_m","_a","_u","_s","_b","_t","_c","_l","_f","_mt","Date","now","s","_index","mag01","BITMASK32","_twist","next","nextInt","bool","likelihood","pickOne","pickSet","numPicks","allowDuplicates","_pickSetWithDuplicates","_pickSetWithoutDuplicates","currentPick","tempArray","splice","swap","randomIndex","d4","d10","d20","TwoPI","PI","frac","sign","clamp","canonicalizeAngle","angle","tmpAngle","toDegrees","radians","degrees","from","to","_x","randomInRange","Random","floating","randomIntInRange","round","_y","Zero","Vector","One","Half","Up","Down","Left","Right","static","cos","sin","vec","isNaN","Infinity","vec1","vec2","sqrt","pow","vector","tolerance","abs","deltaY","deltaX","magnitude","newSize","size","distance","newLength","scale","setTo","add","sizeOrScale","dest","num","perpendicular","atan2","anchor","sinAngle","cosAngle","clone","fixed","toFixed","LogLevel","EventTypes","Logger","_appenders","defaultLevel","Info","_INSTANCE","addAppender","ConsoleAppender","appender","_log","level","args","len","log","debug","Debug","Warn","Fatal","console","warn","consoleArgs","unshift","ScreenAppender","width","height","_messages","_canvas","innerWidth","innerHeight","style","position","_ctx","getContext","body","appendChild","message","clearRect","pos","opacity","fillStyle","fillText","Color","parseInt","parseFloat","hex","h","l","HSLColor","toRGBA","factor","temp","fromRGBA","desaturate","color","newR","newG","newB","newA","color1","invert","color2","multiply","equal","format","toHSLA","toHex","c","_componentToHex","fromHex","White","Gray","LightGray","DarkGray","Yellow","Orange","Red","Vermilion","Rose","Magenta","Violet","Blue","Azure","Cyan","Viridian","Green","Chartreuse","Transparent","ExcaliburBlue","p","q","t","hue2rgb","Side","getOpposite","side","Top","Bottom","None","fromDirection","direction","directions","directionEnum","Number","MAX_VALUE","maxIndex","dot","leftOrOptions","top","bottom","BoundingBox","intersection","points","minX","minY","maxX","maxY","center","point","getPoints","rotate","fromPoints","shifted","translate","matrix","xa1","xa2","xb1","xb2","ya1","ya2","yb1","yb2","matrixPos","getPosition","results","ray","farClipDistance","tmin","tmax","xinv","dir","yinv","tx1","tx2","ty1","ty2","other","dimensions","epsilon","hasZeroDimensions","contains","totalBoundingBox","combine","equals","overlapX","overlapY","overlapX1","overlapY1","bb","intersect","getSideFromIntersection","ex","drawRect","_isCompleted","promise","_resolver","_rejecter","isCompleted","oLeft","oTop","calcOffsetLeft","parent","offsetLeft","offsetParent","calcOffsetTop","offsetTop","addItemToArray","removeItemFromArray","milliseconds","clock","Future","schedule","setTimeout","MatrixLocations","Matrix","Float32Array","_scaleX","_scaleSignX","_scaleY","_scaleSignY","near","far","mat","DOMMatrix","identity","sx","sy","angleRadians","vectorOrMatrix","resultX","resultY","result1","a11","a21","a31","a41","a12","a22","a32","a42","a13","a23","a33","a43","a14","a24","a34","a44","b11","b21","b31","b41","b12","b22","b32","b42","b13","b23","b33","b43","b14","b24","b34","b44","getScale","sine","cosine","currentScale","getScaleY","getScaleX","xscale","yscale","setScaleX","setScaleY","inverseDet","getBasisDeterminant","m","tx","ty","isIdentity","Float64Array","_scale","toDOMMatrix","AffineMatrix","determinant","to4x4","setRotation","_transforms","_currentTransform","pop","_states","_currentState","_getDefaultState","z","tint","_cloneState","_bubbles","bubbles","stopPropagation","KillEvent","GameEvent","super","PreKillEvent","GameStartEvent","ctx","delta","engine","PostUpdateEvent","PreFrameEvent","prevStats","stats","gamepad","button","axis","PreCollisionEvent","actor","ContactStartEvent","contact","context","ExitViewPortEvent","ExitTriggerEvent","_handlers","_wiredEventDispatchers","_deferedHandlerRemovals","_processDeferredHandlerRemovals","eventHandler","_removeHandler","handler","eventName","event","emit","eventHandlers","once","metaHandler","ev","off","on","eventDispatcher","Resource","responseType","bustCache","logger","getInstance","events","EventDispatcher","uri","request","XMLHttpRequest","open","_cacheBust","addEventListener","status","response","statusText","send","watch","change","__isProxy","Proxy","_d","_e","Graphic","_ID","transform","_transformStale","showDebug","_flipHorizontal","_flipVertical","_rotation","_origin","_width","_height","origin","flipHorizontal","flipVertical","rotation","localBounds","fromDimension","_preDraw","_drawImage","_postDraw","reset","_rotate","_flip","scaleDirX","scaleDirY","_logger","_dirty","_logNotLoadedWarning","image","sourceView","destSize","_updateSpriteDimensions","ready","then","Sprite","newWidth","newHeight","nativeWidth","nativeHeight","isLoaded","drawImage","cloneGraphicOptions","ImageFiltering","TextureLoader","_GL","_MAX_TEXTURE_SIZE","getParameter","MAX_TEXTURE_SIZE","_TEXTURE_MAP","filtering","forceUpdate","gl","tex","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","createTexture","checkImageSizeSupportedAndLog","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","filterMode","TEXTURE_MIN_FILTER","Pixel","NEAREST","LINEAR","TEXTURE_MAG_FILTER","deleteTexture","originalSrc","dataset","_LOGGER","Blended","Map","ImageSource","Image","_readyFuture","endsWith","naturalWidth","naturalHeight","_src","src","blob","_resource","load","createObjectURL","loadedFuture","onload","setAttribute","_filtering","SpriteSheet","sprites","rows","columns","spriteIndex","sourceViews","spacing","grid","cols","spriteWidth","spriteHeight","originOffset","margin","offsetDefaults","marginDefaults","_text","alphabet","shadow","caseInsensitive","spriteSheet","text","textToRender","toLocaleLowerCase","letterIndex","letter","_alreadyWarnedAlphabet","letterSprite","_alreadyWarnedSpriteSheet","lines","maxWidthLine","reduce","_getCharacterSprites","sprite","xCursor","yCursor","line","draw","_color","bounds","measureText","save","offset","restore","SpriteFont","DebugText","fontSheet","_imageSource","_spriteSheet","fromImageSource","_spriteFont","render","RenderSource","_gl","_texture","TEXTURE0","_setupFramebuffer","_frameTexture","_frameBuffer","attachmentPoint","COLOR_ATTACHMENT0","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","disable","use","viewport","ExcaliburWebGLContextAccessor","getGlTypeSizeBytes","FLOAT","SHORT","UNSIGNED_SHORT","BYTE","getAttributeComponentSize","LOW_FLOAT","HIGH_FLOAT","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","getAttributePointerType","uniforms","attributes","_compiled","vertexSource","fragmentSource","useProgram","program","Shader","_ACTIVE_SHADER_INSTANCE","vertexShader","_compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","_createProgram","getAttributes","attribute","getUniforms","uniform","uniformCount","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","uniformLocation","getUniformLocation","glType","location","attributeCount","ACTIVE_ATTRIBUTES","getActiveAttrib","attributeLocation","getAttribLocation","normalized","slotNumber","texture","activeTexture","setUniform","setUniformFloat","setUniformMatrix","uniformType","isCurrentlyBound","createProgram","attachShader","linkProgram","LINK_STATUS","getProgramInfoLog","typeName","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","errorInfo","getShaderInfoLog","_processSourceForError","errorLineStart","search","errorLineEnd","_","error2","buffer","createBuffer","bufferData","bindBuffer","ARRAY_BUFFER","STATIC_DRAW","DYNAMIC_DRAW","count","bufferSubData","_layout","_attributes","_vertexTotalSizeBytes","vertexBuffer","_vertexBuffer","_shader","initialize","totalVertexSizeBytes","compiled","shaderAttributes","attrib","componentsPerVertex","vertAttribute","typeSize","uploadBuffer","upload","vert","vertexAttribPointer","enableVertexAttribArray","GraphicsDiagnostics","DrawCallCount","DrawnImagesCount","priority","_maxLines","_vertexIndex","_lineCount","_context","compile","ortho","VertexBuffer","VertexLayout","_isFull","flush","getTransform","finalStart","finalEnd","drawArrays","LINES","_maxPoints","_pointCount","_buffer","snapToPixel","finalPoint","pixelSnapEpsilon","POINTS","postprocessor","getShader","getLayout","TRIANGLES","numberOfQuads","useUint16","ELEMENT_ARRAY_BUFFER","totalVertices","maxUint16","maxUint16Index","bufferGlType","Uint16Array","Uint32Array","currentQuad","ImageRenderer","_maxImages","_maxTextures","_imageCount","_textures","MAX_TEXTURE_IMAGE_UNITS","transformedFrag","_transformFragmentSource","setUniformIntArray","_quads","QuadIndexBuffer","maxTextures","newSource","texturePickerBuilder","_bindTextures","swidth","sheight","dx","dy","dwidth","dheight","_addImageAsTexture","view","sw","sh","topLeft","topRight","bottomLeft","bottomRight","textureId","_getTextureIdForImage","imageWidth","imageHeight","uvx0","uvy0","uvx1","uvy1","drawElements","RectangleRenderer","_maxRectangles","_rectangleCount","drawLine","drawRectangle","thickness","sub","normal","halfThick","startTop","endTop","endBottom","startBottom","stroke","strokeThickness","hasPendingDraws","CircleRenderer","_maxCircles","_circleCount","radius","builder","recycler","maxObjects","totalAllocations","objects","disableWarnings","done","poolIndex","_webglCtx","rectOptions","Black","lineOptions","pointOptions","write","_renderers","useDrawSorting","_drawCallPool","Pool","DrawCall","instance","renderer","_drawCalls","_postProcessTargets","_postprocessors","_transform","TransformStack","_state","StateStack","smoothing","backgroundColor","_alreadyWarnedDrawLifecycle","ExcaliburGraphicsContextWebGLDebug","canvasElement","enableTransparency","__gl","antialias","premultipliedAlpha","alpha","depth","powerPreference","preallocate","_init","canvas","_ortho","dim","supported","clearColor","clear","COLOR_BUFFER_BIT","BLEND","blendEquation","FUNC_ADD","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","blendEquationSeparate","blendFuncSeparate","PointRenderer","LineRenderer","_screenRenderer","ScreenPassPainter","_renderTarget","RenderTarget","rendererName","_currentRenderer","_isDrawLifecycle","drawCall","_isCurrentRenderer","resetTransform","updateViewport","resolution","setResolution","trace","drawCircle","originalSort","firstIndex","findIndex","dc","zIndex","originalSortOrder","oldTransform","oldState","currentRendererName","currentRenderer","values","toRenderSource","i1","renderWithPostProcessor","renderToScreen","_ex","_debugText","__ctx","strokeStyle","strokeRect","ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon","beginPath","moveTo","lineTo","lineWidth","closePath","arc","fill","ExcaliburGraphicsContext2DCanvasDebug","imageSmoothingEnabled","globalAlpha","fillRect","setTransform","_postprocessor","beginDrawLifecycle","DisplayMode","SVGA","Standard","Atari2600","GameBoy","GameBoyAdvance","NintendoDS","NES","SNES","Screen","_antialiasing","_resolutionStack","_viewportStack","_pixelRatioOverride","_isFullScreen","_isDisposed","_fullscreenChangeHandler","_pixelRatioChangeHandler","_listenForPixelRatio","_devicePixelRatio","_calculateDevicePixelRatio","applyResolutionAndViewport","_resizeHandler","_contentResolution","_displayMode","displayMode","Fixed","antialiasing","_browser","browser","pixelRatio","_applyDisplayMode","_mediaQueryList","removeListener","nativeComponent","matchMedia","addListener","_resizeObserver","disconnect","removeEventListener","isHiDpi","FillContainer","FitContainer","FitContainerAndFill","FitContainerAndZoom","parentElement","_resolution","_viewport","scaledWidth","camera","_camera","peekResolution","scaledHeight","graphicsContext","ExcaliburGraphicsContextWebGL","checkIfResolutionSupported","_alreadyWarned","imageRendering","ExcaliburGraphicsContext2DCanvas","isSmooth","isFullScreen","elementId","maybeElement","getElementById","requestFullscreen","exitFullscreen","newX","newY","aspectRatio","screenHeight","screenWidth","screenMarginY","screenMarginX","inverse","pageToScreenCoordinates","screenToWorldCoordinates","screen","worldToScreenCoordinates","screenToPageCoordinates","drawWidth","drawHeight","canvasWidth","zoom","halfDrawWidth","halfDrawHeight","_contentArea","overflow","aspect","adjustedWidth","adjustedHeight","_computeFitAndFill","vw","vh","clientWidth","clientHeight","clip","clip1","_computeFitAndZoom","scaleX","scaleY","zoomedWidth","maxScaleFactor","zoomedHeight","_setResolutionAndViewportByDisplayMode","Window","ResizeObserver","observe","FillScreen","FitScreen","_computeFit","_computeFitContainer","FitScreenAndFill","_computeFitScreenAndFill","_computeFitContainerAndFill","FitScreenAndZoom","_computeFitScreenAndZoom","_computeFitContainerAndZoom","AudioContextFactory","audioContext","create","resume","createBufferSource","ended","connect","destination","onended","playbackState","isLegacyWebAudioSource","currentTime","WebAudio","_UNLOCKED","PLAYING_STATE","FINISHED_STATE","clearTimeout","unlockTimeoutTimer","Class","eventObject","x1","y1","x2","y2","cap","lineCap","roundRect","br","tl","tr","bl","defaultRadius","quadraticCurveTo","Raster","_g","_h","_j","quality","_smoothing","flagDirty","_lineWidth","_lineDash","_padding","strokeColor","lineDash","padding","_bitmap","bitmapHeight","bitmapWidth","maybeCtx","_getTotalWidth","_originalWidth","_getTotalHeight","_originalHeight","_strokeColor","_applyRasterProperties","execute","setLineDash","getLineDash","rasterize","Canvas","_options","cloneRasterOptions","cache","ExResponse","StateMachine","states","currentState","machineDescription","machine","stateName","transitionState","transitions","startState","eventData","potentialNewState","onExit","onEnter","onState","elapsedMs","onUpdate","saveKey","localStorage","setItem","getItem","WebAudioInstance","_audioContext","_volumeNode","createGain","_playingPromise","_playingResolve","_stateMachine","PLAYING","_createNewBufferSource","_handleEnd","_instance","pausedAt","_playbackRate","duration","startedAt","_playStarted","stop","SEEK","STOPPED","PAUSED","_volume","_loop","loop","playbackRate","in","gain","setTargetAtTime","_duration","getTotalPlaybackDuration","playStarted","go","_name","_value","_path","_val","_actor","MediaEvent","track","_processedData","file","Audio","filetype","canPlayType","paths","arraybuffer","canPlayFile","_tracks","volume","NativeSoundEvent","instances","async","audiobuffer","decodeAudio","NativeSoundProcessedEvent","_engine","pauseAudioWhenHidden","isPlaying","_wasPlayingOnHidden","pause","play","_isStopped","some","isPaused","_resumePlayback","_startPlayback","forEach","trackId","_getTrackInstance","seek","getPlaybackPosition","resumed","getTrackId","all","newTrack","Loader","loadables","_resourceList","_playButtonShown","_resourceCount","_numLoaded","_progressCounts","logo","logoWidth","logoHeight","loadingBarColor","suppressPlayButton","_playButtonStyles","Loader_0","Z","playButtonText","startButtonFactory","buttonElement","textContent","display","_loadingFuture","addResources","_image","_imageElement","_playButtonRootElement","playButtonElement","_playButtonElement","existingRoot","_styleBlock","head","loadable","_totalCounts","addResource","resizeHandler","_positionPlayButton","_playButton","evt","click","playButtonClicked","startButtonHandler","hidePlayButton","delay","removeChild","_delta","decode","finally","resource","Sound","wireEngine","showPlayButton","unlock","markResourceComplete","progress","buttonWidth","buttonHeight","playButtonPosition","canvasHeight","logoY","logoX","logoPosition","oldAntialias","getAntialiasing","setAntialiasing","loadingX","loadingY","loadingBarPosition","progressWidth","REPORTED_FEATURES","webgl","webaudio","gamepadapi","Detector","_features","failedTests","_criticalTests","canvasSupport","elem","arrayBufferSupport","xhr","dataUrlSupport","toDataURL","objectUrlSupport","rgbaSupport","cssText","_warningTest","webAudioSupport","webglSupport","_loadBrowserFeatures","msg","getBrowserFeatures","dataurl","objecturl","rgba","navigator","getGamepads","failedCritical","warning","CollisionType","obsoleteMessage","suppressObsoleteMessages","isEnabled","maxMessages","showStackTrace","obsolete","alternateMethod","property","SyntaxError","DecoratedClass","logMessage","CollisionResolutionStrategy","BroadphaseStrategy","Integrator","Physics","acc","gravity","collisionResolutionStrategy","Arcade","Realistic","dynamicTreeVelocityMultiplier","dynamicTreeVelocityMultiplyer","enabled","broadphaseStrategy","DynamicAABBTree","defaultMass","integrator","Euler","boundsPadding","positionIterations","velocityIterations","steeringFactor","warmStart","bodiesCanSleepByDefault","surfaceEpsilon","sleepEpsilon","wakeThreshold","sleepBias","checkForFastBodies","decorators","desc","Reflect","decorate","CoordPlane","_getX","getX","_getY","getY","_setX","setX","_setY","setY","WatchVector","original","_parent","_children","_isDirty","_isInverseDirty","_matrix","_inverse","_pos","globalPos","localPos","VectorView","canonRotation","globalRotation","inverseRotation","getRotation","globalScale","inverseScale","globalScaleX","globalScaleY","_calculateMatrix","Transform","owner","newComponent","TagComponent","Component","observers","subscriptions","observer","observersLength","notify","subscriptionsLength","_addChildTransform","child","childTxComponent","TransformComponent","_z","coordPlane","World","children","childrenAdded$","subscribe","childrenRemoved$","_previousOwner","oldz","zIndexChanged$","notifyAll","applyInverse","vel","scaleFactor","angularVelocity","torque","inertia","category","mask","_category","_mask","CollisionGroup","collisionGroups","combinedName","combinedCategory","All","colliderA","colliderB","Pair","calculatePairHash","bodyA","BodyComponent","bodyB","group","canCollide","collisionType","PreventCollision","active","collide","collider","idA","idB","projection","getOverlap","overlaps","TreeNode","worldBounds","root","nodes","_insert","leaf","leafAABB","currentRoot","isLeaf","area","getPerimeter","combinedArea","cost","inheritanceCost","leftCost","leftCombined","newArea","oldArea","rightCost","rightCombined","oldParent","newParent","currentNode","_balance","grandParent","sibling","trackCollider","node","untrackCollider","_remove","multdx","multdy","balance","helper","rayCast","numerator","begin","cross","getSlope","divisor","u","getLength","time","getPoint","DynamicTreeCollisionProcessor","_dynamicCollisionTree","DynamicTree","_pairs","Set","_collisionPairCache","_colliders","colliders","getColliders","CompositeCollider","index1","hash","targets","seconds","potentialColliders","filter","query","_pairExists","pair","physics","collider1","Active","updateDistance","minDimension","disableMinimumSpeedForFastBody","fastBodies","updateVec","oldPos","centerPoint","furthestPoint","getFurthestPoint","Ray","minTranslate","rayCastQuery","hitPoint","minCollider","isValid","shift","update","fastBodyCollisions","contacts","newContacts","collisions","updated","updateCollider","Collider","__compositeColliderId","_collisionProcessor","_dynamicAABBTree","addCollider","wire","unwire","untrack","worldPos","axes","furthestPoints","bestPoint","maxDistance","getInertia","mass","totalInertia","otherColliders","potentialCollider","maybeLine","getClosestLineBetween","maybeLine1","minLine","minLength","minPoint","minDistance","projs","proj","project","newProjection","Projection","proj1","LineSegment","intercept","slope","_normal","_dir","_slope","_length","midpoint","sideVector","clipTime","signed","x0","y0","aMinusP","currPoint","threshold","dyc","dx1","dy1","dxc","ClosestLine","p0","q0","w0","denom","sDenom","tDenom","tClosestParallel","sClosest","tClosest","polygonA","polygonB","otherWorldPos","otherDirection","thisDirection","negate","rayTowardsOther","rayTowardsThis","thisPoint","otherPoint","thisFace","getClosestFace","otherFace","face","getEdge","polygon","edge","edgeLine","asLine","circle","circlex","circley","circleA","circleB","circleWorlPos","edgeA","edgeB","edgeLineA","edgeLineB","CircleCollider","_globalMatrix","_naturalRadius","orig","discriminant","toi","toi1","toi2","positiveToi","mintoi","shape","ClosestLineJumpTable","CircleCircleClosestLine","PolygonCollider","PolygonCircleClosestLine","flip","EdgeCollider","CircleEdgeClosestLine","CollisionJumpTable","CollideCircleCircle","CollideCirclePolygon","CollideCircleEdge","scalars","dotProduct","mtv","tangent","localPoints","info","_canceled","sleeping","sleepMotion","setSleeping","cancel","polyA","polyB","bestSeparation","bestSide","bestAxis","bestSideIndex","bestOtherPoint","sides","getSides","localSides","getLocalSides","vertB","vertSeparation","distanceToPoint","separation","localSide","sideId","localPoint","getFurthestLocalPoint","polyDir","closestPointOnPoly","minOverlap","minAxis","minIndex","proj2","overlap","circleAPos","circleBPos","combinedRadius","CollisionContact","mvt","local","SeparatingAxis","findCirclePolygonSeparation","samedir","findSide","findLocalSide","edgeWorld","cc","asLocalLine","da","dda","db","ddb","normal1","separation1","info1","den","pointOnEdge","dd","normal2","separation2","info2","CollideEdgeEdge","pc","linePoly","CollidePolygonPolygon","separationA","findPolygonPolygonSeparation","separationB","incident","reference","refDir","clipRight","clipLeft","below","xf","xf1","FindContactSeparation","shapeA","txA","shapeB","txB","worldPoint","worldPoint1","worldPoint2","worldPoint3","circlePoint","dist","_getTransformedBegin","_getTransformedEnd","average","PolygonEdgeClosestLine","EdgeEdgeClosestLine","CollidePolygonEdge","transformedBegin","transformedEnd","_boundsFromBeginEnd","edgeNormal","_transformedPoints","_sides","_localSides","_transformedPointsDirty","_sidesDirty","_localSidesDirty","_localBoundsDirty","_isCounterClockwiseWinding","reverse","isConvex","_calculateTransformation","_points","sum","oldPoint","newPoint","oldDirection","orientation","angleSum","entries","polygons","Shape","Polygon","isPointInTriangle","ab","bc","ca","ap","bp","cp","cross1","cross2","cross3","vertices","indices","range","va","vb","vc","leftArm","isEar","vertIndex","triangles","getTransformedPoints","currentSide","mostDirection","testRay","accum","PolygonPolygonClosestLine","pts","POSITIVE_INFINITY","faceIndex","_localBounds","_cachedMass","_cachedInertia","denominator","iplusone","crossTerm","minContactTime","contactIndex","contactTime","scalar","firstPoint","Circle","Box","$colliderAdded","Observable","$colliderRemoved","_collider","flipped","entity","precollision","postcollision","PostCollisionEvent","CollisionStartEvent","CollisionEndEvent","poly","Edge","useCompositeCollider","BaseAlign","Axis","DegreeOfFreedom","dependencies","MotionComponent","_oldTransform","__oldTransformCaptured","enableFixedUpdateInterpolate","canSleep","_sleeping","bounciness","friction","useGravity","limitDegreeOfFreedom","oldVel","oldAcc","_mass","newMass","_cachedInverseInertia","inverseMass","bias","currentMotion","ColliderComponent","maybeCollider","inverseInertia","motion","oldRotation","oldScale","applyImpulse","impulse","finalImpulse","X","Y","addEqual","Rotation","distanceFromCenter","AddedComponent","isAddedComponent","RemovedComponent","Entity","components","_componentsToRemove","_componentTypeToInstance","_componentStringToInstance","_tagsMemo","_typesMemo","componentAdded$","_isInitialized","_setName","component","addComponent","tags","addTag","force","removeComponent","_rebuildMemos","added","removed","componentRemoved$","getAncestors","queue","curr","newEntity","types","addChild","templateEntity","getComponents","addTemplate","ctor","constuctorType","onAdd","_notifyAddComponent","componentOrType","_removeComponentByType","onRemove","delete","_notifyRemoveComponent","isInitialized","onInitialize","PreUpdateEvent","onPreUpdate","onPostUpdate","_initialize","_preupdate","_postupdate","hasGraphicsTick","graphic","tick","_graphics","graphics","gfx","nameOrGraphic","getGraphic","copyGraphics","getNames","recalculateBounds","hide","show","order","currentKeys","_component","_layers","_layerMap","default","GraphicsLayer","_maybeAddLayer","_getLayer","graphicsLayerKeys","visible","onPreDraw","onPostDraw","layers","GraphicsLayers","graphicToSet","offsetX","offsetY","elapsed","idempotencyToken","Rectangle","_radius","PointerComponent","useGraphicsBounds","easing","Linear","EasingFunctions","CreateReversibleEasingFunction","startValue","endValue","EaseInQuad","EaseOutQuad","EaseInOutQuad","EaseInCubic","EaseOutCubic","EaseInOutCubic","ActionQueue","_actions","_completedActions","_entity","action","_currentAction","getActions","isComplete","Repeat","repeatBuilder","repeat","_stopped","_repeatBuilder","_repeatContext","ActionContext","_actionQueue","getQueue","_repeat","_originalRepeat","clearActions","MoveBy","speed","_started","_tx","_motion","_speed","_offset","_start","_end","_distance","destx","desty","RotationType","rotationType","_rotationType","ShortestPath","_currentNonCannonAngle","distance1","distance2","_shortDistance","_longDistance","_shortestPathIsPositive","_direction","LongestPath","Clockwise","CounterClockwise","distanceTraveled","RotateBy","angleRadiansOffset","speedX","speedY","_endX","_endY","_speedX","_speedY","_startX","_startY","_distanceX","_distanceY","directionX","directionY","scaleOffsetX","scaleOffsetY","_startScale","_endScale","_directionX","_directionY","CallMethod","_method","_hasBeenCalled","easingFcn","_currentLerpTime","_lerpDuration","_lerpStart","_lerpEnd","_initialized","Blink","timeVisible","timeNotVisible","numBlinks","_timeVisible","_timeNotVisible","_elapsedTime","GraphicsComponent","_totalTime","endOpacity","_multiplier","_endOpacity","_ogspeed","_delay","ActionsComponent","kill","entityToFollow","followDistance","_followTx","_followMotion","_current","_maximumDistance","actorToFollowSpeed","_distanceBetween","actorToMeet","_speedWasSpecified","_meetTx","_meetMotion","actorToMeetSpeed","_queue","EaseTo","EaseBy","yOrSpeed","speedOrUndefined","xOrPos","MoveTo","yOffsetOrSpeed","xOffset","yOffset","xOffsetOrVector","RotateTo","sizeYOrSpeed","speedXOrUndefined","speedYOrUndefined","sizeXOrVector","ScaleTo","sizeX","sizeY","sizeOffsetYOrSpeed","sizeOffsetXOrVector","ScaleBy","sizeOffsetX","sizeOffsetY","Fade","Delay","Die","times","repeatForever","RepeatForever","Follow","Meet","runAction","easeTo","easeBy","moveBy","rotateTo","rotateBy","scaleTo","scaleBy","blink","fade","die","callMethod","follow","meet","toPromise","FontUnit","TextAlign","FontStyle","Direction","Font","_o","_p","_q","_r","family","Normal","bold","unit","Px","textAlign","baseAlign","Alphabetic","LeftToRight","_textBounds","_cachedTextMeasurement","_bitmapToTextMeasurement","_textToBitmap","_bitmapUsage","_textFragments","blur","measurementDirty","cached","rasterProps","_getRasterPropertiesHash","_getTextBitmap","_applyFont","metrics","textHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","lineAdjustedHeight","bottomBounds","measurement","actualBoundingBoxLeft","actualBoundingBoxRight","textBounds","fontString","textBaseline","font","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","_drawText","colorOverride","lineHeight","line1","strokeText","textAndHash","textImages","currentX","currentY","clearCache","checkAndClearCache","isNewBitmap","_setDimension","frag","_splitTextBitmap","frag1","frag2","performance","cacheSize","_textWidth","_textHeight","Text","_font","_calculateDimension","isStale","config","_anchor","_handleAnchorChange","scene","_draggable","_dragging","_pointerDragStartHandler","_pointerDragEndHandler","_pointerDragMoveHandler","pe","_pointerDragLeaveHandler","collisionGroup","Actor","defaults","Passive","thePos","theVel","theAcc","theAngle","isOffScreen","hasTag","draggable","isDraggable","currentGraphic","_scene","onPreKill","PostKillEvent","onPostKill","_prekill","_postkill","newZ","getGlobalPos","getGlobalScale","recurse","geom","containment","otherCollider","me","ScreenElement","useBoxCollider","useWorld","coords","fcn","interval","repeats","numberOfRepeats","randomRange","_numberOfTicks","maxNumberOfRepeats","_baseInterval","_generateRandomInterval","_complete","Timer","_MAX_ID","_callbacks","complete","_running","_totalTimeAlive","newInterval","newNumberOfRepeats","timeToNextAction","timeElapsedTowardNextAction","isRunning","cancelTimer","ParallaxComponent","parallaxFactor","useTransform","_token","_onScreenXStart","_onScreenXEnd","_onScreenYStart","_onScreenYEnd","tiles","_rows","_cols","renderFromTopOfGraphic","_collidersDirty","_originalOffsets","DebugGraphicsComponent","_composite","_oldPos","tileWidth","tileHeight","currentCol","cd","Tile","flagCollidersDirty","originalOffset","clearColliders","tile","solid","_getOrSetColliderOriginalOffset","prev","getTile","_updateColliders","getWorldBounds","worldCoordsUpperLeft","worldCoordsLowerRight","maybeParallax","parallaxOffset","oneMinusFactor","currentScene","PreDrawEvent","xEnd","yEnd","graphicsIndex","graphicsLen","getGraphics","PostDrawEvent","grayish","pos1","_posDirty","_solid","_recalculate","_bounds","StrategyContainer","lockToActor","addStrategy","LockCameraToActorStrategy","lockToActorAxis","LockCameraToActorAxisStrategy","elasticToActor","cameraElasticity","cameraFriction","ElasticToActorStrategy","radiusAroundActor","RadiusAroundActorStrategy","limitCameraBounds","box","LimitCameraBoundsStrategy","_cam","_eng","cam","currentFocus","getFocus","focus","cameraVel","stretch","boundSizeChecked","focusX","focusY","_cameraStrategies","strategy","dz","_angularVelocity","_posChanged","watchAny","_cameraMoving","_isShaking","_shakeMagnitudeX","_shakeMagnitudeY","_shakeDuration","_elapsedShakeTime","_xShake","_yShake","_isZooming","_zoomEnd","_currentZoomTime","_zoomDuration","_zoomEasing","_easing","_halfWidth","_halfHeight","_follow","ax","ay","easingFn","_lerpPromise","_lerpResolve","magnitudeY","magnitudeX","_zoomStart","_zoomPromise","cameraStrategy","_screen","currentRes","loadingComplete","res","updateTransform","runStrategies","InitializeEvent","az","newZoom","zoomEasing","_zoomResolve","lerpPoint","CreateVectorEasingFunction","moveEasing","_isDoneShaking","newCanvasWidth","newCanvasHeight","cameraPos","triggerDefaults","opts","EnterTriggerEvent","_dispatchAction","_target","SystemType","_entityAddedOrRemoved","isAddedSystemEntity","RemovedEntity","isRemoveSystemEntity","EntityManager","_world","entities","_entityIndex","_entitiesToRemove","removeEntity","queryManager","addEntity","isRemovedComponent","idOrEntity","deferred","unregister","currFrame","actors","killed","processComponentRemoval","localeCompare","_entities","T","_key","buildTypeKey","matches","AddedEntity","typesOrEntity","_queries","entityManager","queryType","contain","getQuery","maybeExistingQuery","Query","_addQuery","systems","initialized","systemType","find","system","createQuery","maybeRemoveQuery","preupdate","s1","getEntities","Scene","s2","postupdate","removeSystem","QueryManager","systemManager","SystemManager","Update","updateEntities","updateSystems","findEntitiesForRemoval","processComponentRemovals","processEntityRemovals","entityOrSystem","System","addSystem","totalAcc","EulerIntegrator","_ACC","_VEL","_POS","_VEL_ACC","_SCALE_FACTOR","_SCALE","optionalBody","captureOldTransform","integrate","ArcadeSolver","directionMap","distanceMap","solve","preSolve","isCanceled","solvePosition","solveVelocity","postSolve","squareDistance","opposite","velAdj","velAdj1","normalImpulse","tangentImpulse","normalMass","tangentMass","aToContact","bToContact","originalVelocityAndRestitution","aToContactNormal","bToContactNormal","aToContactTangent","bToContactTangent","velA","lastFrameContacts","idToContactConstraint","CollisionPreSolveEvent","matchAwake","finishedContactIds","contact1","contactPoints","pointIndex","ContactConstraintPoint","restitution","relativeVelocity","getRelativeVelocity","contact2","contactPoints1","getContactConstraints","point1","updateMotion","CollisionPostSolveEvent","constraints","maxCorrection","steeringForce","slop","impulseForce","impulseForce1","impulseDelta","maxFriction","newImpulse","normalVelocity","impulseDelta1","newImpulse1","impulse1","_realisticSolver","RealisticSolver","_arcadeSolver","_processor","_lastFrameContacts","_currentFrameContacts","_trackCollider","_untrackCollider","colliderComponent","colliderComponent1","colliderComp","compositeColliders","broadphase","narrowphase","getSolver","compositeId","substring","runContactStartEnd","id1","c1","colliderA1","colliderB1","ContactEndEvent","AnimationDirection","AnimationStrategy","frames","Loop","frameDuration","timeScale","_idempotencyToken","_firstTick","_currentFrame","_timeLeftInFrame","_done","_playing","_reversed","totalDuration","goToFrame","Animation","maybeFrame","currentFrame","frameIndices","durationPerFrameMs","invalidIndices","currentFrameIndex","Backward","Forward","canFinish","End","Freeze","frameNumber","PingPong","elapsedMilliseconds","_nextFrame","members","_updateDimensions","GraphicsGroup","member","maybeAnimation","_isAnimationOrGroup","base","props","assign","EmitterType","ParticleImpl","emitterOrConfig","life","beginColor","endColor","velocity","acceleration","startSize","endSize","particleRotationalVelocity","currentRotation","focusAccel","fadeFlag","_rRate","_gRate","_bRate","_aRate","_currentColor","emitter","particleSize","particleSprite","sizeRate","elapsedMultiplier","isOffscreen","ParticleEmitter","tmpColor","drawPoint","removeParticle","accel","Configurable","_particlesToEmit","numParticles","isEmitting","particles","deadParticles","minVel","maxVel","minAngle","maxAngle","emitRate","particleLife","minSize","maxSize","_sprite","emitterType","randomRotation","particle","emitParticles","particleCount","_createParticle","world","clearParticles","ranX","ranY","Particle","remove","GraphicsSystem","Draw","_sortedTransforms","_zHasChanged","_zIndexUpdate","_graphicsContext","entityAddedOrRemoved","unsubscribe","parallax","_applyTransform","particleOpacity","_drawGraphicsComponent","graphicsComponent","isDebug","showBounds","offset1","boundsColor","ancestor","ancestors","interpolatedPos","interpolatedScale","interpolatedRotation","fixedUpdateFps","blend","currentFrameLagMs","CollisionSystem","entitySettings","useFilter","filterSettings","ids","nameQuery","cursor","_pushCameraTransform","txSettings","showAll","showPosition","positionColor","showPositionLabel","drawText","showZIndex","showId","showName","showRotation","fromAngle","rotationColor","showScale","scaleColor","graphicsSettings","debugDraw","bodySettings","showCollisionGroup","showCollisionType","showMass","showMotion","showSleeping","motionSettings","showVelocity","velocityColor","showAcceleration","accelerationColor","colliderSettings","showGeometry","geometryColor","bounds1","showOwner","bounds2","_popCameraTransform","physicsSettings","showBroadphaseSpacePartitionDebug","_collisionSystem","showCollisionContacts","showCollisionNormals","collisionContactColor","collisionNormalColor","cameraSettings","showFocus","focusColor","showZoom","PointerSystem","overrideUseColliderShape","overrideUseGraphicsBounds","lastFrameEntityToPointers","currentFrameEntityToPointers","_sortedEntities","_receiver","pointers","entityCurrentlyUnderPointer","pointerId","entityWasUnderPointer","_processPointerToEntity","_dispatchEvents","$953cdf9ae7e8a925$var$imageSources","$2c23f148d58cd887$export$280e9a68c3ffd919","$2c23f148d58cd887$export$3b0d6d7590275603","$2c23f148d58cd887$export$c35d437ae5945fcd","imageSource","$2c23f148d58cd887$export$3075603db8e6204c","$ad2bcec7a0192558$var$game","$2c23f148d58cd887$export$2c3b404bf3a77a1f","$ad2bcec7a0192558$var$paddle","$2c23f148d58cd887$export$f73d3eb6fd876d80","$2c23f148d58cd887$export$892596cec99bc70e","$2c23f148d58cd887$export$ddb2ed749236e720","primary","$ad2bcec7a0192558$var$ball","$ad2bcec7a0192558$var$ballSpeed","$2c23f148d58cd887$export$202e0172ed3c7be0","$ad2bcec7a0192558$require$zombieAnimation","actions","$2c23f148d58cd887$export$91397be43fc980cc","$ad2bcec7a0192558$var$brickColor","$ad2bcec7a0192558$var$brickWidth","$ad2bcec7a0192558$var$padding","$ad2bcec7a0192558$var$bricks","brick","$ad2bcec7a0192558$var$colliding","alert","$ad2bcec7a0192558$require$loader"],"version":3,"file":"index.8e1b6af1.js.map"}